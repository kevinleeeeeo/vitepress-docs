# ECMA

## 作业

**作业一**

```
var plan = '做大餐';
var week = window.prompt('请填写星期几');

switch (week) {
  case '星期一':
    document.write(week);
    break;
  case '星期二':
    document.write(week);
    break;
  case '星期三':
    document.write(week);
    break;
  case '星期四':
    document.write(week);
    break;
  case '星期五':
    document.write(week);
    break;
  case '星期六':
    document.write(week);
    break;
  case '星期日':
    document.write(week);
    break;
  default:
    week = false;
}

var day = window.prompt('选择上午或者下午');

switch (day) {
  case '上午':
    document.write(day);
    break;
  case '下午':
    document.write(day);
    break;
  default:
    day = false;
}

if (week && day) {
  document.write('的安排: ' + plan)
} else {
  document.write('没有安排')
}
```

```
//日程安排
var weekday = window.prompt('请输入星期几');
var time = window.prompt('请输入上午或下午'); \

switch (weekday) {
  case '星期一':
    if (time == '上午') {
      console.log('看书');
    } else if (time == '下午') {
      console.log('逛街');
    }
    break;
}
```

**作业二**

`for`循环写斐波那契数列(黄金分割数列、兔子数列)，

算出第n位

只知道两位，然后算出后面的值，前两位的和等于后一位

1 1 2 3 5 8...

```
//循环一： n1 n2 n3
//         1  1  2  3  5  8
//循环二：    n1 n2 n3
//循环三：       n1 n2 n3
//循环四：          n1 n2 n3

//前两位是确定的
//n3 = n1 + n2

var n =parseInt(window.prompt('请输入第几位'));
var n1 = 1,
  n2 = 1,
  n3;
if (n < 0) {
  console.log('输入数字错误');
} else {
  if (n <= 2) {
    n3 = 1;
    }
  for (var i = 2; i < n; i++){
    n3 = n1 + n2;
    n1 = n2;
    n2 = n3;
  }
  console.log(n3);
}
```

**作业三**

定义一个函数，从wp接收一个饮料的名称，函数返回对应的价格(switch or if)

```
function softDrinkPrice(name) {
  switch (name) {
    case '可乐':
      console.log('2.5元');
      break;
    case '雪碧':
      console.log('2.6元');
      break;
    default:
      console.log('请输入饮料名称');
  }
}
softDrinkPrice('可乐'); //2.5元
softDrinkPrice('雪碧'); //2.5元
softDrinkPrice('哈哈哈'); //请输入饮料名称
```

**作业四**

定义一个函数，从wp接收第一个数，接收一个运算符号(`+`,`-`,`*`,`/`,`%`)，接收第二个数，利用函数做运算并返回运算结果

```
function Cal(calSign, num1, num2) {
  switch (calSign) {
    case '+':
      console.log(num1 + num2);
      break;
    case '-':
      console.log(num1 - num2);
      break;
    case '*':
      console.log(num1 * num2);
      break;
    case '/':
      console.log(num1 / num2);
      break;
    case '%':
      console.log(num1 % num2);
      break;
    default:
      return console.log('请输入运算符号');
  }
}

// Cal('+', 1, 2); //3
// Cal('-', 1, 2); //-1
// Cal('*', 1, 2); //2
// Cal('/', 1, 2); //0.5
// Cal('%', 1, 2); //1
```



**作业五**

定义一个函数，从wp接收一个n，算出n的阶乘，不能用for循环

```
//result = 1 x 2 x 3 x ... x n
//规律 n = n * (n - 1)
//出口 
function factor(num) {
  if (num < 0) {
    return -1;
  } else if (num === 0 || num === 1) {
    return 1;
  } else {
    return (num * factor(num - 1));
  }
}
console.log(factor(5)); //120

//队列
//fact(5) = 5 * fact(4);
//fact(4) = 4 * fact(3);
//fact(3) = 3 * fact(2);
//fact(2) = 2 * fact(1);

//fact(5) = 5 * 4;
//fact(4) = 4 * 3;
//fact(3) = 3 * 2;
//fact(2) = 2 * 1;
```

定义一个函数，从wp接收一个n，算出斐波那契数列的第n位，不能用for循环

```
//1 1 2 3 5 8 ...
//规律：n3 = n2 + n1;
//出口：n <= 2
function fibo(n) {
  if (n == 1 || n == 2) {
    return 1
  };
  return fibo(n - 1) + fibo(n - 2);
};
console.log(fibo(6));

n = 5;
fb(5) = fb(4) + fb(3);
fb(4) = fb(3) + fb(2);
fb(3) = fb(2) + fb(1);

fb(5) = 3 + 2;
fb(4) = 2 + 1;
fb(3) = 1 + 1;

fb(5) = 5 
```

**作业六**

写闭包累加器，执行一次打印一次

```
function accumulator(num) {
  var num = arguments[0] || 1;
  function like() {
    num++;
    console.log(num);
  }
  function unlike() {
    num--;
    console.log(num);
  }
  return [like, unlike];
}
var result = accumulator();
result[0]()
result[0]()
result[1]()
```

写一个缓存区，一个班级，学生名字保存在一个数组里，

两个方法写在函数的一个对象中，第一个方法是加入半接，第二个方法是离开班级，

每次加入或离开，都需要打印新的学生名单

```
function classOne(name) {
  var sList = [];
  var operate = {
    enter: function () {
      console.log(name + '加入班级');
      sList += name;
    },
    leave: function () {
      console.log(name + '离开班级');
      sList -= name;
    }
  }
  return operate;
}
classOne('大田').enter();
classOne('大田').leave();
```

```
function myClass() {
  var sList = [];
  var operation = {
    join: function (name) {
      sList.push(name);
      console.log(sList);
    },
    leave: function (name) {
      for (var i = 0; i < sList.length; i++) {
        var item = sList[i];
        if (item === name) {
          sList.splice(i, 1);
        }
      }
    }
  }
  return operation;
}

var obj = myClass();
obj.join('zhangsan');
obj.join('lisi');
obj.join('wangwu');
obj.leave('lisi');
```

**作业七**

写一个构造函数，接收数字类型的参数，参数数量不定，完成参数相加和相乘的功能

```
function MyMath(option) {
  this.number1 = option.number1;
  this.number2 = option.number2;

  this.add = function () {
    console.log(this.number1 + this.number2);
  }
  this.mul = function () {
    console.log(this.number1 * this.number2);
  }
}

var test = new MyMath({
  number1: 2,
  number2: 10
});
test.add();
test.mul();
```

```
function Compute() {
  var args = arguments,
    res;
  this.plus = function () {
    res = 0;
    loop('add', res);
  }
  this.times = function () {
    res = 1;
    loop('mul', res);
  }
  function loop(method, res) {
    for (var i = 0; i < args.length; i++) {
      var item = args[i];
      if (method === 'add') {
        res += item;
      } else if (method === 'mul') {
        res *= item;
      }
    }
    console.log(res);
  }
}
var compute = new Compute(2, 4, 6);
compute.plus(); //12 
compute.times(); //48
```

```
function Compute() {
  var res = 0;
  this.plus = function (args) {
    // console.log(arguments);
    loop(arguments, 'add', res);
  }
  this.times = function (args) {
    res = 1;
    loop(arguments, 'mul', res);
  }

  function loop(args, method, res) {
    for (var i = 0; i < args.length; i++) {
      var item = args[i];
      if (method === 'add') {
        res += item;
      } else if (method === 'mul') {
        res *= item;
      }
    }
    console.log(res);
  }
}
var compute = new Compute();
compute.plus(2, 4, 6); //12 
compute.times(3, 5, 7); //48
```

**作业八**

写一个构造车的函数，可设置车的品牌，颜色，排量，再写一个构造消费者的函数，设置用户的名字，年龄，收入，通过选择的方法实例化该用户喜欢的车，再设置车的属性

```
function Car(option) {
  this.brand = option.brand;
  this.color = option.color;
  this.displacement = option.displacement;
}

function User(option) {
  this.name = option.name;
  this.age = option.age;
  this.incoming = option.incoming;
  this.carSelect = option.carSelect;

}

var test = new MyMath({
  number1: 2,
  number2: 10
});
test.add();
test.mul();
```

```
function Car(color, brand, displacement) {
  this.brand = brand;
  this.color = color;
  this.displacement = displacement;
  this.drive = function () {
    console.log('I am driving');
  }
}

var car = new Car('red', 'mazda');
console.log(car.color);
console.log(car.brand);
car.drive();
```

```
function Car(opt) {
  this.brand = opt.brand;
  this.color = opt.color;
  this.displacement = opt.displacement;
}

function Person(opt) {
  this.name = opt.name;
  this.age = opt.age;
  this.income = opt.income;
  this.selectCar = function () {
    var myCar = new Car(opt.carOpt);
    console.log(this.name + '挑选了一辆排量为: ' + myCar.displacement + '的' + myCar.color + '的' + myCar.brand);
  }
}
var james = new Person({
  name: 'james',
  age: 18,
  income: '15k',
  carOpt: {
    brand: 'Mazda',
    color: '红色',
    displacement: '2.5L'
  }
});
james.selectCar();
```

**作业九**

写一个函数，接收任意一个字符串，算出这个字符串的总字节数

```
function seachASCII(str) {
  var byte = 0;
  var result = 0;
  for (var i = 0; i < str.length; i++) {
    var pos = str.charCodeAt(i);
    if (pos < 255) {
      byte = 1;
    } else {
      byte = 2;
    }
    result += byte;
  }
  console.log(result);
}
seachASCII('abcdefa'); //7
```

写插件，任意传两个数字，调用插件内部方法可进行加减乘除功能

```
var compute = (function () {
  function Compute() {
    var result = 0;
    switch (arguments[0].method) {
      case 'add':
        add(arguments[0]);
        break;
      case 'reduce':
        reduce(arguments[0]);
        break;
      case 'mul':
        mul(arguments[0]);
        break;
      case 'div':
        div(arguments[0]);
        break;
      default:
        console.log('请输入正确的运算符');
    }
    function add(arg) {
      result = arguments[0].a + arguments[0].b;
      console.log(result);
    }
    function reduce(arg) {
      result = arguments[0].a - arguments[0].b;
      console.log(result);
    }
    function mul(arg) {
      result = arguments[0].a * arguments[0].b;
      console.log(result);
    }
    function div(arg) {
      result = arguments[0].a / arguments[0].b;
      console.log(result);
    }
  }
  return Compute;
})();

compute({
  a: 1,
  b: 2,
  method: 'mul'
});
```

```
var compute = (function () {
  function Compute(opt) {
    this.a = opt.a || 0;
    this.b = opt.b || 0;
    this.method = opt.method;
    switch (this.method) {
      case 'add':
        Compute.prototype.add(this.a, this.b);
        break;
      case 'reduce':
        Compute.prototype.reduce(this.a, this.b);
        break;
      case 'mul':
        Compute.prototype.mul(this.a, this.b);
        break;
      case 'div':
        Compute.prototype.div(this.a, this.b);
        break;
    }
  }

  Compute.prototype = {
    add: function (a, b) {
      console.log(a + b);
    },
    reduce: function (a, b) {
      console.log(a - b);
    },
    mul: function (a, b) {
      console.log(a * b);
    },
    div: function (a, b) {
      console.log(a / b);
    }
  }
  return Compute;
})();

new compute({
  a: 1,
  b: 2,
  method: 'div'
});
```

**作业十**

年龄为多少岁姓名为XX买了一辆排量为XX的XX颜色的XX牌子的车

```
//硬性规定两个构造函数Car和Person合并
function Car(displacement, color, brand) {
  this.displacement = displacement;
  this.color = color;
  this.brand = brand;
}

function Person(args) {
  var carLike = args.carLike;
  Car.apply(this, carLike);
  this.name = args.name;
  this.age = args.age;
  this.carSelect = function () {
    console.log('年龄为' + this.age + '岁' + '姓名为' + this.name + '买了一辆排量为' + this.displacement + '的' + this.color + '颜色的' + this.brand + '牌子的车');
  }
}

var person = new Person({
  name: 'kevin',
  age: 30,
  carLike: ['2.5L', 'grey', 'Mazda']
});
person.carSelect();
```

写模块化：

- 功能一：打印一个参数值以内能被3或5或7整除的数值
- 功能二：打印斐波那契数列的第N位
- 功能三：打印从0到100的累加值

```
window.onload = function () {
  init();
}

function init() {
  initComputeDiv(10);
  initComputeFibo(10);
  initComputeAcc(10);
}

var initComputeDiv = (function () {
  //打印一个参数值以内能被3或5或7整除的数值
  function div(num) {
    var arr = [];
    for (var i = 0; i < num; i++) {
      if (i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {
        arr.push(i);
      }
    }
    console.log(arr);
    return this;
  }
  return div;
})();

var initComputeFibo = (function () {
  //打印斐波那契数列的第N位
  function fibo(n) {
    var n1 = 1,
      n2 = 1,
      n3;
    if (n < 0) {
      console.log('数字错误');
    } else {
      if (n <= 2) {
        n3 = 1;
      }
      for (var i = 2; i < n; i++) {
        n3 = n1 + n2;
        n1 = n2;
        n2 = n3;
      }
      console.log(n3);
    }
  }

  return fibo;
})();

var initComputeAcc = (function () {
  //打印从0到100的累加值
  function sum(num) {
    var result = 0;
    for (var i = 0; i <= num; i++) {
      result += i;
    }
    console.log(result);
  }

  return sum;
})();
```

```
//请用window.prompt接收用户输入的年份，判断是否是闰年？(三目运算符)
//整除4 并且不能整除100
//整除400
var year = window.prompt('请输入年份');
(year % 4 == 0 && year % 100 !== 0) || year % 400 === 0 ? console.log('是闰年') : console.log('不是闰年');
```

**作业十一**

用`splice()`重写原型数组的原型上的`unshift()`方法`myUnshift()`

```
var arr = ['d', 'e', 'f'];
//['a', 'b', 'c', 'd', 'e', 'f']

Array.prototype.myUnshift = function () {
  //unshift 在第一位前面加
  //返回值都为执行了方法以后数组长度
  //传入实参列表

  for (var i = arguments.length - 1; i >= 0; i--) {
    // console.log(arguments[i]); //c b a
    //arr.splice(开始项的下标，剪切长度，剪切以后最后一位开始添加数据)
    this.splice(0, 0, arguments[i]);
  }

  //功能2：返回执行方法以后数组长度
  return this.length;
}

arr.myUnshift('a', 'b', 'c');
console.log(arr);
```

```
Array.prototype.myUnshift = function () {
  var pos = 0;
  for (var i = 0; i < arguments.length; i++){
    // console.log(arguments[i]);//a b c
    this.splice(pos, 0, arguments[i]);
    pos++;
  }
  return this.length;
}
arr.myUnshift('a', 'b', 'c');
console.log(arr);
```

```
//利用concat()数组拼接
Array.prototype.myUnshift = function () {
  //先让类数组转为数组
  var argArr = Array.prototype.slice.call(arguments);
  // console.log(argArr); //["a", "b", "c"]
  //返回值：修改原数组
  arr = argArr.concat(this);
  return arr.length;
}
arr.myUnshift('a', 'b', 'c'); //["a", "b", "c", "d", "e", "f"]
// arr.myUnshift(1); //[1, "d", "e", "f"]
console.log(arr);
```

请按照字节数排序下列数组，`charCodeAt() > 255`

`['我爱你', 'OK', 'Hello', '你说WHAT', '可以']`

```
// //请按照字节数排序下列数组
var arr = ['我爱你', 'OK', 'Hello', '你说WHAT', '可以'];
var newArr = [];

for (var i = 0; i < arr.length; i++) {
  // console.log(i); // console.log(i); 0 1 2 3 4
  // console.log(arr[i]); //我爱你 OK Hello 你说WHAT 可以
  // console.log(arr[0]); //我爱你
  var res = seachASCII(arr[i]); //6 2 5 8 4

  //{
  //  6: '我爱你',
  //  2: 'OK'
  //}

  var obj = {};
  //对象键名 = 对象键值
  obj[res] = arr[i];
  // console.log(obj);

  /**
   * {6: "我爱你"}
   * {2: "OK"}
   * {5: "Hello"}
   * {8: "你说WHAT"}
   * {4: "可以"}
   */

  newArr.push(obj);
}

newArr.sort(function (a, b) {
  if (a[res] > b[res]) {
    return 1;
  } else {
    return -1;
  }
})

console.log(newArr);

function seachASCII(str) {
  var byte = 0;
  var result = 0;
  for (var i = 0; i < str.length; i++) {
    var pos = str.charCodeAt(i);
    if (pos < 255) {
      byte = 1;
    } else {
      byte = 2;
    }
    result += byte;
  }
  return result;
}

// var arr = [];
// for (var i = 0; i < 5; i++) {
//   arr.push(i);
// };
// console.log(arr);
```

```
//数组按照元素的字节数排序
var arr = ['我爱你', 'OK', 'Hello', '你说WHAT', '可以'];

arr.sort(function (a, b) {
  //比较函数获取到的字符即可
  return getBytes(a) - getBytes(b);
})

//unicode 0-255 -> 1个字节
//unicode > 255 -> 2个字节
function getBytes(str) {
  //我爱你 -> bytes = 3
  //不管中文还是英文都当成一个字节
  //让下面判断的时候再决定是否加一个字节
  var bytes = str.length;

  for (var i = 0; i < str.length; i++){
    //逐个查询字符遇到>255的加一个字节
    if (str.charCodeAt(i) > 255) {
      bytes++;
    }
  }
  return bytes;
}
console.log(getBytes('我爱你')); //6
console.log(arr); //["OK", "可以", "Hello", "我爱你", "你说WHAT"]
```

```
//数组去重
//Array.protype原型上写unique方法
//实现数据去重 返回新的数组
//重复的项目剔除
//可以用对象属性的方式
//把属性或者值拿出来重新做一个数组

var arr = [0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 'a', 'a'];

Array.prototype.unique = function () {
  var temp = {},
    newArr = [];
  for (var i = 0; i < this.length; i++) {
    // console.log(this[i]); //0, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 'a', 'a'

    //写法一：
    // if (!temp[this[i]]) {
    //   //temp对象属性 = arr对象属性
    //   // temp[this[i]] = this[i];
    //   //过滤0改写为'1111'
    //   temp[this[i]] = '1111';
    //   // console.log(temp);
    //   //{0: "1111", 1: "1111", 2: "1111", 3: "1111", a: "1111"}
    //   newArr.push(this[i]);
    // }

    //写法二：
    if (!temp.hasOwnProperty(this[i])) {
      //temp对象属性 = arr对象属性
      temp[this[i]] = this[i];
      console.log(temp);
      //{0: 0, 1: 1, 2: 2, 3: 3, a: "a"}
      newArr.push(this[i]);
    }
  }
  return newArr;
}
//这里发现0没过滤掉 因为!temp[this[i] -> !0 -> true
console.log(arr.unique()); //[0, 0, 1, 2, 3, "a"] 
console.log(arr.unique()); //[0, 1, 2, 3, "a"]

//原理分析：

// //借用对象不重复性的属性
// //根据数组判断自身有没有该属性
// //如果没有就给该对象添加属性

// var obj = {
//   0: 0,
//   1: 1,
//   2: 2
// }

// //给对象放属性的同时给数组也添加元素
// var newArr = [];
```

```
//字符串去重

var str = '111222000aabb';

String.prototype.unique = function () {
  var temp = {},
    newStr = '';

  for (var i = 0; i < this.length; i++) {
    if (!temp.hasOwnProperty(this[i])) {
      temp[this[i]] = this[i];
      newStr += this[i];
    }
  }
  return newStr;
}

console.log(str.unique()); //120ab
```

```
//找出不重复的字符串并返回次数
var str = 'truaiwrtruibowrtpoiwrcutwopirut';

function test(str) {
  var temp = {};

  for (var i = 0; i < str.length; i++) {
    if (temp.hasOwnProperty(str[i])) {
      // console.log(temp[str[i]]);
      temp[str[i]]++;
    } else {
      temp[str[i]] = 1;
    }
  }
  return temp;
}
console.log(test(str));
/**
 * {t: 5, r: 6, u: 4, a: 1, i: 4, …}
     a: 1
     b: 1
     c: 1
     i: 4
     o: 3
     p: 2
     r: 6
     t: 5
     u: 4
     w: 4
     __proto__: Object
 */
```

```
//封装myTypeof方法
//Object.prototype.toString.call();

//原始值:
//typeof('123') -> 'string'; 
//typeof(123) -> 'number'; 
//typeof(null) -> 'object'; 
//typeof(NaN) -> 'number';
//typeof(undefined) -> 'undefined';
//typeof(true) -> 'boolean';
//toString.call('123') -> '[object String]'
//toString.call(123) -> '[object Number]'
//toString.call(null) -> '[object Null]'
//toString.call(NaN) -> '[object Number]'
//toString.call(undefined) -> '[object Undefined]'
//toString.call(true) -> '[object Boolean]'

//引用值
//typeof({}) -> 'object';
//typeof([]) -> 'object';
//typeof(function(){}) -> 'function';
//toString.call({}) -> '[object Object]'
//toString.call([]) -> '[object Array]'
//toString.call(function(){}) -> '[object Function]'

//包装类
//typeof(new Number(1)) -> 'object';
//typeof(new String('1')) -> 'object';
//typeof(new Boolean(true)) -> 'object';
//toString.call(new Number(1)) -> '[object Number]'
//toString.call(new String('123')) -> '[object String]'
//toString.call(new Boolean(true)) -> '[object Boolean]'

function myTypeof(val) {
  var toStr = Object.prototype.toString,
    type = typeof (val),
    res = toStr.call(val);

  //包装类和 引用值 null {} [] 
  if (type === 'object') {
    switch (res) {
      case '[object Null]':
        type = 'null';
        break;
      case '[object Object]':
        type = 'object';
        break;
      case '[object Array]':
        type = 'array';
        break;
      case '[object Number]':
        type = 'object number';
        break;
      case '[object String]':
        type = 'object string';
        break;
      case '[object Boolean]':
        type = 'object boolean';
        break;
    }
  }
  return type;
}

//原始值
console.log(myTypeof('123')); //'string'
console.log(myTypeof(123)); //'number'
console.log(myTypeof(null)); //'null'
console.log(myTypeof(NaN)); //'number'
console.log(myTypeof(undefined)); //'undefined'
console.log(myTypeof(true)); //'boolean'
//引用值
console.log(myTypeof({})); //'object'
console.log(myTypeof([])); //'array'
console.log(myTypeof(function () {})); //'function'
//包装类
console.log(myTypeof(new Number(1))); //object number
console.log(myTypeof(new String('123'))); //object string
console.log(myTypeof(new Boolean(true))); //object boolean
```

```
//封装myTypeof()
function myTypeof(val) {
  var type = typeof (val),
    toStr = Object.prototype.toString,
    res = {
      '[object Array]': 'array',
      '[object Object]': 'object',
      '[object Number]': 'object number',
      '[object String]': 'object string',
      '[object Boolean]': 'object boolean'
    }
  if (val === null){
    return 'null';
    //object: null {} []
    //这里返回包括包装类Number, String, Boolean
  } else if (type === 'object') {
    var ret = toStr.call(val);
    return res[ret];
    //返回原始值
    //
  } else {
    return type;
  }
}
```

dom:

作业一：

```
//作业1 
//在原型上编程
//遍历任意一个父元素，找到他的子元素节点
//有数字参数 返回 某一个对应子元素
//没有数字参数 返回 子元素节点的集合

Document.prototype.findChildEleNode = function (fNode, num) {
  var fNode = arguments[0],
    sNode = fNode.childNodes,
    childEleSet = [],
    typeNum = arguments[1] || 0;
  // console.log(sNode);

  for (var i = 0; i < sNode.length; i++) {
    var nodeType = sNode[i].nodeType,
      childItem = sNode[i];
    // 有参数
    if (nodeType === typeNum) {
      childEleSet.push(childItem);
    } else {
      //没有参数
      // console.log(sNode);
      // childEleSet = sNode;
    }
  }
  return childEleSet;
}
console.log(document.findChildEleNode(div, 9));;
```

作业二

```
//作业2 
//在原型上编程
//找出一个元素的第n层父级元素 

var a = document.getElementsByTagName('a')[0];

Document.prototype.findFatherTagName = function (ele, n) {
  console.log(ele.parentNode.parentNode);
  var fatherEle = ele;
  for (var i = 1; i <= n; i++) {
    fatherEle = ele.parentNode;
  }
  return fatherEle;

}
document.findFatherTagName(a, 1)
```

作业三

```
//作业3：原型上编程hasChildren
//判断是否有子节点(包括文本节点)
//判断父元素有没有子元素节点
// parent.hasChildNodes
// console.log(div.hasChildNodes()); //true

Node.prototype.hasChildNodes = function () {
  var children = this.childNodes,
    eleNode = [],
    result = false;

  for (var i = 0; i < children.length; i++) {
    var item = children[i];
    if (item.nodeType === 1) {
      eleNode.push(item);
      // console.log(eleNode);
      if (eleNode) {
        result = true;
      } else {
        result = false;
      }
    }
  }
  return result;
}
console.log(div.hasChildNodes());
```

作业四

```
//作业4：原型上编程(未做完)
//寻找兄弟元素节点
//参数为正：找之后的第N个
//参数为负：找之前的第N个
Node.prototype.findEleSibling = function (num) {
  // console.log(this.nodeType);

  //拿到同级所有的节点
  var elem = this.parentNode.childNodes,
    elemList = [];
  //过滤除元素节点之外的节点
  for (var i = 0; i < elem.length; i++) {
    var item = elem[i];
    if (elem[i].nodeType === 1) {
      elemList.push(item);
    }
  }

  //找回原来位置 ????
  
  console.log(elemList[0]);
  // if (num > 0) {
  // } else if (num < 0) {
  //   num = Math.abs(num);
  //   // console.log(num);
  // }


  //负数
  //参数1： console.log(this.previousSibling.previousSibling);
  //参数2： console.log(this.previousSibling.previousSibling.previousSibling.previousSibling);

  //正数
  //参数1： 
  // console.log(this.nextSibling.nextSibling);
  //参数2： console.log(this.nextSibling.nextSibling.nextSibling.nextSibling)
}
div.findEleSibling(1);
```

```
//作业5： JS创建HTML结构
//div > ul > li class="list item" x 5
var div = document.createElement('div'),
  oList = document.createElement('ul'),
  oFrag = document.createDocumentFragment();

for (var i = 1; i <= 5; i++) {
  var oLi = document.createElement('li');
  oLi.innerHTML = i;
  oLi.className = 'list-item';
  oFrag.appendChild(oLi);
}
oList.appendChild(oFrag);
div.appendChild(oList);

console.log(div);
```

```
//作业6：遍历一个父级元素下面所有的子元素节点(未完成)
//递归
Node.prototype.findAllElem = function () {
  console.log(this);
  // console.log(this.childNodes[1].childNodes[1]);
  var elemList = [];

  for (var i = 0; i < this.childNodes.length; i++) {
    if (this.childNodes[i].nodeType === 1) {
      elemList.push(this.childNodes[i]);
      console.log(elemList);
    }
  }
}

div.findAllElem();
```

```
function elemChildren(node) {
  var temp = {
    'length': 0,
    'push': Array.prototype.push,
    'splice': Array.prototype.splice
  };

  var children = node.childNodes,
    len = children.length,
    item;

  for (var i = 0; i < len; i++) {
    item = children[i];
    if (item.nodeType === 1) {
      temp.push(item);
    }
  }
  return temp;
}

console.log(elemChildren(box)[1]);
```



事件流

作业1：

做列表 点击增加li 按钮 

1. 清空input框内容
2. list列表后增加项

```
<div>
  <input type="text" id="add" />
  <button class="addBtn">增加li</button>
  <ul class="list">
  </ul>
</div>
```

```
var oList = document.getElementsByClassName('list')[0],
  oInput = document.getElementById('add'),
  oBtn = document.getElementsByClassName('addBtn')[0];

oBtn.addEventListener('click', function (e) {
  var e = e || window.event,
    tar = e.target || e.srcElement,
    li = document.createElement('li');

  li.innerHTML = oInput.value;
  oList.appendChild(li);
  oInput.value = '';
}, false);
```

作业2：todolist

```
  <div>
    <input type="text" id="add" />
    <button class="addBtn">增加li</button>
    <ul class="list">

    </ul>
  </div>
```

```
// 作业1
// 做列表 点击增加li 按钮 
//新增：
//1.清空input框内容
//2.list列表后增加项
//编辑：
//1.点击某一项把某项数据填到输入框文本域
//2.点击按钮文本内容改为 编辑到第几项
//3.点击按钮成功修改该项信息

var oList = document.getElementsByClassName('list')[0],
  oInput = document.getElementById('add'),
  oBtn = document.getElementsByClassName('addBtn')[0],
  isEdit = false,
  inputValue = '',
  idx;

//动态创建的ul
var oItems = document.getElementsByClassName('item');

function init() {
  bindEvent();
}

//事件绑定
function bindEvent() {
  //按钮事件
  addEvent(oBtn, 'click', btnClick);
  //列表事件：修改
  addEvent(oList, 'click', edit);
  //列表事件：删除
  addEvent(oList, 'click', del);
}

function btnClick(e) {
  //情况1：输入框为空不能点按钮
  if (oInput.value.length === 0) {
    return;
  }

  //去重
  var _item;
  //遍历对比li里面的text
  for (var i = 0; i < oItems.length; i++) {
    _item = oItems[i].innerText.split(' ')[0];
    if (oInput.value === _item) {
      alert('已存在该项目');
      return;
    }
  }

  // 新增/编辑
  if (isEdit) {
    //编辑
    oItems[idx].innerHTML = tpl(oInput.value);
    reset();
    isEdit = false;
  } else {
    //新增
    add();
  }
}

// 新增操作
function add() {
  //增加操作: 1.获取输入框的文本值并保存至全局
  inputValue = oInput.value;
  //增加操作: 2.创建新的li节点并新增类名
  var oLi = document.createElement('li');
  oLi.className = 'item';
  //增加操作: 3.把处理好的字符串赋值到Li的文本里
  oLi.innerHTML = tpl(inputValue);
  //增加操作: 4.将处理好的li逐条加入到ul里
  oList.appendChild(oLi);
  //重置输入框内容
  reset();
  isEdit = false;
}

//修改操作
function edit(e) {
  var e = e || window.event,
    tar = e.target || e.srcElemnt;

  //点击到编辑时才能进行下面操作：
  if (tar.innerText === ' 编辑') {
    //修改操作: 1.拿到被点击的当前li项
    var oLi = elemParent(tar, 1),
      //修改操作: 2.拿到被点击的当前li项里面的文本内容
      text = oLi.innerText.split(' ')[0];
    //修改操作: 3.将文本内容放到文本输入框里
    oInput.value = text;

    //修改操作: 4.找到该项索引值并修改按钮文本信息
    idx = Array.prototype.indexOf.call(oItems, oLi);
    oBtn.innerText = '修改第' + (idx + 1) + '项';

    //激活可编辑状态
    isEdit = true;
    console.log('编辑状态：启用');
  }
}

function del(e) {
  var e = e || window.event,
    tar = e.target || e.srcElemnt;

  //点击到编辑时才能进行下面操作：
  if (tar.innerText === ' 删除') {
    //找到当前项
    var oLi = elemParent(tar, 1);
    //删除当前项
    elemParent(oLi, 1).removeChild(oLi);
  }
}

function tpl(text) {
  return (
    text +
    '<a href="javascript:;" style="text-decoration: none;"> 编辑</a>' +
    '<a href="javascript:;" style="text-decoration: none;"> 删除</a>'
  )
}

function reset() {
  oInput.value = '';
  oBtn.innerText = '增加li'
}

function findNodeElem(elem, type) {
  var _arrLike = {
      'length': 0,
      'push': Array.prototype.push,
      'slice': Array.prototype.slice
    },
    children = elem.childNodes,
    item;

  for (var i = 0; i < children.length; i++) {
    item = children[i];
    if (item.nodeType === 1) {
      _arrLike.push(item);
    }
  }
  return _arrLike;
}

/**
 * 封装兼容低版本的事件绑定处理函数
 * @el 元素
 * @type 事件类型
 * @fn 事件处理函数
 */
function addEvent(el, type, fn) {
  if (el.addEventListener) {
    el.addEventListener(type, fn, false);
  } else if (el.attachEvent) {
    el.attachEvent('on' + type, function () {
      fn.call(el);
    })
  } else {
    el['on' + type] = fn;
  }
}

/**
 * 封装找父级元素的函数
 * @node 子元素节点
 * @n 寻找第几个父级元素
 * @返回值 返回父级元素
 */
function elemParent(node, n) {
  var type = typeof (n);

  if (type === 'undefined') {
    return node.parentNode;
  } else if (n <= 0 || type !== 'number') {
    return undefined;
  }

  while (n) {
    node = node.parentNode;
    n--;
  }
  return node;
}

init();
```



## 面试题

```
var a = false + 1;
console.log(a); //1
```

```
var b = false == 1;
console.log(b); //false
```

```
//'undefined' -> true
//undefined -> false
//typeof (a) -> typeof (undefined) -> 'undefined' -> true
//(-true) -> -1
//(+undefined) -> Number(undefined) -> NaN
//(-1 + NaN + '') -> 'NaN' -> true
//true && true -> true -> console.log('通过了')

if (typeof (a) && (-true) + (+undefined) + '') {
  console.log('通过了');
} else {
  console.log('没通过');
}
```

```
//1 + 15 = 16 == 16 -> true
if (1 + 5 * '3' == 16) {
  console.log('通过了');
} else {
  console.log('未通过');
}

//16(number) => true
if (1 + 5 * '3' === 16) {
  console.log('通过了');
} else {
  console.log('未通过');
}
```

```
//' ' = false -> !! -> true
//'' = false -> !! -> flase
//!!false -> false
//true + false - false = 1 
// 1 || '通过了' -> 1 
console.log(!!' ' + !!'' - !!false || '通过了'); //1
```

```
//(a, b) 只返回逗号后面
var fn = (
  function test1() {
    return 1;
  },
  function test1() {
    return '2';
  }
)();
console.log(typeof (fn)); //string
```

```
//(function b() {})为表达式忽略b所以没有b，所以为undefined
//console.log(b)报错，但console.log(typeof (b))报undefined
//typeof (undefined) => undefined

var a = 10;
if (function b() {}) {
  a += typeof (b);
}
console.log(a); //10undefined
```

```
//面试题
function Foo() {
  getName = function () {
    console.log('111');
  }
  return this;
}
Foo.getName = function () {
  console.log('222');
}
Foo.prototype.getName = function () {
  console.log('333');
}
var getName = function () {
  console.log('444');
}

function getName() {
  console.log('555');
}

//输出结果
Foo.getName(); //222
getName(); //function getName(){console.log(444);}
Foo().getName(); //111
getName(); //111
new Foo.getName(); //222
new Foo().getName(); //333
new new Foo().getName(); //333

//解题过程
/**
 * GO = {
 *   getName: undefined 
 *            -> function getName(){console.log(555);}
 *            -> function getName(){console.log(444);}
 *            //执行Foo()
 *            -> function getName(){console.log(111);}
 * }
 */
```

```
//最先想到的办法:for循环
function uniqueArr(array) {
  //数组容器
  var _arr = [],
    isReapeat;
  for (var i = 0; i < array.length; i++) {
    //默认为false
    isReapeat = false;
    //遍历数组容器
    for (var j = 0; j < _arr.length; j++) {
      //证明重复了
      if (_arr[j] == array[i]) {
        //并定义为true
        isReapeat = true;
        //不能往_arr容器里增加元素
        break;
      }
    }
    //这里外层for循环仍会继续循环
    //如需终止循环,声明变量isReapeat枷锁
    if (!isReapeat) {
      //在循环外push元素
      _arr.push(array[i]);
    }
  }
  return _arr;
}

console.log(uniqueArr(arr).sort());;
//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```



## 笔试题

```
/**
 * 
   AO = {
     a: undefined -> function a() {}
   }
 */
function test() {
  return a;
  a = 1;

  function a() {}
  var a = 2;
}
console.log(test()); //function a() {}
```

```
/**
 * GO = {
 *   a: 1,
 *   test: function test(){...}
   }
   AO = {
     a: undefined -> function a() {} -> 2
   }
 */
console.log(test()); //2
function test() {
  a = 1;

  function a() {}
  var a = 2;
  return a;
}
```

```
/**
 * GO = {
 *   a: undefined -> 1,
     test: function test(e){...},
     f: 5
   }
   AO = {
     a: undefined -> 4,
     b: undefined,
     c: undefined,
     e: undefined -> 1 -> function e() {} -> 2
   }
 */
a = 1;

function test(e) {
  function e() {}
  arguments[0] = 2;
  console.log(e); //2
  //a: undefined -> false
  if (a) {
    var b = 3;
    console.log(b); //不打印
  }
  var c;
  a = 4;
  var a;
  console.log(b); //undefined
  f = 5;
  console.log(c); //undefined
  console.log(a); //4
}
var a;
test(1);
console.log(a); //1
console.log(f); //5
```

```
function Test(a, b, c) {
  var d = 1;
  this.a = a;
  this.b = b;
  this.c = c;

  function f() {
    d++;
    console.log(d);
  }
  this.g = f;
}
var test1 = new Test();
test1.g(); //2
test1.g(); //3
var test2 = new Test();
test2.g(); //2
```

```
//x = 1
//y = 0 
//z = 0 
/**
 * GO = {
 *   x: undefined -> 1,
 *   y: undefined -> 0,
 *   z: undefined -> 0,
 *   add: function add(n){return n = n + 1;} 
 *        -> function add(n){return n = n + 3;}
 * }
 */

var x = 1,
  y = z = 0;

function add(n) {
  return n = n + 1;
}
y = add(x); //y = 4

function add(n) {
  return n = n + 3;
}
z = add(x); //z = 4
console.log(x, y, z); //1 4 4
```

```
function foo1(x) {
  console.log(arguments);
  return x;
}
foo1(1, 2, 3, 4, 5); //可输出

function foo2(x) {
  console.log(arguments);
  return x;
}(1, 2, 3, 4, 5); //不可输出

(function foo3(x) {
  console.log(arguments);
  return x;
})(1, 2, 3, 4, 5); //可输出
```

```
function b(x, y, a) {
  a = 10;
  console.log(arguments[2]); //10
}
b(1, 2, 3);
//映射关系
function b(x, y, a) {
  arguments[2] = 10;
  console.log(a); //10
}
b(1, 2, 3);
```

```
//alibaba
//console.log(arguments) => 空数组
//bar() -> bar.call() -> bar(arguments)

function foo() {
  bar.apply(null, arguments);
  //bar.call(arguments) -> bar(arguments) -> [1,2,3,4,5]
}

function bar() {
  console.log(arguments); //1,2,3,4,5
}
foo(1, 2, 3, 4, 5);
```

```
//alibaba
function b(x, y, a) {
  arguments[2] = 10;
  alert(a); //10
}
b(1, 2, 3);
```

```
var f = (function f() {
  return '1';
}, function g() {
  return 2;
})
console.log(typeof f); //function

var f = (function f() {
  return '1';
}, function g() {
  return 2;
})()
console.log(typeof f); //number
```

```
//undefined > 0 -> false
//undefined < 0 -> false
//undefined = 0 -> false
//null > 0 -> false
//null < 0 -> false
//null = 0 -> false
//undefined == null -> true
//undefined === null -> false

//isNaN('100') -> false
//isNaN('abc') -> true
//var num = Number('100') -> isNaN(num) -> false

//parseInt('123a') -> 123
//parseInt('1a') -> 1

console.log(undefined == null); //true
console.log(undefined === null); //false
console.log(isNaN('100')); //false
console.log(parseInt('1a') == 1); //true

//写一个isNaN()方法
function isNaN1(num) {
  //由于NaN谁也不等于所有把它变为'NaN'
  var res = Number(num) + '';
  if (res == 'NaN') {
    return true;
  } else {
    return false;
  }
}

isNaN1('abc'); //NaN
console.log(isNaN1('abc')); //true
console.log(isNaN1(123)); //false
```

```
{} = {} ?
//为什么不等于？
//因为引用值地址不一样
//如何相等？
var obj = {}
obj1 = obj;
console.log(obj == obj1); //true
```

```
var a = '1';

function test() {
  var a = '2';
  this.a = '3';
  console.log(a); //2 //2
}
test();
new test();
console.log(a); //3
```

```
var a = 5;

function test() {
  a = 0;
  console.log(a);
  console.log(this.a);
  var a;
  console.log(a);
}
test(); //0 5 0
new test(); //0 undefined 0
```

```
function test() {
  console.log(foo); //undefined
  var foo = 2;
  console.log(foo); //2
  console.log(a); //报错
}
test();
```

```
function a() {
  var test;
  test();

  function test() {
    console.log(1); //1
  }
}
a();
//test: undefined -> fuction test(){}
```

```
//alibaba
function test() {
  var marty = {
    name: 'marty',
    printName: function () {
      console.log(this.name);
    }
  }

  var test1 = {
    name: 'test1'
  }
  var test2 = {
    name: 'test2'
  }
  var test3 = {
    name: 'test3'
  }

  test3.printName = marty.printName;

  marty.printName.call(test1); //test1
  marty.printName.apply(test2); //test2
  marty.printName(); //marty
  test3.printName(); //test3
}
test()
```

```
var bar = {
  a: '1'
};

function test() {
  bar.a = 'a'; //这里覆盖全局的值
  Object.prototype.b = 'b';
  return function inner() {
    console.log(bar.a); //'a'
    console.log(bar.b); //'b'
  }
}
test()();
//此处test()() -> var test = test(); -> test();
```

```
//如何优化
function test(day) {
  switch (day) {
    case 1:
      console.log('Mon');
      break;
    case 2:
      console.log('Tue');
      break;
    case 3:
      console.log('Wed');
      break;
    case 4:
      console.log('Thur');
      break;
    case 5:
      console.log('Fri');
      break;
    case 6:
      console.log('Sat');
      break;
    case 7:
      console.log('Sun');
      break;
    default:
      console.log('I dont know');
  }
}

// 写法一

function test(day) {
  var weekday = ['Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat', 'Sun'];

  weekday[day - 1] !== undefined ? console.log(weekday[day - 1]) : console.log('i dont know')
}
test(-1)

//写法二
function test(day) {
  var weekday = [, 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat', 'Sun'];

  weekday[day] !== undefined ? console.log(weekday[day]) : console.log('i dont know')
}
test(2);
```

```
//考点：预编译作用域闭包
function Test(a, b, c) {
  var d = 0;
  this.a = a;
  this.b = b;
  this.c = c;

  function e() {
    d++;
    console.log(d);
  }
  this.f = e;
}
var test1 = new Test();
test1.f(); //1
test1.f(); //2
var test2 = new Test();
test2.f(); //1
```

```
//考点：类数组也是对象的一种形式
function test() {
  console.log(typeof (arguments)); //object
}
test();
```

```
//考点：函数表达式忽略函数名
var test = function a() {
  return 'a';
}
test();

console.log(typeof (a)); //undefined 
```

```
//考点：typeof(未声明变量) -> undefined 
var test = function a() {}
test();
console.log(typeof (a)); //'undefined'
```

