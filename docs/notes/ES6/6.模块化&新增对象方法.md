# 模块化&新增对象方法

## 合并

`Object.assigin()`方法用来合并一个对象。在该方法之前想要合并对象需要通过遍历，将遍历后的属性进行重新组合到新对象中。例如`jQuery`中也有类似的方法`jQuery.extend()`，将原有对象合并至新对象中。

基本语法，参数1是需要合并的目标对象(新对象)，参数2是源对象，可能一个或者是多个源对象。返回值是目标对象对应的引用。

```js
const returnObj = Object.assign(target, source1, source2, ...);
```

假如想讲一个对象里的属性合并到新对象，此时可以写：

```js
let obj = { a: 1 };
let tar = {};
const returnObj = Object.assign(tar, obj);
console.log(returnObj); //{ a: 1 }
console.log(returnObj === obj); //false
console.log(returnObj === tar); //true
```

以上还说明了返回值是一个新的引用值，返回值和目标对象是同一引用。

多个对象属性合并，假如其中的属性都没有定义就不存在属性覆盖的问题。

```js
const tar = { a: 1 };
const obj1 = { b: 2 };
const obj2 = { c: 3 };
const returnObj = Object.assign(tar, obj1, obj2);
console.log(returnObj); //{ a: 1, b: 2, c: 3 }
```

但是假如有重复的属性时，存在属性覆盖(新值覆盖老值)。

```js
const tar = { a: 1, b: 1 };
const obj1 = { b: 2, c: 2 };
const obj2 = { c: 3 };
const returnObj = Object.assign(tar, obj1, obj2);
console.log(returnObj); //{ a: 1, b: 2, c: 3 }
```

当给参数1作为一个非引用对象的目标去合并源对象时，会报错，`Cannot convert undefined or null to object`。说明参数1只能是一个对象引用才可以去合并操作。`undefined`没有对应的包装类从而无法进行合并。

```js
const returnObj1 = Object.assign(undefined, { a: 1 });
console.log(returnObj1); //Uncaugh Error
const returnObj2 = Object.assign(null, { a: 1 });
console.log(returnObj2); //Uncaugh Error
```

当给参数1作为一个原始值作为目标去合并源对象时，可以合并，合并对象为一个包装类包装并且合并后的新对象。

```js
const returnObj1 = Object.assign(1, { a: 1 });
console.log(returnObj1); //Number{1, {a: 1}}
const returnObj2 = Object.assign('1', { a: 1 });
console.log(returnOb2); //String{'1', {a: 1}}
const returnObj3 = Object.assign(true, { a: 1 });
console.log(returnObj3); //Boolean{true, {a: 1}}
```

当给参数2作为一个非引用源对象去合并目标对象时，不会报错，参数2不是对象时不做处理，只返回当前的目标对象。

```js
const returnObj1 = Object.assign({ a: 1 }, undefined);
console.log(returnObj1); //{ a: 1 }
const returnObj2 = Object.assign({ a: 1 }, null);
console.log(returnObj2); //{ a: 1 }
```

当给参数2作为一个原始值作为源去合并目标对象时，源为数值或者是布尔值时不会做出处理，只返回当前目标对象，但是源为字符串时则返回一个带有索引属性的目标对象，原因是字符串转为对象，该对象的属性是可枚举遍历的，就会进行合并拷贝操作。

```js
const returnObj1 = Object.assign({ a: 1 }, 1);
console.log(returnObj1); //{ a: 1 }
const returnObj2 = Object.assign({ a: 1 }, '123');
console.log(returnOb2); //{ 0: '1', 1: "2", 2: "3", a: 1 }
const returnObj3 = Object.assign({ a: 1 }, true);
console.log(returnObj3); //{ a: 1 }
```

拓展说一下将字符串对象包装的演示。返回一个类数组，具有索引并且可遍历。通过给目标对象进行拷贝合并属性拿到一个新的目标对象。

```js
const arrayLike = new Object('abc');
console.log(arrayLike);
//{ 0: 'a', 1: 'b', 2: 'c', length: 3 }

const returnObj = Object.assign({}, arrayLike);
console.log(returnObj); //{ 0: '1', 1: "2", 2: "3" }
```

不同属性值类型情况，如字符串将进行隐式类型转换，转化为字符串包装类(`new Object('abc')`)，返回的结果是`{0: 'a', 1: 'b', 2: 'c'}`。如布尔值时通过`new Boolean(true)`，返回的结果是`Boolean{ true }`，带有私有属性`[[PrimitiveValue]]`原始值，该属性是无法遍历的。如数值时通过`new Number(123)`，返回的结果是`Number{ 123 }`，同样也是带有私有属性`[[PrimitiveValue]]`原始值，该属性是无法遍历的。

```JS
const test1 = 'abc'; //{0: 'a', 1: 'b', 2: 'c'}
const test2 = true; //{}
const test3 = 10; //{}

const obj = Object.assign({}, test1, test2, test3);
console.log(obj);
//{0: 'a', 1: 'b', 2: 'c'}
```

继承属性，当通过`defineProperty`定义一个属性的属性值时，默认是不可写，不可枚举，不可配置的。说明该属性是无法遍历的。

```js
const obj = { a: 3 };
Object.defineProperty(obj, 'b', { value: 4 });
console.log(Object.getOwnPropertyDescriptor(obj, 'b'));
//{ value: 4, writable: false, enumerable: false, configurable: false }
```

给对象强制指定一个原型时，并通过描述符的方式再定义两个属性，其中一个` baz`属性是可枚举的。合并对象时只能拷贝带有可枚举的属性。说明继承属性和不可枚举属性是不能拷贝的。

```js
const obj = Object.create({ foo: 1 }, {
  bar: { value: 2 },
  baz: { value: 3, enumerable: true }
});

console.log(obj); //{baz: 3, bar: 2}
const copy = Object.assign({}, obj);
console.log(copy); //{baz: 3}
```

遇到`Symbol()`方法创建的可迭代对象属性时，通过`Object.assign`方法是可以合并拷贝属性。

```js
const obj = Object.assign(
  { a: 'b' }, 
  { [Symbol('c')]: 'd' } 
);
console.log(obj);
//{ a: 'b', Symbol(c): 'd' }
```

`Object.assign`方法也可以将对象进行深度拷贝。

```js
const obj = { a: { b: 1 } };
const tar = Object.assign({}, obj);
obj.a.b = 2;
console.log(tar);
//{ a: { b: 2 } }
```

在对象属性深度合并拷贝时的情况。子层对象有重复的属性时，存在属性覆盖(新值覆盖老值)。

```js
const tar = { a: { b: 'c', d: 'e' } };
const source = { a: { b: 'hello' } };
console.log(Object.assign(tar, source));
//{ a" { b: 'hello' } }
```

当对数组进行合并拷贝时，覆盖索引对应位置的属性(属性名即索引名称相同)。

```js
const obj = Object.assign([1, 2, 3], [4, 5]);
console.log(obj);
//[4, 5, 3]
```

当将对象里的取值函数进行合并拷贝时，返回的是一个取值函数返回对应属性和属性值对象而不是`foo`取值函数体本身。

```js
const source = {
  get foo(){ return 1 }
};
const target = {};
console.log(Object.assign(target, source));
//{ foo: 1 }
```

解决返回函数体本身的办法是通过`Object.getOwnProperties`方法获取对象所有属性的描述符。

```JS
const source = {
  get foo(){ return 1 },
  set foo(val){ console.log(val) }
}
const tar = {};
console.log(Object.assign(tar, source));
//{ foo: undefined }

//获取当前source对象上面的所有描述符
const sourceDescriptors = Object.getOwnPropertyDescriptors(source);
console.log(sourceDescriptors);
//{ foo: {get: ƒ, enumerable: true, configurable: true, set: ƒ} }

//定义新对象的属性为source对象所有属性的描述符
Object.defineProperties(tar, sourceDescriptors);
//将描述符列表拷贝至新对象里
const tarDescriptors = Object.getOwnPropertyDescriptors(tar);
console.log(tarDescriptors);
//{ foo: {get: ƒ, enumerable: true, configurable: true, set: ƒ} }
```

可以通过`Object.create`去克隆一个新的对象，指定一个源对象原型和它的对象描述符。

```JS
const obj = { a: 1, b: 2, c: 3 };
const objDescriptors = Object.getOwnPropertyDescriptors(obj);
console.log(objDescriptors);
/*
  {
    a: {value: 1, writable: true, enumerable: true, configurable: true},
    b: {value: 2, writable: true, enumerable: true, configurable: true},
    c: {value: 3, writable: true, enumerable: true, configurable: true}
  }
*/
const proto = Object.getPrototypeOf(obj);
const clone = Object.create(proto, objDescriptors);
console.log(clone);
//{a: 1, b: 2, c: 3}
```



帮一个对象的原型上扩展一些属性和方法。

```js
const age = 18;
function Person(){}
Object.assign(Person.prototype, {
  eat(){},
  age
});
console.log(Person.prototype);
//{age: 18, eat: ƒ, constructor: ƒ}
```

可以给一个函数的参数对象进行合并拷贝拓展默认值对象。模拟的应用场景是当用户有传入配置的属性时采用用户配置的属性，没有时即用默认配置属性。

```JS
const defaultObj = {
  url: {
    host: 'xxx',
    port: 8000
  }
}

function test(opt){
  opt = Object.assign({}, defaultObj, opt);
  console.log(opt)
}
test(); //{ url: { host: 'xxx', port: 8000 } }
test({ url: { port: 8080 } }); //{ url: { host: 'xxx', port: 8080 } }
```

利用`Object.defineProperties`对象描述符对多个属性进行定义。

```js
const obj = {};
Object.defineProperties(obj, {
  a: { value: true, writable: true },
  b: { value: 'hello', writable: false }
});
console.log(obj);
//{a: true, b: 'hello'}

//获取该对象中所有属性的描述符
console.log(Object.getOwnPropertyDescriptors(obj));
/*
  {
    {value: true, writable: true, enumerable: false, configurable: false},
    {value: 'hello', writable: false, enumerable: false, configurable: false}
  }
*/
```

## 密封

可以让对象密封，`seal()`不可新增/不可删除/可写

```
var obj = { a: 2 };

//对象的密封
console.log(Object.seal(obj));
//判断对象是否密封
//false没有密封/true已开启密封
console.log(Object.isSealed(obj)); //true
```

`freeze()`冻结对象，不可写/不可新增/可枚举/可读

```
//密封对象级别最高的方式Object.freeze()
var obj = { a: 2 };

Object.freeze(obj);
//false没有冻住/true冻住
console.log(Object.isFrozen(obj));
```

```
//深度冻结
function myFreeze(obj) {
  Object.freeze(obj);
  for (var key in obj) {
    if (typeof (obj[key]) === 'object' && obj[key] !== null) {
      myFreeze(obj[key]);
    }
  }
}
```

## 相等

判断是否严格相等的`API`中的`Object.is()`

```
// ES5判断NaN === NaN
console.log(NaN === NaN); //false
console.log(+0 === -0); //true

//ES6新API判断严格相等 sameValue
console.log(Object.is(NaN, NaN)); //true
console.log(Object.is(+0, -0)); //false
```









## 插件化

插件化的开发方式：通过在全局对象上挂载属性，能够在外面通过`<script>`标签引入，在全局对象上`new`一个实例实现一部分功能的封装





**插件/组件/模块化 区别：**

- 插件是一种开发的方式(技巧)，一系列功能封装的构造函数，实例化后能够达到不同的对象，在不同的地方去使用，可复用
- 组件是`react`(函数组件，类组件)，`vue`(单文件组件)，组件基于特定功能的`UI`，根据视图进行划分，拆分逻辑结构样式，包含入口和出口`js`文件
- 模块化是特定的函数实现一个功能，多个函数累加在一起，功能集合，完成一系列功能的方法集合





## 导入导出

`import/export`是关键字，在`ES6`(`es2015`)标准下里的`ES`模块化(`ES MODULE`) 

```
示例一：
//utils.js
export function test(){...}

//main.js
import {test} from './utils.js';
test();

此时浏览器控制台报错：
Uncaught SyntaxError: Cannot use import statement outside a module
不能够在一个不是module的文件里使用import关键字
然后给<script>加上type="module"

此时浏览器控制台再次报错：
Access to script at 'file:///C:/frontEnd/es-module-exercise/main.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.

跨域报错，只能在http/https服务器环境下才能支持模块加载

尝试通过vite启动服务器
npm i -D vite@2.5.8
启动服务器

此时正常识别加载的模块并没有报错
```



**`import`静态导入：**

加载时编译的导入方式，初始化时加载模块

```
import xxx from './xxx';
//依赖`type="module"`
```





**`import`动态导入：**

```
// 按需加载模块
//不依赖`type="module"`

import('./xxx');
```

> 注: 这里的`import()`并不是一个方法，而是`import关键字 + ()`





> **关于：**
>
> `nomodule="true"`：运行在不支持`ES2015`标准的浏览器上，忽略`type=module`脚本
>
> `type="module"`: 运行在支持`ES2015`标准的浏览器上，忽略`nomodule`脚本



```
//写法一：
//utils.js
export function plus(a, b) {
  return a + b;
}

export function minus(a, b) {
  return a - b;
}

//写法二：
function plus(a, b) {
  return a + b;
}

function minus(a, b) {
  return a - b;
}

//注意：这里export导出的不是一个对象，而是一个模块类型!
export {
  plus,
  minus
}

//写法一和写法二是同一个意思:都是导出导入一个模块而不是一个对象

//main.js
//导入时解构该模块：从一个模块类型里解构两个函数
import {
  plus,
  minus
} from './utils.js';

console.log(plus(1, 2));
console.log(minus(3, 4));
```

导入模块的几种写法：

```
//可以通过*模块并命名为utils
import * as utils from './utils';

/**
 console.log(utils);
 * Module {
 *   minus: ƒ minus(a, b),
 *   plus: ƒ plus(a, b)
 * }
 */

console.log(utils.plus(1, 2));
console.log(utils.minus(3, 4));

//也可以解构这个模块类型(像对象但不是一个对象)
import { plus, minus } from './utils';

console.log(plus(1, 2));
console.log(minus(3, 4));

//也可以别名
import { plus as computePlus, minus } from './utils';

console.log(computePlus(1, 2));
console.log(minus(3, 4));

//说明模块的每一个方法对应一个接口
```



导出模块的注意事项：

```
//默认导出一个对象/命名空间
//default表示导出的不是一个模块而是一个对象
//将一个对象作为一个模块导出
export default {
  plus,
  minus
}

//上面导出的方式影响导入时不能解构且报错
import { plus, minus } from './utils';
Uncaught SyntaxError: The requested module '/utils.js' does not provide an export named 'minus'

//只能这样导入
import utils from './utils';
//console.log(utils); {plus: ƒ, minus: ƒ}
//此时的utils是一个对象
```



副作用导入模块(模块内部有马上要执行的代码):

```
//utils.js
export function plus(a, b) {
  return a + b;
}

export function minus(a, b) {
  return a - b;
}

console.log('This is a UtilsModule');

//main.js
//模块一导入就会执行打印代码
import './utils';
```



***`export default` 和 `export `能否一起使用？***

```
//可以共存
//utils.js
export default {
  c: 3,
  d: 4
}

export function plus(a, b) {
  return a + b;
}

export function minus(a, b) {
  return a - b;
}

//main.js
//注意：default默认必须先声明且放第一位
import utils, {
  plus,
  minus
} from './utils';

//console.log(utils); {c: 3, d: 4}是一个对象

console.log(plus(1, 2));
console.log(minus(3, 4));
```



> 补：动态导入属于实验阶段
>

***什么时候要使用动态`import`？***

1. 静态导入太多的情况下，有一些不需要马上加载的模块可以使用动态导入
2. 异步获取加载模块的方式
3. 副作用加载`import('./utils');`
4. 不能滥用动态导入



```
//import('./utils')返回的是一个Promise对象，所以也是支持then的使用
import('./utils').then(module => {
  // console.log(module);
  // Module {default: Object, minus: ƒ , plus: ƒ  }
});
```

 
