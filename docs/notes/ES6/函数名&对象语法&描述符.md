# 函数名&对象语法&描述符

## 函数名 

函数声明和`new Function`定义的函数名称会有区别。

```js
console.log(f.name); //f
```

`new Function`构造出来的函数名称是不一样的。

```js
console.log((new Function).name); //anonymous
```

```js
console.log(foo.bind({}).name); //bound foo;
```

## 对象语法

对象名称和函数名称相同时可以简写。

```js
const foo = 'bar';
const baz = { foo };
```

属性名，可以通过`[]`访问对应的值。

```js
var arr = [1, 23, 23, 45, 5];
console.log(arr[1]); //23
```

属性经过一层包装，将传入的所有值进行包装变成一个字符串。所以说，定义的属性都为字符串。

```js
var arr = [1, 23, 23, 45, 5];
console.log(arr['1']); //23
```

属性名通过某种方式进行拼接。拼接的属性名会重写之前的属性名，先进行覆盖然后再找属性值。

```js
const obj = {};
obj['f' + 'o' + 'o'] = false;
console.log(obj); //{ foo: false }
```

```js
let a = 'hello';
let b = 'world';
let obj = {
  [a + b]: true,  //helloworld: true
  ['hello' + b]: 123, //helloworld: 123
  ['hello' + 'world']: undefined //helloworld: undefined
};

console.log(obj); //{ helloworld: undefined }
```

***当属性名为对象的时候，如何转换为对象？*** 通过包装类或者对象原型上的`toString`方法将属性名转为字符串。

```js
const myObject = {};
myObject[true] = 'foo';
// console.log(myObject); //{ true: 'foo' }

myObject[3] = 'bar';
// console.log(myObject); //{ '3': 'bar', true: 'foo' }

myObject[myObject] = 'baz';
// console.log(myObject);
//{ '3': 'bar', true: 'foo', '[object Object]': 'baz' }

//如何成为字符串？
console.log(Boolean.prototype.toString.call(true)); //true
console.log(Number.prototype.toString.call(3)); //3
console.log(Object.prototype.toString.call(myObject)); //[object Object]
console.log(Object.prototype.toString.call(true)); //[object Boolean]
```

只有一个属性，后一个属性覆盖前一个属性。

```js
const a = { a: 1 };
const b = { b: 2 };
const obj = {
  [a]: 'valueA',
  [b]: 'valueB'
}
console.log(obj);
//{[object Object]: "valueB"}
```

打了引号结果会不一致。

```js
const a = { a: 1 };
const b = { b: 2 };
const obj = {
  ['a']: 'valueA',
  ['b']: 'valueB'
};
console.log(obj);
//{ a: 'valueA', b: 'valueB' }
```

对象中找到函数名称的`name`属性。

```js
const person = { sayName() { console.log('hello'); } }
console.log(person.sayName.name); //sayName
```



## 描述符

在`ES5`之前，`JavaScript`并没有提供一个直接检测属性特征的方法。如检测某个对象里的属性是否是只读的，可遍历，可修改，可配置。`ES5`之后提供了属性描述符来检测并获取对象描述符信息，如`Object.getOwnPropertyDescriptor()`方法，该方法保存在对象原型上的构造器里面(`Object.prototype.constructor.getOwnPropertyDescriptor`)。

```js
console.log(Object.prototype);
/**
 * {
 *   constructor: {
 *     getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor(),
 *     getOwnPropertyDescriptors: ƒ getOwnPropertyDescriptors(), 
 *     defineProperty: ƒ defineProperty(), 
 *     defineProperties: ƒ defineProperties(),
 *     assign: ƒ assign(),
 *     ...
 *   }
 * }
 */
```

获取对象里属性的描述符，它返回的是一个描述符对象，包含了`value`值，`writable`可写的，`enumerable`可枚举的，`configurable`可配置(可删)的属性。

```js
const obj = { a: 1 };
console.log(Object.getOwnPropertyDescriptor(obj, 'a'));
//{ value: 1, writable: true, enumerable: true, configurable: true }
```

`Object.defineProperty()`方法可以用来定义一个新的属性或者是修改已经存在属性。尝试给对象新增一个属性。

```js
let obj = {};
Object.defineProperty(obj, 'username', {
  value: 'kevin',
  enumerable: true,
  writable: true,
  configurable: true
});
console.log(obj); //{ username: 'kevin' }
```

假如给一个对象的某个属性进行可读写`writable: false`的限制，会造成该属性无法被重写。静默失败，即该属性的重写操作并没有生效，也没有报错，只是不执行，但是在严格模式下会报错`TypeError: Cannot assign to read only property 'username' of object`。

```js
let obj = {};
Object.defineProperty(obj, 'username', {
  value: 'kevin',
  writable: false,
});
obj.username = 'lucy'; 
console.log(obj); //{ username: 'kevin' }
```

假如给一个对象的某个属性进行可配置`configurable: false`的限制，会造成该属性无法删除。静默失败，即该属性的删除操作并没有生效，也没有报错，只是不执行，但是在严格模式下会报错`TypeError: Cannot delete property 'username' of #<Object>`。

```js
let obj = {};
Object.defineProperty(obj, 'username', {
  value: 'kevin',
  configurable: false
});
delete obj.username;
console.log(obj); //{ username: 'kevin' }
```

假如给一个对象的某个属性进行可枚举`enumerable: false`的限制，会造成该属性无法被遍历。静默失败，即该属性的遍历操作并没有生效，也没有报错，只是不执行，但是在严格模式下也不会报错，因为还有其余属性可以被遍历。

```js
'use strict';
let obj = { age: 29, job: 'engineer' };
Object.defineProperty(obj, 'username', {
  value: 'kevin',
  enumerable: false
});

for (let key in obj) {
  console.log(key); //age job
}
```

`getter`也是属于对象描述符，相当于原生`JS`内置`[[GET]]`操作来获取对象属性。当通过对象的属性访问的方式会触发`getter`函数去获取该属性的属性值。

```js
obj.username
```

在对象里定义一个`getter`方法，当该属性被访问时触发执行。

```js
let obj = {
  get username() { return 'kevin'; }
};
console.log(obj.username); //kevin
console.log(obj); //{ username: [Getter] }
```

通过`Object.defineProperty()`方法对一个对象的属性的描述符中进行`getter`定义。

```js
let userInfo = {};
Object.defineProperty(userInfo, 'username', {
  get: function () { return 'kevin'; }
});
console.log(userInfo, userInfo.username);
//{} kevin
```

`setter`也是属于对象描述符，相当于原生`JS`内置`[[PUT]]`操作来给对象属性进行赋值。当通过对象属性进行赋值操作会触发`setter`函数去修改该属性的属性值。

```js
obj['username'] = 'lucy';
```

在对象里定义一个`setter`方法，当该属性被重新赋值时触发执行。需要注意的是在`setter`函数不能直接对该属性进行重新赋值操作，否则导致栈溢出报错，因为直接赋值操作会递归地触发`setter`导致堆栈溢出。

```js
let obj = {
  get username() { return 'kevin'; },
  set username(value) {
    //RangeError: Maximum call stack size exceeded
    //this.username = value; 
    this.nameList.push(value);
  },
  nameList: []
};

obj.username = 'lucy';
console.log(obj);
//{ username: [Getter/Setter], nameList: [ 'lucy' ] }
```

`getter`和`setter`对对象属性进行定义时，一般都是成对出现的，否则没有实际意义。



## `Symbol`

***`ES6`为什么要引入`symbol`?***

**场景：**

`ES5`对象属性经常出现重名的情况，解决对象属性名重名的问题

`symbol`属于原始值类型的值，而不是构造函数

- 原始值类型的值：`number/boolean/null/undefined/symbol`
- 引用值类型的值：`Object/Array/Function`

```
let s1 = Symbol('foo');
//是原始值包装类
console.log(typeof s1); //symbol
//挂不上属性
console.log(s1.a); //undefined

//如何区别唯一的symbol值?可以通过传参区分
//作为标识符存在的
console.log(s1); //Symbol(foo)
```

```
//通过生成完全不一样的不可重复的原始类型
//针对拷贝属性覆盖的问题
var a = Symbol('a');
var b = Symbol('a');
console.log(a === b); //false

// Symbol的值能否被Object.assign()拷贝？
//可以拷贝
var test = Object.assign({ a: 'b' }, { [Symbol('c')]: 'd' });
console.log(test);
//{a: "b", Symbol(c): "d"}
```

***如何避免重名？***

```
var obj = {
  a: 1
};
let s1 = Symbol(obj);
console.log(s1);
//说明对象自己调用了Object.prototype.toString()方法将自己变成字符串
//也说明symbol的值永远是字符串
//Symbol([object Object])
```

如何使用？作为属性名来用

```
//独一无二的属性名
let name = Symbol();
let person = {};

// 错误写法
//此写法是字符串不能用Symbol创建的变量
person.name = 'zhangsan';
console.log(person);
//{name: "zhangsan"}

//正确的写法：
person[name] = 'lisi';
console.log(person);
//{name: "zhangsan", Symbol(): "lisi"}

//常用写法：
let name = Symbol();
let person1 = {
  [name]: 'wangwu'
}
console.log(person1);
//{Symbol(): "wangwu"}

//写法三：
let name = Symbol();
let person = {};
Object.defineProperty(person, name, {
  value: 'zhangsan'
})
console.log(person);
//{Symbol(): "zhangsan"}
```

```
//挂载Symbol到变量里
let name = Symbol();
let eat = Symbol();
let person = {
  [name]: 'zhangsan',
  [eat]: function(){}
  //简写
  [eat](){
    console.log(this[name]);
  }
}
```

`Symbol`相关的几个方法

`Symbol.for()`拿到唯一的值

```
//一般来说，Symbol的值都是不同的
let s1 = Symbol('foo');
let s2 = Symbol('foo');
console.log(s1 === s2); //false

//也有特殊的情况，可以值是相同的
let s3 = Symbol.for('foo');
let s4 = Symbol.for('foo');
console.log(s3 === s4); //true
```

`Symbol.keyFor`全局中拿到当前的`key`值

```
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');
//拥有同样的标识符
console.log(Symbol.keyFor(s1)); //foo
console.log(Symbol.keyFor(s2)); //foo
```

试着遍历

```
const obj = {}
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'hello';
obj[b] = 'world';
// console.log(obj);
//{Symbol(a): "hello", Symbol(b): "world"}

//遍历
for (let i in obj) {
  console.log(i);
  //无打印结果
  //说明for in 不能遍历 Symbol属性的对象
}
```

`Object.getOwnPropertySymbols()`新的`API`专门遍历`symbol`类型的值(唯一的遍历方法)

```
const obj = {}
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'hello';
obj[b] = 'world';

//只针对Symbol属性的对象遍历的方法
console.log(Object.getOwnPropertySymbols(obj));
//[Symbol(a), Symbol(b)]
```

**总结：**

- `for in`：遍历自身和继承的可枚举属性(不包括含`Symbol`类型的值)
- `Object.key()`：遍历自身不包含`Symbol`类型的值
- `Object.getOwnPropertySymbols()`：遍历自身的`Symbol`类型的值
- `Object.assign()`：遍历自身可枚举的，包含`Symbol`类型的值
- `JSON.stringify()`：遍历自身可枚举的属性



**`Symbol`定义唯一方法实现一个`iterator`接口：**

对象是不连续的且无序的数据结构，一般来说不能用`for of`，但是可以通过部署迭代器接口的方式来使用`for of` 遍历

```
//手动的编写一个iterator接口可以针对指定的数据类型进行迭代遍历
//对象上写一个iterator接口
let obj = {
  start: [1, 3, 2, 4],
  end: [5, 7, 6],
  //中括号包裹字符串的方式
  [Symbol.iterator]() {
    //定义指针
    let index = 0,
      //组合新数组
      arr = [...this.start, ...this.end],
      //新数组长度
      len = arr.length;
    //将新数组进行迭代
    return {
      next() {
        if (index < len) {
          return {
            //累加的结果
            value: arr[index++],
            done: false
          }
        } else {
          return {
            value: undefined,
            done: true
          }
        }
      }
    }

  }
}

for (let i of obj) {
  console.log(i); //1 3 2 4 5 6 7
}
```





## `Reflect`

是一个对象, 是`JavaScript`内置对象方法集合的容器

```
Reflect = {}
```

整合了`ES5`原型上原有的方法的`ES6API`(静态方法)

`apply()`/`defineProperty()`/`deleteProperty()`/`get()`/`getOwnPropertyDescriptor`/`getPrototypeof()`/`has()`/`isExtensible()`/`ownKeys()`/`preventExtensions()`/`set()`/`setPrototypeOf()`

```
//如何通过Reflect访问对象
console.log(obj.a);
console.log(Reflect.get(obj, 'a'));
```

利用函数式的写法重新定义`Proxy`构造函数，用方法去取值/赋值使得更为合理，利用底层的方法操作对象

```
let proxy = new Proxy(target, {
  get(target, prop){
    //1.直接访问返回
    //return 'This is property value' + target[prop];
    
    //2.通过函数式返回
    return Reflect.get(target, prop);
  },
  set(target, prop, value){
    //target[prop] = value;
    Reflect.set(target, prop, value);
  }
});
```

