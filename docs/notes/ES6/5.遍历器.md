# ES6遍历器



## 遍历

- `Object.keys()`：遍历出自身的可枚举的键名(不含继承属性)
- `Object.values()`：遍历出自身的可枚举的键值(不含继承属性)
- `Object.entries()`：遍历出自身的可枚举的键值对(不含继承属性)

```
const foo = {
  a: 1,
  b: 2,
  c: 3
}

Object.defineProperties(foo, {
  d: {
    value: 4,
    enumerable: true
  },
  f: {
    value: 5,
    enumerable: false
  }
})


//获取当前对象的键名，不能遍历未被定义枚举属性的键名
// console.log(Object.keys(foo));
//["a", "b", "c", "d"]

//获取当前对象的键值，不能遍历未被定义枚举属性的键值
// console.log(Object.values(foo));
//[1, 2, 3, 4]

//获取当前对象的键值对，不能遍历未被定义枚举属性的键值
// console.log(Object.entries(foo));
/**
 * [Array(2), Array(2), Array(2), Array(2)]
 *   0: (2) ["a", 1]
 *   1: (2) ["b", 2]
 *   2: (2) ["c", 3]
 *   3: (2) ["d", 4]
 *   __proto__: Array(0)
 */
```



## `for of`

`ES6`为了解决迭代器`iterator().next()`调用繁琐而新增的`API`

可以遍历对应的数据结构，通过该`API`可以迭代

```
let arr = [1, 2, 3];
for (let i of arr) {
  console.log(i); //1 2 3
}
```

与`for in`区别：

- `for in `：拿到的是数据结构的下标(主要遍历对象)
- `for of`：拿到的是数据结构的值(部署过迭代器的数据接口的数据类型的)





## 生成器

`generator`函数语法。作用是访问迭代器对象，返回值是迭代器对象。

```
function* test(){}
```

只要执行生成器函数 生成一个迭代器对象。

```
function* test() {}
console.log(test());

/**
 * 生成跟迭代器对象里具有next()方法的对象
 * test {<suspended>}
 *   __proto__: Generator
 *     __proto__: Generator
 *     constructor: GeneratorFunction {...}
 *     next: ƒ next()
 */
```



生成器函数一定要和`yeild`结合使用，可以自定义产出内容和返回值，用法和迭代器有点像`yeild`：产出的意思，产出的同时暂停程序向下执行。

```
function* test() {
  yield 'a';
  yield 'b';
  yield 'c';
  return 'd';
}

let iter = test();
console.log(iter.next()); //{value: "a", done: false}
console.log(iter.next()); //{value: "b", done: false}
console.log(iter.next()); //{value: "c", done: false}
console.log(iter.next()); //{value: "d", done: true}
```

迭代器接口迭代`yeild`所产出的值。

```
function* test() {
  console.log(0); //0
  yield 'a'; //{value: "a", done: false}
  console.log(1);  //1
  yield 'b'; //{value: "b", done: false}
  console.log(2); //2
  yield 'c'; //{value: "c", done: false}
  console.log(3); //3
  return 'd'; //{value: "d", done: true}
}

let iter = test();
console.log(iter.next()); 
console.log(iter.next()); 
console.log(iter.next()); 
console.log(iter.next()); 
```

`yeild`和`return`本质的区别：

- `yeild`暂停，找上一次暂停的位置，有记忆功能
- `return`结束程序执行



**返回值问题**

```
//说明yeild并不产出值
function* test() {
  let a = yield 'a';
  console.log(a);
  yield 'b';
  yield 'c';
  return 'd';
}

let iter = test();
//第一次执行，不产出yeild的返回值
console.log(iter.next()); //{value: "a", done: false}

//第二次执行，产出yeild的返回值为undefined
console.log(iter.next()); //undefined {value: "b", done: false}
```

```
//如果想要yeild产出值，可以在next()执行时传参
console.log(iter.next(10)); //10 {value: "b", done: false}
```

`next()`传值问题 蛇形传值方式

```js
function* foo() {
  let value1 = yield 1;
  console.log(value1); //two
  let value2 = yield 2;
  console.log(value2); //three
  let value3 = yield 3;
  console.log(value3); //four
  let value4 = yield 4;
  console.log(value4); //five
}

let iter = foo();
//第一次执行，不产出yeild的返回值
console.log(iter.next('one')); //{value: 1, done: false}
//第二次执行，产出yeild的返回值为第一次执行next()传入的值
console.log(iter.next('two')); //{value: 2, done: false}
console.log(iter.next('three')); //{value: 3, done: false}
console.log(iter.next('four')); //{value: 4, done: false}
console.log(iter.next('five')); //{value: undefined, done: true}
```



优化对象迭代器的函数

```
let obj = {
  start: [1, 2, 3],
  end: [7, 8, 9],
  [Symbol.iterator]: function* () {
    var nextIndex = 0,
      arr = [...this.start, ...this.end],
      len = arr.length;

    while (nextIndex < len) {
      //产出值
      yield arr[nextIndex++];
    }
  }
}

for (let i of obj) {
  console.log(i); //1 2 3 4 5 6 7 8 9
}
```

利用生成器函数优化代码

```
function promisify(fn) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      fn(...args, (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve(data);
        }
      });
    });
  };
}

let readFile = promisify(fs.readFile);

function* read() {
  let value1 = yield readFile("./name.txt", "utf-8");
  let value2 = yield readFile(value1, "utf-8");
  let value3 = yield readFile(value2, "utf-8");
}

let iter = read();
//格式：let {value: xx, done: false} = iter.next();
// let { value: value, done: done } = iter.next();
let { value, done } = iter.next();
//进一步调用next(val)拿到第一次的值
value.then((val1) => {
  let { value: done } = iter.next(val1);
  value.then((val2) => {
    let { value, done } = iter.next(val2);
    value.then((val3) => {
      console.log(val3);
    });
  });
});
```

以上写法过于繁琐，优化提纯一个新的函数。

```
//解决链式调用的问题
function Co(iter) {
  return new Promise((resolve, reject) => {
    let next = (data) => {
      let { value, done } = iter.next(data);
      if (done) {
        resolve(value);
      } else {
        value.then((val) => {
          next(val);
        });
      }
    };
    next();
  });
}

let promise = Co(read());
promise.then((val) => console.log(val));
```

生成器对象上的`return()`/`throw()`方法。终结迭代的方式，终结遍历这个函数，后面`next`获取的值都为`undefined`。和在生成器函数内部直接`return`的结果一样。

```
//return()
//调用之后返回true
function* get() {
  yield 1;
  yield 2;
  yield 3;
}
let g = get();
console.log(g.next()); 
//{value: 1, done: false}
console.log(g.next()); 
//{value: 2, done: false}
console.log(g.next()); 
//{value: 3, done: false}
console.log(g.next()); 
//{value: undefined, done: true}

let h = get();
console.log(h.next()); 
//{value: 1, done: false}
console.log(h.return());
//{value: undefined, done: true}
console.log(h.next()); 
//{value: undefined, done: true}
console.log(h.next()); 
//{value: undefined, done: true}
```

```
//throw()必须在next()之后执行才能捕获异常
//throw()也相当于next()继续执行迭代
//try...catch对异步代码不管用
var g = function* () {
  try {
    yield;
  } catch (e) {
    console.log("生成器内部异常：" + e);
  }
};
var i = g();
console.log(i.throw("a")); //无法捕获错误
console.log(i.next());
console.log(i.throw("a")); //捕获成功
```









## 迭代器

`Symbol`底下有一个`iterator()`方法是迭代器，且迭代器里有个`next()`方法。

```
let arr = [1, 2, 3];
console.log(arr);
//[1, 2, 3]
//数组的原型上找到Symbol构造函数里的iterator方法并执行
let iter = arr[Symbol.iterator]();
//Symbol.iterator方法的原型上有一个next()方法
console.log(iter.next()); //{value: 1, done: false}
console.log(iter.next()); //{value: 2, done: false}
console.log(iter.next()); //{value: 3, done: false}
console.log(iter.next()); //{value: undefined, done: true}
```

以上说明迭代的本质也在读取数据结构的值，抽取当中结构数据的第一个值，迭代器是一种有序的，连续的，基于抽取的组织方式。

迭代器模式是一种结构化模式，可以从源对象以一次一个的方式抽取。

内部迭代器是指系统内部定义好的迭代规则，如数组原型上的迭代器函数。外部迭代器是指通过某种方式给他部署一个迭代器接口，一次抽取一个数据，一次迭代一个数据。



**具有部署迭代器接口的数据结构有：**

`Array/Map/Set/weekMap/weekSet/arguments/nodeList`



```
/**
 * 模拟一个迭代器函数
 * @param {*} array 数组
 * @returns 返回一个next()方法
 */
function makeIterator(array) {
  //指针
  var nextIndex = 0;
  return {
    next: function () {
      return nextIndex < array.length ? {
        value: array[nextIndex++],
        done: false
      } : {
        value: undefined,
        done: true
      }
    }
  }
}
//调用
var iter = makeIterator([1, 2, 3]);
console.log(iter.next()); //{value: 1, done: false}
console.log(iter.next()); //{value: 2, done: false}
console.log(iter.next()); //{value: 3, done: false}
console.log(iter.next()); //{value: undefined, done: true}
```





## 迭代器进阶

因为对象不具备迭代器接口，部署迭代器方式生成一个外部迭代器便于`for of`遍历。

```
let obj = {
  start: [1, 2, 3],
  end: [7, 8, 9],
  [Symbol.iterator]() {
    var nextIndex = 0,
      arr = [...this.start, ...this.end],
      len = arr.length;
    return {
      next() {
        if (nextIndex < len) {
          return {
            value: arr[nextIndex++],
            done: false
          }
        } else {
          return {
            value: undefined,
            done: true
          }
        }
      }
    }
  }
}

for (let i of obj) {
  console.log(i);
}
```

***为什么对象身上不具备迭代器接口？***

因为对象上键值对成员是无序的。

```
let map = new Map([
  ['a', 1],
  ['b', 2]
]);
for (let i of map) {
  console.log(i);
}
//["a", 1]
//["b", 2]
```

***如何让对象也像`Map`数据结构一样具有迭代器接口?***

```
//利用map特性部署迭代器接口
let obj = {
  a: 1,
  b: 2,
  c: 3,
  [Symbol.iterator]() {
    let nextIndex = 0;
    let map = new Map();
    for (let [key, value] of Object.entries(this)) {
      // console.log(key, value); //a 1  b 2  c 3
      //重组map
      map.set(key, value);
    }
    // console.log(map);
    //{"a" => 1, "b" => 2, "c" => 3}

    //将map转换为数组以便于拿到length属性
    //把具有迭代器对象的map展开并存入数组
    let mapEntries = [...map.entries()];
    // console.log(mapEntries);
    //[['a', 1], ['b', 2], ['c', 3]]

    //部署iterator接口
    return {
      next() {
        if (nextIndex < mapEntries.length) {
          return {
            value: mapEntries[nextIndex++],
            done: false
          };
        } else {
          return {
            value: undefined,
            done: true
          };
        }
      }
    }
  }
}

for (let i of obj) {
  console.log(i);
}
//["a", 1]
//["b", 2]
//["c", 3]
```



**默认调用`iterator`接口的场合：**

- `...`拓展运算符
- `for of`
- `Array.from()`
- `map`
- `set`
- `Promiss.all()`
- `yeild`





## async/await

适用于异步函数的`ES6`语法，本质上也是一个语法糖，来源于生成器函数。

1. 内置的执行器(`co`函数)
2. 更好的语义
3. 更广的实用性

`async`的返回值是一个`Promise`对象，也有三种状态，每种状态对应每种回调





## 应用

迭代器和生成器的应用，如装饰器，在项目中非常常用的写法。

假如有许多函数如100个并让其顺序执行。先定义一个数组集合，来存放这些函数，然后`for`循环容器，并逐一执行。需求是从某个函数开始暂停不让其执行，如何实现？

可以在每个函数中返回布尔值，如果是`true`，就可以继续执行，否则不能往下执行。

```
function test1(){ return true; }
function test2(){ return true; }
function test3(){ return false; }

for(let fn of functions){
  if(!fn()){ break; } //跳出循环不执行
}
```

在`koa`服务端中的洋葱模型里的中间件集合，如`[test1, test2, test3, ...]`，在每个API执行时需要经过许多的中间件函数。遍历执行这些中间件，但在遍历执行的过程中某个中间件失败时无法正常执行，会阻断后续的中间件的正常执行。此时需要有一种机制去截断，不能让中间件集合继续往下执行。在中间集合的每个函数里都会有一个`next()`的前置条件，只有`next`执行的前提下才能允许下一个中间件的运行。

```
var functions = [
  function fn1(next){ next(); },
  function fn2(next){ next(); },
  function fn3(next){ next(); }
]
```

在前端也可以实现中间件截断功能。处理一个函数集合，利用生成器和递归来实现只有在中间件函数里定义`next`执行才会继续递归使得API正常使用每个中间件程序。

```
(function (functions) {
  //根据函数集合产出每一个函数
  function* generator(arr) {
    for (var i = 0; i < arr.length; i++) { yield arr[i]; }
  }

  //该递归方法让函数集合中的所有函数都执行
  function nextDo(n) {
    //当前函数test1的执行，并传参，参数为下一个函数test2
    n.value(function () {
      //产出下一个对象如{done: false, value: ƒ test2}
      var n = iterator.next();
      //done为false，还没迭代完毕时继续递归执行 否则中止程序
      if (!n.done) { nextDo(n) } else { return }
    });
  }

  var iterator = generator(functions);

  var init = () => {
    //传入产出的每一个对象如{done: false, value: ƒ test1}
    nextDo(iterator.next());
  };

  init();
})([
  function test1(next) {
    /**
     console.log(next);
     * function () {
         var n = iterator.next();
        if (!n.done) { nextDo(n); } else { return; }
      }
     */
    next();
  },
  function test2(next) { next(); },
  function test3(next) { next(); }
]);
```

利用迭代器的记忆功能实现一个日志打印工具。