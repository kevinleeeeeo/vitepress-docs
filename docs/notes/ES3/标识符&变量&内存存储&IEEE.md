

# 标识符&变量&内存存储&`IEEE`

## 标识符

标识符`Identifier`是程序员可以自己决定命名的名字或内容，有变量名，常量名，函数名，类名等。这些名称其实都与内存有关系。

标识符包含了大小写字母`A-Za-z`，数字`0-9`，下划线`_`，美元符号`$`。规则是不能以数字开头，严格区分大小写字母，不允许使用空格，不允许使用`ES`[关键字与保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar)，语义化清晰完整且尽量简洁。可以使用驼峰及蛇形命名法。

使用驼峰命名法`camelCase`的格式，适用于函数和变量名称。

```
helloWorld
```

帕斯卡命名法`PascalCase`，大驼峰命名，适用于类名或构造函数名称。

```
HelloWorld
```

蛇形命名法`snake_case`，适用于常量名称，一般写法是全部大写。

```
HELLO_WORLD
```

中横线烤串命名法`kebab-case`，适用于项目文件或文件夹名称。

```
hello-world
```

空格命名法`space case`，不适合编程语言，不能使用。

```
hello world
```

## 变量

标识符可以用来充当变量名称。内存中存储数据的最基本的单元标识，`JavaScript`是一门动态语言，变量与数据类型没有关系，变量与值的数据类型无关，声明变量使用`var`关键字去声明变量，将一个值赋值给变量。一个变量，就是一个用于存放数值的容器。声明变量 `var`有两个过程，第一个是变量声明，第二个是变量赋值。变量的`3`要素包括值类型，变量名称，变量值。

```js
var myTitle = 'This is title';
```

`Java`语言的静态性。`int`声明为一个整形数据并赋值给一个整形，赋值其他类型数据将会报错。

```java
int a = 1;
```

`JavaScript`是一门弱类型语言，当值操作不匹配既定的数据类型时，系统会做隐式类型转换。

```js
var a = 1;
a = a + 'string';
//'1string'
```

声明变量的过程，首先开辟一个`64`位内存空间，将`1`存储至该空间，将`a`标识对应上该空间的地址。

```js
var a = 1;
```

变量的运算和变量的赋值存在优先级问题，先运算后赋值。

```js
var x = 3,
  y = 4;
var z = x + y;
console.log(z);

//print 7
```

## 内存存储

编程语言的基本能力有变量声明，指的是开辟值存储的内存空间的能力，有数据结构，指的是具备表达数据不同结构的能力，有函数声明，指的是具有对程序进行封装集成的能力，有运算，指的是完成算数与逻辑运行的能力。

内存存储情况如`Java`中声明一个变量`int a = 1`，由于是强类型语言，在`int a`的时候已经决定了当前要开辟的空间是一个`32`位的整形空间，整形是一个四字节`32`位，`JavaScript`不存在整形，并将`1`存储起来，存储的是`32`位整形的二进制补码。此时会有一个十六进制的地址对应上变量标识，通过地址访问标识去访问值。

内存存储情况如`JavaScript`中声明一个变量`var a = 1`，由于是弱类型语言，值可以决定开辟的空间，因为`JavaScript`在运行时去赋值，赋值的时候可以确定并推断出值的类型，值确定了类型后就会变成双精度的浮点型的标准进行存储。`JavaScript`所有的数字采用`64`位双精度浮点型的原因是选用`double`类型的双精度`64`位浮点型的取值范围是所有类型中最大的，所以会存在精度上的损失的问题。

`JavaScript`中的内存分为栈内存 `Stack`和堆内存 `Heap`。

**如何存储原始值？** 栈内存先进后出。

```js
var a = 3;
var b = a;
a = 1;
console.log(b); //3
```

说明原始值数据是永久保存且不可改变的，例如手机相机电脑内存删除内容其实数据仍保留。

**如何存储引用值？** 值，指针存储在栈 `Stack `内存 指向 堆内存 `Heap `地址。

```js
var arr1 = [1, 2, 3, 4];
var arr2 = arr1;
console.log(arr1 + '' + arr2);
//1, 2, 3, 4 | 1, 2, 3, 4
```

指向相同地址的情况。

```js
var arr1 = [1, 2, 3, 4];
var arr2 = arr1;
arr1.push(5);
console.log(arr1); //1, 2, 3, 4, 5
console.log(arr2); //1, 2, 3, 4, 5
```

指向不同地址的情况。

```js
var arr1 = [1, 2, 3, 4];
var arr2 = arr1;
arr1 = [1, 2];
console.log(arr1); //1, 2
console.log(arr2); //1, 2, 3, 4, 5
```





## `IEEE 754`

`IEEE`二进制浮点数算术标准（`IEEE 754`）是`20`世纪`80`年代以来最广泛使用的浮点数运算标准，由电器和电子工程师协`Institute of Electrical and Electronics Engineers`会来定义`754`号规范里的二进制浮点数算数标准，其中的公式是`V = (-1)^s * M * 2^E`，`V`是二进制浮点数表示方法，`s`是符号(`0`代表正数，`1`代表负数)，`M`是有效数字，`E`代表了指数(往左移动为正，往右为负)，为许多`CPU`与浮点运算器所采用。

这个标准定义了表示浮点数的格式（包括负零`-0`）与反常值（`denormal number`），一些特殊数值（无穷（`Inf`）与非数值（`NaN`），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。

`IEEE 754`规定了四种表示浮点数值的方式：单精确度（`32`位）、双精确度（`64`位）、延伸单精确度（`43`比特以上，很少使用）与延伸双精确度（`79`比特以上，通常以`80`位实现）。只有`32`位模式有强制要求，其他都是选择性的。大部分编程语言都提供了`IEEE`浮点数格式与算术，但有些将其列为非必需的。

在六、七十年代，各家计算机公司的各个型号的计算机，有着千差万别的浮点数表示，却没有一个业界通用的标准。这给数据交换、计算机协同工作造成了极大不便。`IEEE`的浮点数专业小组于七十年代末期开始酝酿浮点数的标准。在`1980`年，英特尔公司就推出了单片的`8087`浮点数协处理器，其浮点数表示法及定义的运算具有足够的合理性、先进性，被`IEEE`采用作为浮点数的标准，于`1985`年发布。而在此前，这一标准的内容已在八十年代初期被各计算机公司广泛采用，成了事实上的业界工业标准。加州大学伯克利分校的数值计算与计算机科学教授威廉·卡韩被誉为“浮点数之父”。

十进制转为二进制的过程：将`25.125`数值分两个部分去转为十进制。

```js
/*
第一部分为整数部分：转25
25 / 2 => 12 余 1
12 / 2 => 6 余 0
6 / 2 => 3 余 0
3 / 2 => 1 余 1
1 / 2 => 0 余 1
二进制整数逆向取即 11001

第二部分为小数部分：0.125
0.125 * 2 => 0.25 余 0
0.25 * 2 => 0.5 余 0
0.5 * 2 => 1 余 1
二进制小数正向取即 001

最终为11001.001
**
```

使用`IEEE`标准来科学的表示上述二进制。`11001.001`并不是有效数字，有效数字的写法是`1.1001001`即小数点往左移动`4`位(指数)。在内存存储中会舍去前面的`1.`变成`1001001`。`s`是正数所以为`0`。

```js
/**
11001.001
s => 0
M => 1.1001001
E => 4
V = (-1)^0 * 1.1001001 * 2^4
*/
```

`JavaScript`中的数字都是`double`类型，`8`个字节对应`1`个字节`8`位即`64`位。在内存中要分`64`个格子出来，`s`需要占`1`位，`E`需要占`11`位，因为`double`类型是占`11`位，`E`的取值范围是`0-2047`，`0-1023`为负数，`1024-2047`为正数，`M`类型占`52`位。

```js
/**
E => 4 + 1023 => 转十进制 => 成为11位的数值 => 10000000011
*/
```

在`64`位内存中进行存储的空间排布为：

```js
/**
s*1 | E*11 | M*52
0 | 10000000011 | 1001001000.... 不够位数补0需齐至52位
*/
```