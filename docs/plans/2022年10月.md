## 第一周

| **日期** |                  **早**                  |               **午**               |               **晚**               | **复习内容** | **完成度** |
| :------: | :--------------------------------------: | :--------------------------------: | :--------------------------------: | :----------: | :--------: |
| 10月3日  |    对象属性遍历、this、caller_callee     |         关于this指向的总结         | 三目运算、对象克隆、浅拷贝、深拷贝 |    JSONP     |    90%     |
| 10月4日  | 深拷贝实例、数组基础、数组方法、数组排序 |          数组方法、类数组          |  自定义原型方法、去重、封装typeof  |    cookie    |    90%     |
| 10月5日  |      错误信息、try_catch、严格模式       |     变量生命周期、垃圾回放原理     |             arguments              |     表单     |    90%     |
| 10月6日  |                函数副作用                |         时间线、解析与渲染         |      剖析JavaScript的执行机制      |   文件上传   |    90%     |
| 10月7日  | 同步与异步加载的三种方法、企业级异步加载 | 异步加载案例、放大模式、宽放大模式 |        IE常见的BUG解决方案         |    iframe    |    80%     |
| 10月8日  |           ObjectDefineProperty           |        ObjectDefineProperty        |      移动端页面常用的meta标签      | postmessage  |    80%     |
| 10月9日  |                   复习                   |                复习                |                复习                |     复习     |    50%     |



**知识整理：**

- JavaScript中的枚举是对象，遍历是按顺序依次获取信息的过程。

- JavaScript中有枚举时一定会有遍历，两者相辅相成。

- **`Object.prototype.hasOwnProperty()`**，获取对象自身属性，返回值是布尔值，作用于拷贝对象前判断是否有自身属性。 该方法会忽略掉那些从原型链上继承到的属性。 

- **`for ... in`** ，遍历会遍历出所有对象包括原型上的属性。

- **`in`运算符**， 如果指定的属性在指定的对象或其原型链中，则 `in` 运算符返回 `true`。 判断属性是否存在于对象里，该方法不会忽略掉那些从原型链上继承到的属性。 

- **`instanceof`** **运算符**，用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。 判断对象是否是构造函数实例化出来的。**缺点**是不能判断原始值，可以拿来判断数据类型(不推荐)。场景是 多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。 检查多个`iframe`窗口的实例对象来区分。

- `this`是`JavaScript`的关键字，是当前环境执行期上下文的一个属性，在不同的环境中`node/window`下表现是不同的。

- 全局作用域下的`this`是全局对象`this === window`

- `web`的全局对象有：`window`,`self`,`frames`

- `node`的全局对象有：`global`

- `worker`的全局对象有：`self`

- `globalThis`可以拿到不同环境下的全局对象

- 严格模式函数内部的`this`指向`undefined`

- 数组的原型`Array prototype`，所有数组都继承于`Array.prototype`，且里面所有的方法都可以继承和使用。

- 数组在JavaScript底层机制，就是继承对象而来，数组就是对象的另一种形式。

- 类数组具有`length`属性，数组形式下标对应的值访问，却没有数组原生方法，如`push`。继承对象原型`Object.prototype`上的方法。

- 利用`Array.prototype.slice.call(arguments))`方法转变类数组为数组。

- `try..catch..`手动抛出错误方法来避免程序遇到错误终止执行。

- **垃圾回收原理：**

  - 找出不再使用的变量
  - 释放其占用内存
  - 固定的时间间隔运行
  
- `arguments`查询函数内部其实是知道实参的个数。返回一个像数组结构的参数列表，其实是一个类数组的参数列表。

- 无论实参如何赋值，形参都会跟着变，形参数组里必须有对应的值，如果实参和形参的对应关系是存在的，那么就存在必然的映射关系。

-  时间线是浏览器开始加载页面(HTML)的开始到整个页面加载结束的过程中按顺序发生的每一件事情的总流程，有了时间线概念就避免使用`window.onload`，因为文档解析完成后里面会执行`DOMContentLoaded`事件, 而`window.onload`仍要等待``脚本加载完毕后才能触发。 

- **`window.onload`**是一个等待触发的事件，在HTML文档构建的过程是DOM树和CSS树构建，构建完毕后合并render渲染树，合并后开始渲染，渲染完毕后加载异步资源，如图片，`iframe`。`window.onload`是要等待以上加载完毕后才会执行的事件。等待这个事件非常浪费时间，所以慎用或少用。

- **`DOMContentLoaded`**是当初始的 HTML文档被完全加载和解析完成之后，`DOMContentLoaded` 事件被触发，而无需等待样式表、图像和子框架`iframe`的完全加载。

-  **样式阻塞**指的是浏览器是否需要暂停网页的首次渲染，直到资源准备就绪。

-  **脚本阻塞**在浏览器解析HTML文档时，如果遇到``文档标签时，便停下对HTML文档进行解析，暂停构建DOM，而优先去加载和执行脚本，等待脚本执行完毕后，浏览器才会从中断的地方恢复DOM构建。  

- `defer`或`async`属性可以显性声明脚本是异步的，防止阻塞DOM构建和渲染。

  - `defer`异步后台加载脚本，不中止文档解析，文档解析完毕后执行后台加载完毕的脚本。
  - `async`异步后台加载脚本，加载的过程不会中止文档解析，但是加载完毕时会马上执行脚本，在执行脚本期间会中止文档解析(阻塞)，直到脚本执行完毕后继续解析文档。

-  在 DOM、CSSOM 构建完毕，`defer` 脚本执行完成之后，DOMContentLoaded 事件触发。 

-  在 DOM、CSSOM 构建完毕，DOMContentLoaded 事件触发，不需要等待`async`脚本执行，资源样式表加载等。 

- **文档加载页面的三个重要阶段：**

  - `document.readyState = 'loading';`，页面加载的第一个阶段
  - `document.readyState = 'interactive';`，DOM和CSS文档**解析**完成阶段
  - `document.readyState = 'complete';`，页面**加载**完成，资源加载完毕，脚本加载和执行完毕，`onload`事件触发的阶段

-  **同步加载**也叫阻塞模式是在同步模式下浏览器加载默认同步加载状态如 `` 标签同步加载的同时 阻塞DOM解析。 

- **需要异步加载的场景：**

  - 工具类函数
  - 不直接操作DOM的库，如https相关的库
  - 用户点击意见反馈才按需加载(问卷调查，数据统计等)

- ***为什么微信打开网页会非常慢？***

  因为微信的SDK程序机制是需要放在页面的`<head>`标签里，这个SDK的JS文件非常大阻止了页面的正常渲染，所以每一打开时都会有一段长时间的白屏。所以做移动端，webApp，渐进式App时，千万不能把``放入``里去。

-  模块化的放大模式(`augmentation`)是把依赖的模块注入到程序中，好处是可以多人共同写同一模块。 
-  Loose augmentation，此写法可以拿到当前的主模块里已有的插件模块继续新增新的模块。实现多人同时合作写一个大的模块，里面的依赖可以独自开发。个人单独开发时不需要用。 
- `Object.defineProperty`直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
- 默认情况是对象是不可枚举，不可修改，不可删除，不可配置，值为`undefined`。
- 在vue2中的数据劫持，因为对每个数据的访问和修改时都进行实时的计算，计算好的数据又跟视图绑定在一起，避免对DOM的直接操作而是操作响应式的数据，实现了视图和数据的双向绑定。



## 第二周

| **日期** |             **早**             |            **午**            |         **晚**          |  **复习内容**  | **完成度** |
| :------: | :----------------------------: | :--------------------------: | :---------------------: | :------------: | :--------: |
| 10月10日 |             Proxy              |     ES-14中对象操作方法      |   观察模式-购物车案例   | 超文本标记语言 |    90%     |
| 10月11日 |            内置对象            |          copyWithin          |   generator，iterator   |  网页设计概念  |    90%     |
| 10月12日 |       entries,fill,find        |    findIndex,flat,flatMap    | from，is,includes，sort |  标题标签特性  |    80%     |
| 10月13日 |              from              |     排序应用，综述，配置     |  排序算法的概念及实现   |  段落标签类型  |    80%     |
| 10月14日 | 类型保护的介绍，核心逻辑的抽离 | 具体接口的定义，排序逻辑实现 |   链表数据结构的实现    |    盒子标签    |    80%     |
| 10月15日 |      使用继承实现排序功能      |      抽象类的介绍和使用      |    数组去重若干方法     |    锚点标签    |    80%     |
| 10月16日 |              复习              |             复习             |          复习           |      复习      |    70%     |



**知识整理：**

- Proxy是ES6的一个构造函数。`Proxy`与`Object.defineProperty`有相似之处，但前者是返回一个代理对象，跟原对象没有任何关系。后者是劫持数据给一个空对象进行拓张，对属性进一步的设置，如配置，枚举等。
- Proxy并不是数据劫持，原因是处理一个完整的原对象后返回一个新代理对象，通过操作代理对象对数据进行操作。
-  Proxy产生的主要作用是自定义对象属性的获取，赋值，枚举，函数调用等功能。在`handler`里可以定义许多实施方法来操作新代理对象里的属性。但假如没有定义`handler`方法时会默认响应一个新代理对象。 
-  除了可以定义`get`，`set`方法，还可以定义对象的14中操作方法，如`has`，`deleteProperty`。它所有的内部方法转发给代理对象，调用这些方法时就会调用代理对象相应的方法。可以通过`handler`定义的方法去重写代理对象默认的内部方法，所有重写方法的方式就相当于做一些拦截操作。 
-  **数组**中使用`Proxy`代理 ， 给数组使用代理也同样像对象做代理，也会触发`get`返回数组元素，触发`set`修改代理对象和原对象的数组元素。可以访问数组长度，可以用数组方法。 
-  **函数**中使用`Proxy`代理 ， 可以给函数引用值进行代理处理。 
- Reflect， ES6新增的一个内置全局对象，叫方法集合的容器。除了枚举，有13中对象内置操作的静态方法。有时不仅是操作对象，还有可能操作函数或者数组，抽离一些公共方法进行管理。 
- Reflect 的好处是未来会有新增方法，抽离`Object`对象里定义混乱的方法。 
- `Array.from` 对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。ES2015，ES6新增。 
-  `Array.from`的第一个参数必须是可迭代对象或者是标准的类数组，第二个参数是一个遍历数组的回调函数，第三个参数是更改回调内部指向。 
-  `copyWithin(target, start, end)`，ES6新增，浅复制数组的一部分到同一数组中的另一个位置，并返回它，**不会改变原数组的长度**，返回的原数组引用。场景是移动数组元素时使用的方法。 
-  `Array.prototype.entries`方法返回一个新的 Array Iterator 数组迭代器对象，该对象包含数组中每个索引的键/值对。 
-  `Array.prototype.fill(target, start, end)`，ES6新增，用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。所有参数均可选。 
- `find`， ES6新增，返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。 
- `findIndex`， ES6新增，返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回`-1`。 
- `flat`， 扁平化，二维数组转为一维数组，不能多层扁平化，ES2019新增，兼容性不太好，会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。`flat`方法的返回值和原数组并**不是**同一引用。 
- `flatMap`， ES2020，兼容性较差，首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 `map`连着深度值为 1 的 `flat`几乎相同，但 `flatMap`通常在合并成一种方法的效率稍微高一些。 
- `includes`， ES2016即ES7新增，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。`includes`方法的不传参时直接返回`false`。 
- `sort`， ES3，对数组的元素进行排序，并返回数组。它返回原数组的引用，不进行数组引用赋值。使用了原地算法。在浏览器V8引擎里，如果`arr.length <= 10`时使用插入排序，如果`arr.length > 10`时使用快速排序，性能上的区别。在Mozilla里使用了归并排序，Webkit使用了`C++`的库QSort方法实现快速排序。 
-  `sort`方法也支持对字符串的排序。经过`toString`方法的过程，将数组元素转为字符串，根据`DOMStrring`是UTF-16字符串的实现，会映射到`String`构造函数上去构建字符串。每个字符串都是UTF-16字符串，通过`String`或`DOMString`实例化出来的。按照UTF-16的编码顺序来进行排序的。 
-  转成字符串的原因是数字如果仅限于一种类型的排序时，`sort`的功能性就不高，希望有一种规则让所有的类型都可以进行排序，所有通过字符串和字符串编码集结合一起排序形成规则，这样可排序的范围就会变大。 



## 第三周

| **日期** |          **早**           |                **午**                 |                  **晚**                  | **复习内容** | **完成度** |
| :------: | :-----------------------: | :-----------------------------------: | :--------------------------------------: | :----------: | :--------: |
| 10月17日 |  数组扁平化、去重与排序   | 函数组合、结合律、pointfree、实用案例 | 数组扁平化基础与原理、数组扁平化函数封装 |   范围标签   |    90%     |
| 10月18日 |    异步的开端-promise     |           promise的使用方法           |                 iterator                 |   序列标签   |    90%     |
| 10月19日 |         generator         |             async与await              |               ES6的模块化                | 下拉菜单标签 |    90%     |
| 10月20日 | 手写实现之『ES6 Promise』 |       手写实现之『ES6 Promise』       |        手写实现之『ES6 Promise』         |   表格标签   |    90%     |
| 10月21日 | 手写实现之『ES6 Promise』 |           JavaScript模块化            |           生成器与迭代器的应用           |   字符实体   |    80%     |
| 10月22日 |         grid布局          |               grid布局                |                 grid布局                 |  上下标标签  |    90%     |
| 10月23日 |           复习            |                 复习                  |                   复习                   |     复习     |    70%     |



**知识整理：**

- 数组扁平化的方法有`concat`，`reduce + concat`，`flat`。
- 数组去重的方法有新旧数组`for`循环，同组数组`for`循环，`filter + indexOf`，`forEach + indexOf`，`sort`，`includes`，`sort + reduce`，`Map`，`Set`。
- 函数组合也叫饲养函数(`compose`)，饲养高品质的函数做优质的输出，用一个新的函数把其他功能的函数组合起来后可以一次性解决这些函数的单个函数要解决的问题 。
-  若干个纯函数，偏函数，柯里化函数组合成一个新的函数形成数据传递，并实现一种有序执行的效果 。
- 左倾方式是函数参数自右向左边执行函数的方式 。
-  结合律是在组合函数的参数中再进行分组，它和原来函数组合得出的结果是一样的 。
- JavaScript是通过事件轮询的方式来实现异步，事件循环的核心是回调函数。
- Promise是一个异步问题同步化解决方案，目的为了把异步任务(如`ajax`请求)，实现同步化之后避免会堵塞后面的程序并拿到结果，顺便解决回调地狱。
- `generator`函数语法。作用是访问迭代器对象，返回值是迭代器对象。
- 生成器函数一定要和`yeild`结合使用，可以自定义产出内容和返回值，用法和迭代器有点像`yeild`：产出的意思，产出的同时暂停程序向下执行。
- `yeild`和`return`本质的区别：
  - `yeild`暂停，找上一次暂停的位置，有记忆功能
  - `return`结束程序执行
- `next()`传值问题是蛇形传值方式。
- 生成器对象上的`return()`/`throw()`方法。终结迭代的方式，终结遍历这个函数，后面`next`获取的值都为`undefined`。和在生成器函数内部直接`return`的结果一样。
- 迭代的本质也在读取数据结构的值，抽取当中结构数据的第一个值，迭代器是一种有序的，连续的，基于抽取的组织方式。
- 内部迭代器是指系统内部定义好的迭代规则，如数组原型上的迭代器函数。外部迭代器是指通过某种方式给他部署一个迭代器接口，一次抽取一个数据，一次迭代一个数据。
- 因为对象不具备迭代器接口，部署迭代器方式生成一个外部迭代器便于`for of`遍历。
- `async/await`适用于异步函数的`ES6`语法，本质上也是一个语法糖，来源于生成器函数。
- 它内置的执行器(`co`函数)，更好的语义，更广的实用性。
- `async`的返回值是一个`Promise`对象，也有三种状态，每种状态对应每种回调。





## 第四周

| **日期** |          **早**           |          **午**           |          **晚**           | **复习内容** | **完成度** |
| :------: | :-----------------------: | :-----------------------: | :-----------------------: | :----------: | :--------: |
| 10月24日 |      闭包与设计（1）      |      闭包与设计（2）      |      闭包与设计（3）      |   标签结构   |    80%     |
| 10月25日 |       async与await        |        ES6的模块化        | 手写实现之『ES6 Promise』 |   标签属性   |    80%     |
| 10月26日 | 手写实现之『ES6 Promise』 | 手写实现之『ES6 Promise』 |     JavaScript模块化      |   书写标准   |    80%     |
| 10月27日 |     JavaScript模块化      |   插件_组件_模块化开发    |    手写简化版requireJS    |   标签嵌套   |    90%     |
| 10月28日 |    手写简化版requireJS    |    commonJS_ES6module     |  商城购物车项目模块实战   |   内联元素   |    90%     |
| 10月29日 |  商城购物车项目模块实战   |  商城购物车项目模块实战   |  商城购物车项目模块实战   |   块级元素   |    90%     |
| 10月30日 |           复习            |           复习            |           复习            |     复习     |    80%     |



**知识整理：**

-  一个闭包像是一个函数，每一个函数在创建的时候就形成了闭包。从JavaScript引擎发散出来的一个概念。一个函数有条件访问到外界作用域的这种现象叫做闭包。一个闭包有条件获取外部作用域的任何变量的现象。 

-  当一个函数能访问到外部函数的词法作用域的现象叫做实用的闭包。

-  将闭包的概念转换为设计方案。功能集成具备独立的功能，封装产生程序的作用，一个功能模块带有私有化。作用域向上查找的可行性，对变量更好的使用。对外提供一致接口，隐藏具体实现。 

-  将函数内部的方法供外界使用。一个闭包返回与不返回决定不了是否是一个闭包，而能决定的是它的私有性或公有性和它有没有一个公共的接口的特性。 

-  柯里化对闭包进一步使用，从而让返回值具备公共接口的特性。一个函数内部返回一个函数。闭包可以对外部函数进行二次封装以达到按条件进行执行的目的。 

- `new`实例化过程产生`Object`包装后的`this`，并对`this`对象进行属性和方法的赋值，然后返回`this`，这个`this`是一个闭包。

- 函数特性，在充当方法的时候，属于静态特性，无论实例化多少次，函数和函数内部完成的功能是不会变化的。所以都不应该每一次都实例化。

- JavaScript本身存在问题，解决问题。引入思想解决问题。解决问题过程中使用了哪些方法。模块化解决了现实的**加载顺序**和**污染全局**还顺便解决模块依赖的问题。 

-  当`index.js`文件只有放在最底下才能访问和使用以上模块，原因是文档解析加载造成的阻塞问题还有各个模块之间依赖的问题。模块暴露的变量将会变成全局变量，会造成环境污染。

-  利用闭包和立即执行函数可以将一个模块实现真正的独立，属性和方法变成私有。对各个模块之间可以使用模块注入的方式解决模块依赖的问题。  

-  利用`NodeJS`中的`require()`引入模块和模块导出`module.export`的功能(必须在`node`环境中运行)去解决执行加载顺序的问题。原理是基于`CommonJS`中的模块在服务器环境中的引入和导出。 

- `CommonJS` 是一种模块化规范，来源于`NodeJS`，在服务端开发时使用`require`模块。`CommonJS`上的方法是同步的。`CommonJS`会使用`require`，只要需要依赖引用时，它会创建一个模块的实例，并且它只能在`node`环境中执行。 

-  由于`CommonJS`只能在服务器环境运行，所以有了客户端的`AMD`模块定义，基于`CommonJS`在客户端能够加载模块的一种方案。`AMD`跟`CommonJS`只是表面上相似，但是`AMD`是异步关系的，全称叫异步模块定义(Asynchronous Module Definition)。有一个库叫`RequireJS`可以实现`AMD`。 

-  [RequireJS](https://requirejs.org/)是一个 JavaScript 文件和模块加载器，可以实现客户端的`AMD`模块定义的库。定义一个模块，假如有依赖模块需要添加模块名称，可以解决客户端中脚本加载顺序和模块依赖的问题。 

-  一个普通的模块加载，一个异步的模块定义。阿里也为模块化做了贡献。`CMD`叫通用模块定义(Common Module Definition)。与`AMD`类似但有本质的区别，也是需要[Sea.js](https://seajs.github.io/seajs/docs/#docs)库来实现模块化加载，该库是阿里实现的，实现后来实现`CMD`。 

- 依赖就近，按需加载，使`CommonJS`，`AMD`有着本质的差异。`AMD`依赖前置，等模块加载完毕后才去执行回调函数，而`SeaJS`是需要的时候才会去加载，执行效率上就有着本质的差异。 

- ES6官方新增模块化，异步模块定义(Asynchronous Module Definition)。ECMA统一了`AMD`和`CMD`的两种规范。从机制上，`CommonJS`模块输出的是一个值的拷贝，而`ES6`模块输出的是值的引用。`CommonJS`模块在运行时加载，`ES6`模块是在编译时加载，浏览器环境不支持，需要有服务器环境去加载。

  