# 学习计划

## 第一周

| **日期** |        **早**        |        **午**        |        **晚**        |  **复习内容**  | **完成度** |
| :------: | :------------------: | :------------------: | :------------------: | :------------: | :--------: |
|  4月3日  | `node`中`event-loop` | `node`中`event-loop` | `node`中`event-loop` |    滑入滑出    |    80%     |
|  4月4日  |   `promise`面试题    |   `promise`面试题    |   `promise`面试题    |    滚屏优化    |    80%     |
|  4月5日  |      `<iframe>`      |  `document.domain`   |    `window.name`     |    键盘事件    |    80%     |
|  4月6日  |    `postMessage`     |  `history.location`  |       同源策略       | 浏览器页面解析 |    90%     |
|  4月7日  |    `cors`跨域设置    |        `hash`        |       `jsonp`        |    `DOM`树     |    90%     |
|  4月8日  |     `jsonp`案例      |     `jsonp`案例      |     `jsonp`实战      |    `CSS`树     |    80%     |
|  4月9日  |         复习         |         复习         |         复习         |      复习      |     0%     |

**知识整理：**

- `node`事件环不像浏览器的事件环是一个真正的环，它把所有的任务事件都分配到不同的阶段，在宏任务基础上进行从上到下不停的执行直至每一个阶段都没有任务了，`node`环境不存在微任务队列只有宏任务队列，而宏任务队列分为以下阶段：
  1. **`Timer`定时器**: `setTimeout`,`setInterval`。
  2. `Pending callbacks`待定回调，执行延迟到下一个事件环迭代的`I/O`回调(内部机制使用)。
  3. `Idle`，`prepare`，系统内部机制使用。
  4. **`Poll`轮询**，这个阶段是轮询时间，用于等待还未返回的 `I/O` 事件，比如服务器的回应、文件读写，数据库操作，网络请求等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待` I/O` 请求返回结果。(排除定时器，关闭的回调函数)
  5. **`Check`检测**，`setImmediate`的回调函数。
  6. `Close callbacks`关闭的回调函数，(内部机制使用)，如`socket.on('close', fn)`。
- `Timer`**队列**，只执行`setTimeout`和`setInterval`，但是他们的`callback`不会执行，而是推到宏任务的队列之中。
- **`Poll`队列**，会先执行符合条件的微任务，比如`Promise`的异步完成，如果是`setImmediate`，则只会执行，不执行他的`callback`，然后执行定时器的`callback`，比如`timeout`。这里会适当得暂停一会，看看会不会有新任务进入队列。如果有`setImmediate`的`callback`则进入`Check `阶段，否则回到`Timer`继续新一轮循环。
- `Check`**队列**，当`Poll`阶段的队列完成，则会轮到`Check`，这时会执行`setImmediate`的`callback`。如果没有需要关闭`callbacks`，那么就回到`Timer`继续新一轮的循环。
- `process.nextTick`在`node`环境中的方法与`vue`的用法是一致的。它是微任务，而且优先于`promise.then`的执行。
- 在同步任务中，理论上，`timer`是优先于`check`的`setImmediate`执行的，事实是时间非常短暂，执行环境有延时时候`check`有可能优先于`timer`执行，所以避免这种竞争态情况的发生，稳妥的写法是用一个宏任务进行包裹，这样就可以确保`check`可以永远优先于`timer`执行，因为在外层`setTimeout`中一定会走`timer`,导致里面的`timer`挂起，并在当前事件环中走`check`，接着再走`timer`。
- `setImmediate`用法有点像`setTimeout`，用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。在`vue`中，使用`setImmediate`会比使用`setTimeout`会是一个更好的选择，在宏任务里，使用`setTimeout`会有一些怪异的行为。
- `<iframe>`标签嵌套了浏览器窗口的上下文，能够将另一个`HTML`页面嵌入到当前页面中。`<iframe>`引入页面时会有一个加载过程，`onload`事件可以等到页面加载完毕后触发。
- `iframe`的节点对象的`contentWindow.name`属性可以获取加载的`<iframe>`页面窗口的自定义名称。`contentWindow`就是该`iframe`窗口的`window`对象。
- `window.name`是每个浏览器窗口都有一个全局变量 `window`(包括 `iframe` 框架 `contentWindow`)。每个 `window` 对象都有一个 `name` 属性(一个窗口只有一个`name`属性)。该窗口被关闭前(生命周期内)，所有页面共享一个 `name` 属性并有读写的权限。无论该窗口被关闭前，载入什么页面，都不会改变 `name` 值。存储约为 `2M` 的字符串。
- 跨越解决方案一是服务器中转请求，客户端向同源服务器发起请求，同源服务器向不同源服务器发起请求。
- 跨越解决方案二是给客户端通过`<iframe>`标签引入外部页面，外部页面自带`ajax`请求数据程序。在本页面的脚本代码中，拿到外部页面的`ajax`程序并对本页基础域名的修改和对`ajax`进行再次封装，实现跨域数据请求。原理是保证一个网页不能访问（修改或提取数据）另一个页面，除非这些页面托管在同一源上。为了解决很多跨域间的通信问题，许多的网站会通过设置`document.domain`来达到目的。例如，`user1.example.com` 和 `user2.example.com`之间是不能相互访问的，为了实现这种跨域访问，通过将 `document.domain` 设置为其公共域后缀，它们可以相互授予访问权限。（目前已经被`mdn`弃用）。这是针对方案二对`ajax`进行`domain`属性的再次封装[代码](https://gitee.com/kevinleeeee/ajax-domain-encapsulation)。
- 跨越解决方案三是`iframe`与父级不同源的地址设置共享`window.name`属性(适用于简单的字符数据)，通过`iframe`跳转(`location.href`)到与父级同源的地址，当父级拿到`window.name`属性就可以访问父级同源的地址。[演示代码案例](https://gitee.com/kevinleeeee/cors-windowname-demo)。
- 跨越解决方案四是不同源与父级窗口通过`postMessage`进行通信，获取请求数据，不常用的原因是兼容性不够好。特别容易伪造发送和接收端的数据，有很多漏洞和`xss`攻击。
- 跨越解决方案五是`iframe`与父级不同源的加`#/api`接口，`iframe`加载时获取`hash`值来判断接口名字并发起`ajax`请求。适用于简单数据。
- `JSONP`它是一种常用的解决跨域请求的方式，刻意的跨域请求方式方便于服务器的数据分离管理，适用于大型项目。`JSON with Padding`：跨域获取 `JSON` 数据的一种非官方的使用模式。



## 第二周

| **日期** |    **早**    |     **午**     |      **晚**      | **复习内容**  | **完成度** |
| :------: | :----------: | :------------: | :--------------: | :-----------: | :--------: |
| 4月10日  | `jsonp`实战  | `<iframe>`实战 |  `<iframe>`实战  | 网络请求流程  |    90%     |
| 4月11日  |    `JSON`    |     `JSON`     |    `Date`对象    |   统一资源    |    90%     |
| 4月12日  |  `Date`对象  |    强制缓存    |     协商缓存     | `DNS`解析过程 |    80%     |
| 4月13日  | `setTimeout` | `setInterval`  |     严格模式     |   `TCP`过程   |    80%     |
| 4月14日  |  `ES6`历史   |   块级作用域   |    `let`声明     |   三次握手    |    80%     |
| 4月15日  |  暂行式死区  |  `const`声明   | `window`顶层对象 |   四次挥手    |    90%     |
| 4月16日  |     复习     |      复习      |       复习       |     复习      |    80%     |

**知识整理：**

- `JSON`是`JavaScript Object Notation` (`JavaScript`对象标记)，`JSON`是轻量级数据交互的格式，数据型的交换里面不包含方法。`JavaScript`对象的一种表达方式，是包含方法的。`JSON`是`JavaScript`对象的一个衍生，`JSON`选用映射的关系来形成一个轻量级的数据结构。
- 所有编程语言都离不开的三大数据类型是：
  - `scalar`标量(字符串和数字)
  - `sequence`序列(数组和列表)
  - `mapping`映射(键值对)，如函数参数的映射关系，将两个不同的东西映射在一起，如键值对，`hash`表。
- 早期使用`XML`进行前后端的数据交互，优点是可以自定义标签，关于`XML`的缺点：
  - 数据文档很大
  - 不易读
  - 解析难度比较大
- `JSON.parse()`将JSON字符串转换成`JSON`对象。`JSON.stringify()`将`JSON`数据转为字符串。前后端交互的数据只能是字符串。
- 严格模式是`JavaScript`整个脚本语言在设计之初只用了7天，运行非常快也非常简单，导致开发者刚入门时很容易，但到了后期就会发现这门语言其实并不够严谨和不太安全，此时出现一种更为安全和保证代码运行的模式，使其阅读起来更为规范。
- 严格模式的目的是减少语法层面的不合理，不严谨，不安全，怪异行为。`ES5`开始有严格模式和非严格模式，`IE9 `及以下不支持严格模式。

- 在严格模式下的区别有：
  - 变量层面
    - 全局变量声明时必须用`var`，否则使用严格模式时变量为`undefined`
    - 保留字和关键字不允许使用，如`var eval`
    - 全局变量的`delete`操作符失效问题(静默失败)，通过报错方式解决
  - 对象层面
    - 对象属性描述符造成的操作失败的问题(静默失败)，报错
    - `for...in`循环不会报错
  - 函数层面
    - 函数参数需要唯一的
    - 形参实参就没有相互映射关系
    - `caller`和`callee`会报错
    - `arguments.callee`指的是调用函数本身
    - `函数名称.caller`是函数属性，它指向当前调用函数的作用域
    - `eval`和`with`语句报错
- 日期对象`Date`实例呈现时间中的某个时刻。`Date`日期对象也是一个构造函数。
- `Date`实例化后的`toString()`方法返回也是一串时间。该`toString()`方法是继承`Object`原型。
- `getDate()`方法返回当前一个月的第几天，如`1-31`，返回几号。
- `getDay()`方法返回当前是周的第几天，如`0-6`，`0`代表周日。
- `getMonth()`方法返回当前为第几个月，`0-11`，`0`代表一月。
- `getYear()`方法已经废弃，替换的方法是`getFullYear()`，返回当前年份。
- `getHours()`方法返回当前小时。`0-23`。
- `getMinutes()`方法返回当前分钟数，`0-59`。
- `getSeconds()`方法返回当前秒数，`0-59`。
- `toJSON()`方法返回一个时间格式为`ISO`日期字符串的`JSON`字符串，等同`JSON.stringify()`返回的时间格式，同样也等同`toISOString()`返回的时间格式。
- `setTime()`方法可以设置指定时间戳为当前时间。它的类似操作像实例化`Date`对象时传入指定时间获取的时间是一致的。
- 时间秒数后`0-1000`的值为`1`秒。`getMilliseconds()`方法获取毫秒数。
- `getTime()`方法返回当前格林威治时间数值也叫时间戳。从计算机纪元时间`1970-1-1`的`0`分`0`秒开始记起，截止当前时间过了多少毫秒数。利用两个精确时间戳的时间差可以做很多事情，如倒计时，对比算法等。
- `Date.now()`方法返回当前格林威治时间数值。
- `Date.parse()`方法返回解析一个表示某个日期的字符串。
- **强制缓存**是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求。设置缓存时间的方法有两种（响应头字段）：`Expires`（`HTTP/1.0`）或 `Cache-Control`（`HTTP/1.1`)。
- 强制缓存除了首页`index.html`以外的静态文件如`css`，`js`文件，在服务器中设置缓存的两个方法(`res.setHeader('Expires', expiresTimes)`，`res.setHeader('Cache-Control', 'max-age=10');`)都需要同时设置来兼容老版本。
- **协商缓存**解决首屏`index.html`无法缓存的问题，也叫对比缓存，不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 `HTTP` 状态为 `304`，则表示缓存仍然有效；否则返回状态码 `200` 、最新的资源和最新的资源标识。协商缓存对首屏文件如`index.html`在服务器中进行设置缓存方法(`res.setHeader('Last-Modified', lastModified);`)。
- 服务器中获取请求头信息里的上次修改时间 `if-modified-since`属性的值来和当前读取文件时的上次修改时间`statObj.mtime.toGMTString()`来进行对比，如果时间没有变化则缓存。
- 协商缓存根据前后修改时间判断会存在缺点，文件内容没有修改但是修改时间变化了，它也会去重新读取文件。而且在1秒内的多次更改内容，是无法检测到的，存在精度问题。为了解决这些问题，协商缓存可以根据是否修改了文件内容而进行对比。只有在文件内容被修改的情况下才进行文件读取操作。利用了`MD5`摘要算法，该算法的特点是无法进行还原，不可逆的，根据内容不同导致结果不同，不管内容长度最终结果的长度都会一样的，只要内容更改一点，导致的结果会发生巨大的差异。
- 服务器中通过设置响应头的`Etag`标志属性的值为当前的`hash`值(`res.setHeader('Etag', contentHash);`)。
- 获取请求头信息里的上次修改内容的`hash`值，即服务器响应头定义的`Etag`属性的值(`let ifNoneMatch = req.headers['if-none-match'];`)。对文件内容摘要哈希进行比对。如果内容没有变化则缓存。
- `let`本质是为了`JS`增加一个块级作用域。`ES6`新增的`let`语法是声明变量生成单独块级作用域。函数作用域是无法正常访问的一个隐式的对象，在函数执行前一刻产生的对象。 `[[scope]]` 存储在预编译时期产生的 `GO`全局执行期上下文，和`AO`函数执行期上下文。在预编译过程中有`var`关键字声明提升的过程，会存在同一环境下的二次覆盖的变量污染问题，在`ES5`解决办法是通过立即执行函数来封闭函数作用域的方式来避免变量污染，但是函数内部仍然存在变量污染的问题，因此会采用一个`kiss`原则(`keep it simple and stupid`)来保证函数功能的单一性，函数提纯等一系列方法来解决变量污染问题。
- 块级作用域不等于匿名函数的立即调用，使用立即执行函数可以模拟块级作用域，但立即执行函数是有返回值的，而块级作用域内部是没有返回值给外部访问的。
- **`let`具有以下特点：**
  - `let`不允许在同一作用域下重复声明
  - `let`不会声明提升，会产生一个暂时性死区(`Temporal Dead Zone`)
  - `let`只能再当前的块级作用域下生效
- `const`定义常量，不可变的量，不期望变量被更改。在模块引入时，不希望模块被更改，只是使用模块里的属性和方法。
- **`const`特点：**
  - 定义的常量必要要赋值
  - 一旦定义必须赋值，值不能被更改
  - 有块级作用域，存在暂时性死区
  - 常量不能重复声明



## 第三周

| **日期** |  **早**  |   **午**   |  **晚**  |   **复习内容**    | **完成度** |
| :------: | :------: | :--------: | :------: | :---------------: | :--------: |
| 4月17日  | 解构赋值 | 函数默认值 | 解构本质 |     同源策略      |     0%     |
| 4月18日  |  待计划  |   待计划   |  待计划  |    `<iframe>`     |     0%     |
| 4月19日  |  待计划  |   待计划   |  待计划  |   `window.name`   |     0%     |
| 4月20日  |  待计划  |   待计划   |  待计划  | `document.domain` |     0%     |
| 4月21日  |  待计划  |   待计划   |  待计划  |  `location.hash`  |     0%     |
| 4月22日  |  待计划  |   待计划   |  待计划  |      `jsonp`      |     0%     |
| 4月23日  |   复习   |    复习    |   复习   |       复习        |     0%     |

**知识整理：**
