# 学习计划

## 第一周

| **日期** |        **早**        |        **午**        |        **晚**        |  **复习内容**  | **完成度** |
| :------: | :------------------: | :------------------: | :------------------: | :------------: | :--------: |
|  4月3日  | `node`中`event-loop` | `node`中`event-loop` | `node`中`event-loop` |    滑入滑出    |    80%     |
|  4月4日  |   `promise`面试题    |   `promise`面试题    |   `promise`面试题    |    滚屏优化    |    80%     |
|  4月5日  |      `<iframe>`      |  `document.domain`   |    `window.name`     |    键盘事件    |    80%     |
|  4月6日  |    `postMessage`     |  `history.location`  |       同源策略       | 浏览器页面解析 |    90%     |
|  4月7日  |    `cors`跨域设置    |        `hash`        |       `jsonp`        |    `DOM`树     |    90%     |
|  4月8日  |     `jsonp`案例      |     `jsonp`案例      |     `jsonp`实战      |    `CSS`树     |    80%     |
|  4月9日  |         复习         |         复习         |         复习         |      复习      |     0%     |



**知识整理：**

- `node`事件环不像浏览器的事件环是一个真正的环，它把所有的任务事件都分配到不同的阶段，在宏任务基础上进行从上到下不停的执行直至每一个阶段都没有任务了，`node`环境不存在微任务队列只有宏任务队列，而宏任务队列分为以下阶段：
  1. **`Timer`定时器**: `setTimeout`,`setInterval`。
  2. `Pending callbacks`待定回调，执行延迟到下一个事件环迭代的`I/O`回调(内部机制使用)。
  3. `Idle`，`prepare`，系统内部机制使用。
  4. **`Poll`轮询**，这个阶段是轮询时间，用于等待还未返回的 `I/O` 事件，比如服务器的回应、文件读写，数据库操作，网络请求等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待` I/O` 请求返回结果。(排除定时器，关闭的回调函数)
  5. **`Check`检测**，`setImmediate`的回调函数。
  6. `Close callbacks`关闭的回调函数，(内部机制使用)，如`socket.on('close', fn)`。
- `Timer`**队列**，只执行`setTimeout`和`setInterval`，但是他们的`callback`不会执行，而是推到宏任务的队列之中。
- **`Poll`队列**，会先执行符合条件的微任务，比如`Promise`的异步完成，如果是`setImmediate`，则只会执行，不执行他的`callback`，然后执行定时器的`callback`，比如`timeout`。这里会适当得暂停一会，看看会不会有新任务进入队列。如果有`setImmediate`的`callback`则进入`Check `阶段，否则回到`Timer`继续新一轮循环。
- `Check`**队列**，当`Poll`阶段的队列完成，则会轮到`Check`，这时会执行`setImmediate`的`callback`。如果没有需要关闭`callbacks`，那么就回到`Timer`继续新一轮的循环。
- `process.nextTick`在`node`环境中的方法与`vue`的用法是一致的。它是微任务，而且优先于`promise.then`的执行。
- 在同步任务中，理论上，`timer`是优先于`check`的`setImmediate`执行的，事实是时间非常短暂，执行环境有延时时候`check`有可能优先于`timer`执行，所以避免这种竞争态情况的发生，稳妥的写法是用一个宏任务进行包裹，这样就可以确保`check`可以永远优先于`timer`执行，因为在外层`setTimeout`中一定会走`timer`,导致里面的`timer`挂起，并在当前事件环中走`check`，接着再走`timer`。
- `setImmediate`用法有点像`setTimeout`，用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。在`vue`中，使用`setImmediate`会比使用`setTimeout`会是一个更好的选择，在宏任务里，使用`setTimeout`会有一些怪异的行为。
- `<iframe>`标签嵌套了浏览器窗口的上下文，能够将另一个`HTML`页面嵌入到当前页面中。`<iframe>`引入页面时会有一个加载过程，`onload`事件可以等到页面加载完毕后触发。
- `iframe`的节点对象的`contentWindow.name`属性可以获取加载的`<iframe>`页面窗口的自定义名称。`contentWindow`就是该`iframe`窗口的`window`对象。
- `window.name`是每个浏览器窗口都有一个全局变量 `window`(包括 `iframe` 框架 `contentWindow`)。每个 `window` 对象都有一个 `name` 属性(一个窗口只有一个`name`属性)。该窗口被关闭前(生命周期内)，所有页面共享一个 `name` 属性并有读写的权限。无论该窗口被关闭前，载入什么页面，都不会改变 `name` 值。存储约为 `2M` 的字符串。
- 跨越解决方案一是服务器中转请求，客户端向同源服务器发起请求，同源服务器向不同源服务器发起请求。
- 跨越解决方案二是给客户端通过`<iframe>`标签引入外部页面，外部页面自带`ajax`请求数据程序。在本页面的脚本代码中，拿到外部页面的`ajax`程序并对本页基础域名的修改和对`ajax`进行再次封装，实现跨域数据请求。原理是保证一个网页不能访问（修改或提取数据）另一个页面，除非这些页面托管在同一源上。为了解决很多跨域间的通信问题，许多的网站会通过设置`document.domain`来达到目的。例如，`user1.example.com` 和 `user2.example.com`之间是不能相互访问的，为了实现这种跨域访问，通过将 `document.domain` 设置为其公共域后缀，它们可以相互授予访问权限。（目前已经被`mdn`弃用）。这是针对方案二对`ajax`进行`domain`属性的再次封装[代码](https://gitee.com/kevinleeeee/ajax-domain-encapsulation)。
- 跨越解决方案三是`iframe`与父级不同源的地址设置共享`window.name`属性(适用于简单的字符数据)，通过`iframe`跳转(`location.href`)到与父级同源的地址，当父级拿到`window.name`属性就可以访问父级同源的地址。[演示代码案例](https://gitee.com/kevinleeeee/cors-windowname-demo)。
- 跨越解决方案四是不同源与父级窗口通过`postMessage`进行通信，获取请求数据，不常用的原因是兼容性不够好。特别容易伪造发送和接收端的数据，有很多漏洞和`xss`攻击。
- 跨越解决方案五是`iframe`与父级不同源的加`#/api`接口，`iframe`加载时获取`hash`值来判断接口名字并发起`ajax`请求。适用于简单数据。
- `JSONP`它是一种常用的解决跨域请求的方式，刻意的跨域请求方式方便于服务器的数据分离管理，适用于大型项目。`JSON with Padding`：跨域获取 `JSON` 数据的一种非官方的使用模式。



## 第二周

| **日期** |   **早**    |     **午**     |     **晚**     | **复习内容**  | **完成度** |
| :------: | :---------: | :------------: | :------------: | :-----------: | :--------: |
| 4月10日  | `jsonp`实战 | `<iframe>`实战 | `<iframe>`实战 | 网络请求流程  |     0%     |
| 4月11日  |   待计划    |     待计划     |     待计划     |   统一资源    |     0%     |
| 4月12日  |   待计划    |     待计划     |     待计划     | `DNS`解析过程 |     0%     |
| 4月13日  |   待计划    |     待计划     |     待计划     |   `TCP`过程   |     0%     |
| 4月14日  |   待计划    |     待计划     |     待计划     |   三次握手    |     0%     |
| 4月15日  |   待计划    |     待计划     |     待计划     |   四次挥手    |     0%     |
| 4月16日  |    复习     |      复习      |      复习      |     复习      |     0%     |



**知识整理：**

- 
