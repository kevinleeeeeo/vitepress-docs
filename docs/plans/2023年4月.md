# 学习计划

## 第一周

| **日期** |        **早**        |        **午**        |        **晚**        |  **复习内容**  | **完成度** |
| :------: | :------------------: | :------------------: | :------------------: | :------------: | :--------: |
|  4月3日  | `node`中`event-loop` | `node`中`event-loop` | `node`中`event-loop` |    滑入滑出    |    80%     |
|  4月4日  |   `promise`面试题    |   `promise`面试题    |   `promise`面试题    |    滚屏优化    |    80%     |
|  4月5日  |      `<iframe>`      |  `document.domain`   |    `window.name`     |    键盘事件    |    80%     |
|  4月6日  |    `postMessage`     |  `history.location`  |       同源策略       | 浏览器页面解析 |    90%     |
|  4月7日  |    `cors`跨域设置    |        `hash`        |       `jsonp`        |    `DOM`树     |    90%     |
|  4月8日  |     `jsonp`案例      |     `jsonp`案例      |     `jsonp`实战      |    `CSS`树     |    80%     |
|  4月9日  |         复习         |         复习         |         复习         |      复习      |     0%     |

**知识整理：**

- `node`事件环不像浏览器的事件环是一个真正的环，它把所有的任务事件都分配到不同的阶段，在宏任务基础上进行从上到下不停的执行直至每一个阶段都没有任务了，`node`环境不存在微任务队列只有宏任务队列，而宏任务队列分为以下阶段：
  1. **`Timer`定时器**: `setTimeout`,`setInterval`。
  2. `Pending callbacks`待定回调，执行延迟到下一个事件环迭代的`I/O`回调(内部机制使用)。
  3. `Idle`，`prepare`，系统内部机制使用。
  4. **`Poll`轮询**，这个阶段是轮询时间，用于等待还未返回的 `I/O` 事件，比如服务器的回应、文件读写，数据库操作，网络请求等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待` I/O` 请求返回结果。(排除定时器，关闭的回调函数)
  5. **`Check`检测**，`setImmediate`的回调函数。
  6. `Close callbacks`关闭的回调函数，(内部机制使用)，如`socket.on('close', fn)`。
- `Timer`**队列**，只执行`setTimeout`和`setInterval`，但是他们的`callback`不会执行，而是推到宏任务的队列之中。
- **`Poll`队列**，会先执行符合条件的微任务，比如`Promise`的异步完成，如果是`setImmediate`，则只会执行，不执行他的`callback`，然后执行定时器的`callback`，比如`timeout`。这里会适当得暂停一会，看看会不会有新任务进入队列。如果有`setImmediate`的`callback`则进入`Check `阶段，否则回到`Timer`继续新一轮循环。
- `Check`**队列**，当`Poll`阶段的队列完成，则会轮到`Check`，这时会执行`setImmediate`的`callback`。如果没有需要关闭`callbacks`，那么就回到`Timer`继续新一轮的循环。
- `process.nextTick`在`node`环境中的方法与`vue`的用法是一致的。它是微任务，而且优先于`promise.then`的执行。
- 在同步任务中，理论上，`timer`是优先于`check`的`setImmediate`执行的，事实是时间非常短暂，执行环境有延时时候`check`有可能优先于`timer`执行，所以避免这种竞争态情况的发生，稳妥的写法是用一个宏任务进行包裹，这样就可以确保`check`可以永远优先于`timer`执行，因为在外层`setTimeout`中一定会走`timer`,导致里面的`timer`挂起，并在当前事件环中走`check`，接着再走`timer`。
- `setImmediate`用法有点像`setTimeout`，用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。在`vue`中，使用`setImmediate`会比使用`setTimeout`会是一个更好的选择，在宏任务里，使用`setTimeout`会有一些怪异的行为。
- `<iframe>`标签嵌套了浏览器窗口的上下文，能够将另一个`HTML`页面嵌入到当前页面中。`<iframe>`引入页面时会有一个加载过程，`onload`事件可以等到页面加载完毕后触发。
- `iframe`的节点对象的`contentWindow.name`属性可以获取加载的`<iframe>`页面窗口的自定义名称。`contentWindow`就是该`iframe`窗口的`window`对象。
- `window.name`是每个浏览器窗口都有一个全局变量 `window`(包括 `iframe` 框架 `contentWindow`)。每个 `window` 对象都有一个 `name` 属性(一个窗口只有一个`name`属性)。该窗口被关闭前(生命周期内)，所有页面共享一个 `name` 属性并有读写的权限。无论该窗口被关闭前，载入什么页面，都不会改变 `name` 值。存储约为 `2M` 的字符串。
- 跨越解决方案一是服务器中转请求，客户端向同源服务器发起请求，同源服务器向不同源服务器发起请求。
- 跨越解决方案二是给客户端通过`<iframe>`标签引入外部页面，外部页面自带`ajax`请求数据程序。在本页面的脚本代码中，拿到外部页面的`ajax`程序并对本页基础域名的修改和对`ajax`进行再次封装，实现跨域数据请求。原理是保证一个网页不能访问（修改或提取数据）另一个页面，除非这些页面托管在同一源上。为了解决很多跨域间的通信问题，许多的网站会通过设置`document.domain`来达到目的。例如，`user1.example.com` 和 `user2.example.com`之间是不能相互访问的，为了实现这种跨域访问，通过将 `document.domain` 设置为其公共域后缀，它们可以相互授予访问权限。（目前已经被`mdn`弃用）。这是针对方案二对`ajax`进行`domain`属性的再次封装[代码](https://gitee.com/kevinleeeee/ajax-domain-encapsulation)。
- 跨越解决方案三是`iframe`与父级不同源的地址设置共享`window.name`属性(适用于简单的字符数据)，通过`iframe`跳转(`location.href`)到与父级同源的地址，当父级拿到`window.name`属性就可以访问父级同源的地址。[演示代码案例](https://gitee.com/kevinleeeee/cors-windowname-demo)。
- 跨越解决方案四是不同源与父级窗口通过`postMessage`进行通信，获取请求数据，不常用的原因是兼容性不够好。特别容易伪造发送和接收端的数据，有很多漏洞和`xss`攻击。
- 跨越解决方案五是`iframe`与父级不同源的加`#/api`接口，`iframe`加载时获取`hash`值来判断接口名字并发起`ajax`请求。适用于简单数据。
- `JSONP`它是一种常用的解决跨域请求的方式，刻意的跨域请求方式方便于服务器的数据分离管理，适用于大型项目。`JSON with Padding`：跨域获取 `JSON` 数据的一种非官方的使用模式。



## 第二周

| **日期** |    **早**    |     **午**     |      **晚**      | **复习内容**  | **完成度** |
| :------: | :----------: | :------------: | :--------------: | :-----------: | :--------: |
| 4月10日  | `jsonp`实战  | `<iframe>`实战 |  `<iframe>`实战  | 网络请求流程  |    90%     |
| 4月11日  |    `JSON`    |     `JSON`     |    `Date`对象    |   统一资源    |    90%     |
| 4月12日  |  `Date`对象  |    强制缓存    |     协商缓存     | `DNS`解析过程 |    80%     |
| 4月13日  | `setTimeout` | `setInterval`  |     严格模式     |   `TCP`过程   |    80%     |
| 4月14日  |  `ES6`历史   |   块级作用域   |    `let`声明     |   三次握手    |    80%     |
| 4月15日  |  暂行式死区  |  `const`声明   | `window`顶层对象 |   四次挥手    |    90%     |
| 4月16日  |     复习     |      复习      |       复习       |     复习      |    80%     |

**知识整理：**

- `JSON`是`JavaScript Object Notation` (`JavaScript`对象标记)，`JSON`是轻量级数据交互的格式，数据型的交换里面不包含方法。`JavaScript`对象的一种表达方式，是包含方法的。`JSON`是`JavaScript`对象的一个衍生，`JSON`选用映射的关系来形成一个轻量级的数据结构。
- 所有编程语言都离不开的三大数据类型是：
  - `scalar`标量(字符串和数字)
  - `sequence`序列(数组和列表)
  - `mapping`映射(键值对)，如函数参数的映射关系，将两个不同的东西映射在一起，如键值对，`hash`表。
- 早期使用`XML`进行前后端的数据交互，优点是可以自定义标签，关于`XML`的缺点：
  - 数据文档很大
  - 不易读
  - 解析难度比较大
- `JSON.parse()`将JSON字符串转换成`JSON`对象。`JSON.stringify()`将`JSON`数据转为字符串。前后端交互的数据只能是字符串。
- 严格模式是`JavaScript`整个脚本语言在设计之初只用了7天，运行非常快也非常简单，导致开发者刚入门时很容易，但到了后期就会发现这门语言其实并不够严谨和不太安全，此时出现一种更为安全和保证代码运行的模式，使其阅读起来更为规范。
- 严格模式的目的是减少语法层面的不合理，不严谨，不安全，怪异行为。`ES5`开始有严格模式和非严格模式，`IE9 `及以下不支持严格模式。

- 在严格模式下的区别有：
  - 变量层面
    - 全局变量声明时必须用`var`，否则使用严格模式时变量为`undefined`
    - 保留字和关键字不允许使用，如`var eval`
    - 全局变量的`delete`操作符失效问题(静默失败)，通过报错方式解决
  - 对象层面
    - 对象属性描述符造成的操作失败的问题(静默失败)，报错
    - `for...in`循环不会报错
  - 函数层面
    - 函数参数需要唯一的
    - 形参实参就没有相互映射关系
    - `caller`和`callee`会报错
    - `arguments.callee`指的是调用函数本身
    - `函数名称.caller`是函数属性，它指向当前调用函数的作用域
    - `eval`和`with`语句报错
- 日期对象`Date`实例呈现时间中的某个时刻。`Date`日期对象也是一个构造函数。
- `Date`实例化后的`toString()`方法返回也是一串时间。该`toString()`方法是继承`Object`原型。
- `getDate()`方法返回当前一个月的第几天，如`1-31`，返回几号。
- `getDay()`方法返回当前是周的第几天，如`0-6`，`0`代表周日。
- `getMonth()`方法返回当前为第几个月，`0-11`，`0`代表一月。
- `getYear()`方法已经废弃，替换的方法是`getFullYear()`，返回当前年份。
- `getHours()`方法返回当前小时。`0-23`。
- `getMinutes()`方法返回当前分钟数，`0-59`。
- `getSeconds()`方法返回当前秒数，`0-59`。
- `toJSON()`方法返回一个时间格式为`ISO`日期字符串的`JSON`字符串，等同`JSON.stringify()`返回的时间格式，同样也等同`toISOString()`返回的时间格式。
- `setTime()`方法可以设置指定时间戳为当前时间。它的类似操作像实例化`Date`对象时传入指定时间获取的时间是一致的。
- 时间秒数后`0-1000`的值为`1`秒。`getMilliseconds()`方法获取毫秒数。
- `getTime()`方法返回当前格林威治时间数值也叫时间戳。从计算机纪元时间`1970-1-1`的`0`分`0`秒开始记起，截止当前时间过了多少毫秒数。利用两个精确时间戳的时间差可以做很多事情，如倒计时，对比算法等。
- `Date.now()`方法返回当前格林威治时间数值。
- `Date.parse()`方法返回解析一个表示某个日期的字符串。
- **强制缓存**是在浏览器加载资源的时候，先检查缓存时间是否过期，若未过期则直接从缓存中查找请求结果，如果缓存时间过期或不存在该缓存结果，则向服务端发起请求。设置缓存时间的方法有两种（响应头字段）：`Expires`（`HTTP/1.0`）或 `Cache-Control`（`HTTP/1.1`)。
- 强制缓存除了首页`index.html`以外的静态文件如`css`，`js`文件，在服务器中设置缓存的两个方法(`res.setHeader('Expires', expiresTimes)`，`res.setHeader('Cache-Control', 'max-age=10');`)都需要同时设置来兼容老版本。
- **协商缓存**解决首屏`index.html`无法缓存的问题，也叫对比缓存，不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 `HTTP` 状态为 `304`，则表示缓存仍然有效；否则返回状态码 `200` 、最新的资源和最新的资源标识。协商缓存对首屏文件如`index.html`在服务器中进行设置缓存方法(`res.setHeader('Last-Modified', lastModified);`)。
- 服务器中获取请求头信息里的上次修改时间 `if-modified-since`属性的值来和当前读取文件时的上次修改时间`statObj.mtime.toGMTString()`来进行对比，如果时间没有变化则缓存。
- 协商缓存根据前后修改时间判断会存在缺点，文件内容没有修改但是修改时间变化了，它也会去重新读取文件。而且在1秒内的多次更改内容，是无法检测到的，存在精度问题。为了解决这些问题，协商缓存可以根据是否修改了文件内容而进行对比。只有在文件内容被修改的情况下才进行文件读取操作。利用了`MD5`摘要算法，该算法的特点是无法进行还原，不可逆的，根据内容不同导致结果不同，不管内容长度最终结果的长度都会一样的，只要内容更改一点，导致的结果会发生巨大的差异。
- 服务器中通过设置响应头的`Etag`标志属性的值为当前的`hash`值(`res.setHeader('Etag', contentHash);`)。
- 获取请求头信息里的上次修改内容的`hash`值，即服务器响应头定义的`Etag`属性的值(`let ifNoneMatch = req.headers['if-none-match'];`)。对文件内容摘要哈希进行比对。如果内容没有变化则缓存。
- `let`本质是为了`JS`增加一个块级作用域。`ES6`新增的`let`语法是声明变量生成单独块级作用域。函数作用域是无法正常访问的一个隐式的对象，在函数执行前一刻产生的对象。 `[[scope]]` 存储在预编译时期产生的 `GO`全局执行期上下文，和`AO`函数执行期上下文。在预编译过程中有`var`关键字声明提升的过程，会存在同一环境下的二次覆盖的变量污染问题，在`ES5`解决办法是通过立即执行函数来封闭函数作用域的方式来避免变量污染，但是函数内部仍然存在变量污染的问题，因此会采用一个`kiss`原则(`keep it simple and stupid`)来保证函数功能的单一性，函数提纯等一系列方法来解决变量污染问题。
- 块级作用域不等于匿名函数的立即调用，使用立即执行函数可以模拟块级作用域，但立即执行函数是有返回值的，而块级作用域内部是没有返回值给外部访问的。
- **`let`具有以下特点：**
  - `let`不允许在同一作用域下重复声明
  - `let`不会声明提升，会产生一个暂时性死区(`Temporal Dead Zone`)
  - `let`只能再当前的块级作用域下生效
- `const`定义常量，不可变的量，不期望变量被更改。在模块引入时，不希望模块被更改，只是使用模块里的属性和方法。
- **`const`特点：**
  - 定义的常量必要要赋值
  - 一旦定义必须赋值，值不能被更改
  - 有块级作用域，存在暂时性死区
  - 常量不能重复声明



## 第三周

| **日期** |    **早**    |    **午**    |  **晚**  |   **复习内容**    | **完成度** |
| :------: | :----------: | :----------: | :------: | :---------------: | :--------: |
| 4月17日  |   解构赋值   |  函数默认值  | 解构本质 |     同源策略      |    90%     |
| 4月18日  |    函数名    |   对象拓展   |  描述符  |    `<iframe>`     |    90%     |
| 4月19日  |   `getter`   |   `setter`   | 冻结密封 |   `window.name`   |    90%     |
| 4月20日  |   对象合并   | `setter`拷贝 | `super`  | `document.domain` |    80%     |
| 4月21日  |   对象遍历   |   原型操作   | `Symbol` |  `location.hash`  |    80%     |
| 4月22日  | `Symbol`遍历 |  `iterator`  | `ForOf`  |      `jsonp`      |    80%     |
| 4月23日  |     复习     |     复习     |   复习   |       复习        |    70%     |

**知识整理：**

- 在函数中参数的默认值定义。专业术语：`falsy `假的值(虚值) 通过`boolean`转化为`false`的值。
- 形参默认值会影响函数内声明造成重复声明报错。
- 惰性求值，当函数的参数为表达式的时候，每一次都需要计算表达式的值。
- 解构赋值依然是一个赋值的过程。 模式匹配前提需要模式一样才能匹配结构进行解构。变量的解构本质是变量的赋值，它需要模式匹配的方式进行赋值。
- 对象的解构是不存在顺序的。
- `ES5 `传统函数遵循 `this`指向具有的`4`个规律，优先级是 `new `，然后显式绑定规则，再到隐式绑定规则，再到默认绑定规则。
  - 默认绑定规则下指向全局对象`window`
  - 隐式绑定规则，谁调用指向谁
  - 显示绑定规则，如`bind`，`call`，`apply`
  - `new`关键字去实例化
- 箭头函数的**实质**，它不属于以上`4`种规则并忽略任何形式`this`指向的改变，根据外层函数作用域来决定指向，不能作为构造函数来使用，没有`arguments`对象，用`rest`(拓展运算符替代)，在`generator `函数中`yield `命令在胖箭头中不能生效。
- 适合箭头表达式的情况：
  - 仅仅是一个简单的函数表达式语句，得出唯一`return`的计算值，并且函数内部没有`this`引用的时候。
  - 没有递归操作时，没有事件处理函数绑定或者解绑时，适用重构箭头函数取代`this`指向`bind`改变的方式。
  - 如果内层的函数表达式需要调用`this`，用`var _self = this;`即`bind(this)`确保适当的`this`指向时。
  - 在函数内部通过参数列表转数组`[].slice.call(arguments)`并使用数组方法进行操作时用箭头函数比较好。
- 不适合箭头表达式的情况：
  - 函数声明，执行语句比较多的
  - 还需要用到递归
  - 还需要引用函数名
  - 需要事件绑定，解绑定
- 展开(`spread`)运算符，或者是收集(`rest`)运算符。
- 在`ES6`中，使用了`Object.defineProperty()`方法并定义了`configurable: false`，`writable: false`描述符可以给该对象里的属性进行不可重写，不可删除。
- 但是仍然可以给该对象进行属性新增，如果想要封闭该对象，并无法进行对象拓展，可以使用`Object.preventExtensions()`方法对对象进行拓展处理，返回值是当前被禁止拓展的对象。
- `Object.isExtensible()`方法可以判断当前的对象是否可以拓展。
- `Object.seal()`方法可以对对象**浅层**属性进行密封从而使得对象无法拓展。
- `Object.seal()`方法可以对属性进行新增和删除的限制，却无法对其进行修改限制。
- `Object.isSealed()`方法可以判断当前的对象是否被密封。
- `Object.freeze()`方法可以对对象**浅层**属性进行冻结，即无法对属性进行修改，删除，新增操作。而且一旦冻结无法以任何形式去改变。
- `Object.isFrozen()`方法可以判断当前的对象是否被冻结。
- `Object.is()`方法可以比较两个值是否相等，是否是同一个引用值。它与`===`表达式写法的结果一致。
- `Object.assign()`方法可以将多个对象合并一个对象。相当于对一个对象进行拷贝操作。合并后的对象与目标对象(参数1)的引用是一致的。它与`Vue2`的`Vue.extend()`方法类似。在`ES6`之前想对多个对象进行合并的实现。对多个可枚举属性进行遍历并重新组合为一个新的对象。
- 当`Object.assign()`方法的参数2为`Symbol()`创建的引用值属性的对象时，说明`Symbol()`创建的属性(实际上是一个唯一的字符串)的对象也可以被合并。
- 通过`Object.getOwnPropertyDescriptors()`方法可以获取源对象的所有描述符，再通过`Object.defineProperties()`定义对象的属性为获取的描述符，解决新对象拿到的是属性为函数体本身的对象，完成一个特殊的对象拷贝，原因是`Object.assign()`方法并不能完美对一个`setter`函数本身进行拷贝。
- `ES6` 的 `class` 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 `ES5` 是一致的。与`super`对应的是`this`指向，`this`的初衷是当前函数的对象(指向调用者对象本身)。`super`关键字指向是对象的父类即原型对象。
- 除了对象简写的写法才不会报错，说明`super`关键字使用上是有限制的，只能是**对象下简写方法**(属性不行)内部才可以使用生效。
- `Object.create()`方法可以创建一个原型对象。`Object.setPrototypeOf()`方法可以对对象的原型进行修改操作。避免了实例对象调用`__proto__`并直接赋值对象的方式进行原型修改。参数1为当前对象，参数2为指定原型对象。
- 当`Object.setPrototypeOf()`方法的参数1为原始值时，返回的对象的原型是一个包装类对象，指定对象的对象原型则失效。`Object.getPrototypeOf()`方法可以对对象原型进行读取操作。
- `ES6`引入`Symbol`的原因是`ES5`对象属性经常出现重名的情况，解决对象属性名重名的问题。`Symbol`不是构造函数，尝试`new Symbol()`会报错。`Symbol()`返回的唯一的值，属于原始值类型的值。
- `Symbol()`可以将引用值对象转为`symbol`原始值字符串的过程。说明对象自己调用了`Object.prototype.toString()`方法将自己变成字符串，也说明`symbol`的值永远是字符串。
- `Symbol()`的用法一般是返回的`symbol`值作为独一无二的属性键名来使用。使用`.`语法来定义对象的属性名并不是一个唯一的属性名称，应该使用`[变量]`语法来定义对象的属性名称。当想访问该对象下的属性时也需要使用`[变量]`的方式进行获取。因为`.`语法操作符是隐性`toString`转换字符串导致无法正常获取属性名。
- `Symbol.for()`方法可以拿到不是唯一的值，底层(运行时的`symbol`注册表中找到对应的`symbol`)通过`key`值拿到指定的`symbol`值。`Symbol.keyFor()`方法可以在全局中拿到当前的`key`值。`for in`不能遍历`symbol`属性的对象。`for of`不能遍历`symbol`属性的数组，对象不是可迭代对象也无法进行遍历，此问题可以通过以下`iterator`对象接口封装来解决无法遍历。
- 利用对象合并`Object.assign()`方法对对象里的`symbol`属性进行拷贝，拷贝时会遍历对象下的所有属性，结果是可以进行合并的，但无法获取遍历后的键名`symbol`属性数组集合。
- `Object.getOwnPropertySymbols()`方法是新的`API`专门遍历`symbol`类型的值，也是唯一的遍历`symbol`值的方法。`Object.getOwnPropertySymbols()`方法会遍历自身的`Symbol`类型的值，即使定义了`enumerable: false`不可枚举属性也可以拿到键名数组集合。`Object.getOwnPropertySymbols()`方法仅仅会遍历自身的`Symbol`类型的值，定义在原型上的`Symbol`类型的值无法进行遍历。
- `Symbol.hasInstance()`是`Symbol`构造器上的静态方法，用来判断某个对象实例是否是某构造器实例出来的。当其他对象调用`instanceof`时会调用`Symbol.hasInstance()`方法。开发底层库或者框架时会用到该方法，判断用户行为是否有使用了`instanceof`关键字从而隐式的去执行这个`Symbol.hasInstance()`方法。
- `Symbol.isConcatSpreadable()`方法用来判断当前对象使用`concat()`方法在拼接的时候查看数组能否被展开。在数组`[].concat()`执行调用时同时执行`Symbol.isConcatSpreadable()`方法。
- `Symbol.replace()`方法用来判断字符串方法`String.prototype.replace()`执行时同时执行`Symbol.replace()`方法。
- `Symbol.match()`方法匹配了正则表达式在字符串方法`String.prototype.match()`执行时同时执行`Symbol.match()`方法。
- `Symbol.iterator()`方法为每一个对象都定义了默认的迭代器。可以被`for..of`遍历。例如数组的原型上有一个`Symbol`迭代器接口。访问迭代器接口的方法执行会返回一个迭代器对象，该迭代器对象原型上有个`next()`方法。返回一个具有`value`和`done`属性的对象。这仅仅是第一次执行`next()`方法返回的结果。
- 在 `JavaScript `中，迭代器是一个对象，它定义一个序列，并在终止时可能返回一个返回值。更具体地说，迭代器是通过使用 `next()` 方法返回具有两个属性的对象。
- 迭代器迭代过程是一部分数据被抽取的过程，抽取当前有序且连续的数据结构，迭代器接口是对数据结构读取的一种方式，抽取过的数据就不会被抽取了，相当于数据已经被消耗掉了，说明该数据就无法被访问了。迭代器的意义是让所有的数据类型都用一种统一的方法进行迭代。
- `ES6`部署迭代器的方式通过一个隐式的标准化接口`Symbol.iterator`进行访问接口，每次调用当前的`next()`方法，返回一个当前成员信息的`iterator`对象，包含了`value`和`done`两个属性。
- 迭代器获取数据的方式有点过于麻烦，`ES6`借鉴了`C++`，`JAVA`，`C#`，`Python`语言中的`for...of`循环，也属于迭代的过程，为遍历可迭代数据结构提供一个统一简单的遍历语法接口，它实际上也同样调用了`Symbol.iterator`接口进行访问。

## 第四周

| **日期** |     **早**      |   **午**    |    **晚**     |  **复习内容**  | **完成度** |
| :------: | :-------------: | :---------: | :-----------: | :------------: | :--------: |
| 4月24日  |   `typeArray`   |  正则方法   |    修饰符     |    `cookie`    |    80%     |
| 4月25日  | `unicode`表示法 | 字符串方法  |  模版字符串   |      表单      |    80%     |
| 4月26日  |      `map`      |    `set`    |   `weakmap`   |    文件上传    |    90%     |
| 4月27日  |    `weakset`    |   `proxy`   |   `reflect`   |    网络请求    |    90%     |
| 4月28日  |     `class`     | `class`继承 | `promise`开端 | 服务器简单搭建 |    90%     |
| 4月29日  |  `promise`使用  | `promisify` |  `iterator`   |      路由      |    80%     |
| 4月30日  |      复习       |    复习     |     复习      |      复习      |     0%     |

**知识整理：**

- 在`ES6`中新增了一些特性，如声明正则的变化方式，如将字符串上的正则方法进行了调整，将原本方法放入正则表达式原型上，如新增修饰符`u`，`y`，`s`等。
- `ES6`将字符串上的正则方法进行了调整，将原本方法放入正则表达式原型上。
- `reg.global`是正则实例对象里的属性，判断是否有定义全局匹配修饰符。
- `reg.ignoreCase`是正则实例对象里的属性，判断是否有定义忽略大小写修饰符。
- `reg.multiline`是正则实例对象里的属性，判断是否有定义忽略换行修饰符。
- `reg.sticky`是正则实例对象里的属性，判断是否有定义搜索是否具有粘性的修饰符。
- `reg.source`是正则实例对象里的属性，返回当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。
- `reg.flags`是正则实例对象里的属性，返回一个字符串，由当前正则表达式对象的标志组成，即定义的修饰符。
- `y`修饰符区别于`g`修饰符，它本身也是一种全局匹配。`g`对剩余位置的字符都可以匹配，`y`不会对剩余位置的字符匹配。
- `unicode` 是正则表达式独立实例的只读属性。使用`u`修饰符，任何 `unicode` 代码点的转义都会被解释。`unicode`分为若干个(`17`个)区域，每个区域存放`2*16`次方个字符。如`\uD842`可以表示一个字符。
- `dotAll`，点全部。点不能覆盖的还有`\n`，`\r`，`U2028`，`U2029`。
- `String.prototype.codePointAt()`方法返回 一个`Unicode`编码点值的非负整数，参数是字符串索引。
- `String.fromCodePoint()`方法与`ES5`中的`String.fromCharCode()`方法类似，传入`unicode`码点返回一个对应的字符。
- `String.prototype.includes()`方法在另一个字符串中找到一个字符串，并根据情况返回 `true` 或 `false`。
- `String.prototype.startsWith()`方法判断当前字符串是否是以另外一个给定的子字符串“开始”的，根据判断结果返回 `true` 或 `false`。
- `String.prototype.endsWith()`方法判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 `true` 或 `false`。
- `String.prototype.repeat()`方法返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。
- `String.prototype.padStart()`方法，用另一个字符串填充当前字符串。在日期补齐，时间补齐。
- `String.prototype.padEnd()`方法，用另一个字符串填充当前字符串。
- 一个变量的值可以有基本类型的值，如`number`，`string`，`undefined`，`null`，`boolean`，`NaN`，`Symbol`，开发层面上基本类型的值是不可变的。在计算机层面，一个值不可变化的原因是从内存的角度上去理解的。修改内存比开辟新的内存空间的消耗更大。一个变量的值也可以有引用类型值，如`Object`，`Array`，`Function`，`Map`，`Set`。它们像是一个容器，目的是让容器内部装入更多的值，容器内部装载的值是可以变化的。
- `Set`是`ES6`新增的一种数据类型，它是一个构造函数。类似于数组的数据结构，但它的成员是唯一的。具有迭代器接口。
- 尝试通过`add()`方法新增对象成员。该方法返回当前`set`实例，说明可以链式调用`add()`方法去新增成员。
- 尝试通过`delete()`方法删除当前`set`数据的某个成员数据，该方d当删除某个成员数据成功时返回布尔值`true`，当删除一个不存在的成员时返回布尔值`false`。
- 尝试通过`clear()`方法清空当前`set`数据的所有成员数据，该方法返回值为`undefined`。
- `has()`方法可以判断当前`set`实例数据中是否有某个成员数据。
- 尝试使用`entries()`方法来给`set`实例数据进行遍历，它的返回值是一个迭代器对象。通过`for..of`遍历可以获取键值组成的数组，由于没有键名只有键值，所以键值组成的数组的两个数组元素是一样的。
- 使用`keys()`方法来给`set`实例数据进行遍历，它的返回值是一个迭代器对象。由于`set`数据没有键名，只有键值，所以返回键值的集合。
- 由于`set`实例数据本身具有迭代器接口`Symbol.iterator`，可以直接通过`for..of`进行遍历。实际上，`set`原型上迭代器接口方法与`values()`方法和`keys()`是同一个方法引用。
- `Map`是一个复杂的`Object`，具有有序性，键名可以是任意的值，键名是唯一不重复的。
- 在面向对象开发时，大量对数据操作的类，类与类之间实例化后的对象可以通过`Map`数据进行关联存放，方便查找对象里的属性和方法，减少代码量，实际应用场景是`vue`中对依赖监听时对某个依赖数据和修改数据的方法进行关联，也可以做自定义指令时，`dom`节点与相应逻辑方法关联。
- `Map`是`ES6`新增的一种数据类型，它是一个构造函数。类似对象的存在，键值是完全一一对应的，键名不限于是字符串数据。具有迭代器接口。
- 当尝试给一个对象的属性名赋值为一个对象时，会调用`toString()`方法将属性名进行字符串转换，返回`[object Object]`作为属性名。当再次给一个对象的属性名赋值一个对象时，同样调用`toString()`方法返回同样的属性名，此时会存在属性名一样而属性值覆盖的问题。
- 可以通过`set()`方法给一个`map`实例数据进行定义多个键名键值。
- 当给`map`实例数据定义一个`-0`原始值作为键名时，通过`+0`也可以获取值。键名和键值都成了一一对应的关系。
- `map`数据或`set`数据在对对象进行增删查操作，比数组进行增删查操作的写法更为简单，更为优雅。涉及到数据结构的考量上，能尽量使用`map`数据就尽量少用数组。假如对数据结构的唯一性有要求时就使用`set`数据。
- `WeakMap`和`WeakSet`它的键名始终是引用值，是一个弱引用值。当垃圾回收机制计数不对其进行引用值进行计数时，这种引用模式叫弱引用。
- `WeakMap`和`WeakSet`与`Map`和`Set`基本是一致的，唯一不一样的地方像是一个阉割的版本，不存在遍历的方法。他们都属于弱引用，回收机制中不会考虑`WeakMap`和`WeakSet`的引用，如果没有被其他对象进行引用`WeakMap`或`WeakSet`时，会自动回收当前对象所占用的内存。
- 低级编程语言中像`C`需要手动分配内存，而高级编译语言像`JavaScript`可以自动分配内存。对数据进行读写就是使用内存的过程，低级语言需要手动释放内存，高级语言则通过垃圾回收机制进行释放内存。
- 垃圾回收机制回收的时机是无法预测的，并且引用对强引用的解除是与`WeakMap`或`WeakSet`没有任何关系的情况下，它里面的成员是不稳定的，`size`属性也会不准确的，造成一系列遍历方法会不准确的。
- 利用`WeakMap`数据，在对象进行深度克隆时，对里面的引用进行记录，假如已经递归过一次的引用进行保存，达到解决避免多次递归的问题的目的。
- `Proxy`是设计模式之中其中的代理模式，`ES6`新增，它是代理模式的一种实现。在目标之间设置拦截层，在外界想要访问这个对象的时候，就必须通过该拦截。
- 基本的拦截方式是`getter`，`setter`，对应了读取和赋值操作，`has()`方法拦截的是对象中`in`操作符，判断属性是否在当前的对象里，存在特殊情况是在`for`循环内部无法进行`in`操作符的拦截操作。
- `Reflect`是一个对象, 是`JavaScript`内置对象方法集合的容器。`Reflect`的出现解决了`ES5`对对象原型方法和其余方法的一些混淆，造成对象原型庞大以及定义的模糊不清。
- `Class`它是`ES6`新增的关键字，它是一个类，在纯面向对象的语言中存在的类，`JavaScript`是模拟了类的一个方式，本质上是一个语法糖，语法糖是一个新的语法，仅仅把原来的写法换了另外的一种方式，本身是一个函数，通过`Class`关键字进行重新封装，除了写法上没有什么改变，提高可读性和维护性，减少代码出错率。
- `Class`具有以下特点：
  - 函数可以声明提升，但是`Class`声明无法提升，与`let`相同，具有暂时性死区。
  - 在`Class`类内部定义的公共属性和方法是无法被枚举的。
  - 类里默认是严格模式。
  - 类内部有一个默认的`constructor`方法，没有定义时也不会报错。
  - 类方法只能通过`new`关键字来执行。
- `ES6`之前的继承方式需要修改原型链，`extends`关键字可以简化的实现继承关系。子类也叫派生类，通过`extends`关键字派生出来。
