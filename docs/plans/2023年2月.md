## 第一周

| **日期** |            **早**            |            **午**             |            **晚**             | **复习内容** | **完成度** |
| :------: | :--------------------------: | :---------------------------: | :---------------------------: | :----------: | :--------: |
|  2月6日  |        列表渲染v-for         |           数据劫持1           |           数据劫持2           |   样式操作   |    90%     |
|  2月7日  |          数据劫持3           | v-if与v-for的联合使用风格指南 | Vue的就地更新与v-for的key属性 |   事件概述   |    80%     |
|  2月8日  |  v-for之架子搭建、数据劫持   |        v-for之模板编译        |      事件处理函数的绑定       |   绑定方式   |    80%     |
|  2月9日  |           TodoList           |           TodoList            |           TodoList            |   事件冒泡   |    90%     |
| 2月10日  | DOM4标准的事件监听与滚屏优化 |       事件与按键修饰符        |    表单输入的数据双向绑定     |   事件捕获   |    90%     |
| 2月11日  |           模板编译           |           模板编译            |           模板编译            |  事件源对象  |    90%     |
| 2月12日  |             复习             |             复习              |             复习              |     复习     |    60%     |



**知识整理：**

- `vue2.x` 中 `Options API` 中的`data`函数返回一个对象实现了数据的响应式处理。
- 数据劫持的目的是不希望对原生对象和数组的操作是一个纯操作，而是赋值或操作数组的过程时仍可以新增新的业务逻辑进去，像绑定视图数据，希望数据变化的过程中，视图也跟随着变化，那么就必须拦截 `getter/setter` 行为，在拦截的过程中，保留原来数据的操作的同时可以更改视图。
- 通过`Object.defineProperty`方法来实现代理，如果用户想要访问`data`下的属性，需要`vm.$options.data.title`/`vm.$options.data().title`而不是`vm.title`访问，不便于开发编写。
- 通过观察者模式不仅对`data`进行观察，对内部的属性也要观察，如果内部的属性是对象就要做相关的拦截，如果是数组要对数组方法的拦截。
- `Observer`构造函数内部的数据观察实现是通过`Object.keys()`遍历拿到`data`里所有的`key`和`value`，并将其通过`defineProperty`做下一步的响应式数据处理。
- 不能对数组进行`defineProperty`的原因是因为数组本身`defineProperty`是不处理数组的，当然可以用一些方法去处理，但是比较麻烦，目的仅仅是为了拦截数组，那么就对数组中的方法进行重写。
- 在 `vue2 `里需要重写数组里的原生方法是需要保留原有的数组方法操作数据，并希望在`push/unshift/splice`新增数组元素时新增更多业务逻辑。因为有些数组的数据变更并不能被 `vue` 检测到，操作数组的一些动作，如通过索引值修改值，或者修改长度，或者是调用一些`Array.prototype`上的方法并不能触发这个属性的`setter`, `splice`方法也可以触发状态更新，在 `vue2.x` 版本将数组的 7 个方法`push,pop,shift,unshift,splice,sort,reverse`重写,调用包装后的数组方法就可以被 `vue `检测到。
- `v-for`遍历，列表渲染。如果`v-for`与`v-if`用于同一个元素节点，`v-if`的优先级高于`v-for`（vue3），有可能会冲突，`v-if`无法获取`v-for`遍历的列表，报错提示为在渲染期间，列表属性被访问了，但是没有被定义在实例上。
- key`使用，`key`属性是唯一的值。方便`vue`就地更新策略的实施。
- 事件处理函数的绑定，实际上是原生 `JavaScript `里绑定事件处理函数，用户行为触发，事件和处理函数进行绑定行为，事件的触发会执行其绑定的处理函数。
- 事件修饰符`@click.once`，目的在与把事件处理函数中非纯逻辑的程序分离出去，如定义的事件处理方法里把`e.preventDefault()`等非逻辑的方法分离出去，保证定义的方法是仅仅是逻辑的方法。希望视图和逻辑完全的分离。
- `.once`只调用一次事件处理，调用一次以后自动移除监听器
- `.prevent`阻止默认事件
- `.capture`采用捕获
- `.stop`阻止事件冒泡
- `.passive`拥有不调用`Event.preventDefault()`，即与`.prevent`不能一起用
- `v-model.lazy`在`input+value`输入完成失去焦点时，表单数据才改变。
- `v-model.number`如果无法被 `parseFloat `解析，就返回原始值/在有 `number `时，就返回数值。
- `v-model.trim`过滤掉首尾的空白字符
- 在DOM4标准里，事件处理函数中`addEventListener(eventType, handler, capture)`。参数3`capture`对象中可以定义多个属性。
- 定义的`passive`属性具有优化的滚屏的作用。默认情况下,`passive`为`false`。当将`passive`定义为`true`并且执行`e.preventDefault()`来阻止默认行为时，会报错`Unable to preventDefault inside passive event listener invocation`，在定义`passive`为`true`时，永远不能调用阻止默认行为的方法。
- 在手机页面触摸屏幕时，浏览器默认设置`passive`为`true`。`touchstart`事件的默认行为是滚动。假如强制将`passive`设置为`false`会导致移动设备滚动页面时无法触发默认行为。
- 当`touchstart`事件触发时，执行顺序是处理器程序首先执行(大量的逻辑)，然后到默认行为的执行(如滚动)，此时会出现较大的问题是造成大量的性能浪费(等待时间过长导致卡顿)，因为导致移动设备在滚动页面时无法正常滚动，假如将`passive`属性设置为`true`，保证阻止默认行为的方法不会调用执行，开启两个线程去处理滚动问题，线程1保证处理器程序的执行，线程2执行默认行为，没有了等待的时间，使性能提升从而提高滚动屏幕的性能。
- 将从`template`模板转化为`AST`树的**目的**是因为模板里有可能有`v-for`，或一些`v-*`指令等写法(虚拟`DOM`中不能有)，并将Vue语法糖的属性将其解析成为对应的功能。从而让浏览器识别简化后的`dom`树。
- 模板编译过程：
  1. 拿到 `template`模板。
  2. 将 `template`转换到 `AST`树(正则匹配模板内容重组`AST`树)。
  3. `AST `形成了以后转化为 `render `函数(一系列的字符串方法解析)。
  4. 通过`render `函数写完后转换为虚拟 `DOM `节点。
  5. 设置 `PATCH `补丁，对比新旧节点打补丁。
  6. 形成真实 `DOM`。

## 第二周

| **日期** |        **早**        |            **午**            |         **晚**          | **复习内容** | **完成度** |
| :------: | :------------------: | :--------------------------: | :---------------------: | :----------: | :--------: |
| 2月13日  |    组件化设计注册    |          单文件组件          |       深入组件化        |   取消冒泡   |    80%     |
| 2月14日  |      深入组件化      | 手写tpl-loader分离出模板文件 |   Web components标准    | 取消默认事件 |    80%     |
| 2月15日  | Provide与Inject应用  |     Provide与Inject应用      | import的静态与动态导入  |    事件流    |    90%     |
| 2月16日  | keep-alive、动态组件 |           异步组件           |      深入应用动态       |   事件代理   |    80%     |
| 2月17日  |  异步与suspense组件  |  实现keep-alive虚拟节点缓存  | HTML元素上指定ref的应用 |   鼠标坐标   |    90%     |
| 2月18日  | 组件上指定ref的应用  |      基本认知与类型定义      |   深入props的验证方法   |     拖拽     |    80%     |
| 2月19日  |         复习         |             复习             |          复习           |     复习     |     0%     |



**知识整理：**

- `Vue/React `模板系统是参考 `Web components` 规范来进行上层的设计，通过插槽/模板可以自定义组件，自定义标签，自定义属性，然后再进行渲染。
- `HTML/DOM` 已经规范了 `Web components`，经过特殊的编译，最终形成浏览器能够支持解析并渲染的一系列的代码，它本身是有一套支持浏览器(不需工程化)的组件化系统/规范。
- 提供给开发者能自定义可重用的，可被浏览器正常解析的标签，让逻辑样式标签被封装在一个组件中，最终用自定义标签渲染视图。
- 标签提供了`template`模版, `slot`插槽。
- 容器是`shadowDOM`，一个隐藏的`DOM`，节点并不会渲染到视图上。
- 方法是`customElements.define`自定义元素标签的方法。
- `Vue `组件化核心是组件化系统，利用 `ES `模块化来完成 `vue `组件系统的构建。导入，导出一个组件就是一个模块，将所有整个页面上的各个单元抽离成各个小的单元，通过模块化组合在一起，最终用 `viewmodel `组装成一个真实的 `DOM `树。
- 组件化是抽象了一个小型，独立，可预先定义配置的，可复用的组件。
- 组件最大的作用是独立开发，预先配置，为了更好的维护和拓展。
- 小型化：页面的构成拆分成一个一个的小单元。
- 独立性：独立开发，每一个小单元尽可能独立。
- 预定性：预先定义，每一个小单元都可以先定义好再需要的时候导入使用。
- 配置化：预先配置，小单元可以接收一些在使用的时候需要的一些配置。
- 可复用：小单元在多个地方可以使用。
- 在组件树中，组件之间存在依赖关系，但有数据传递的时候需要父子组件注册。单向数据流的关系导致组件传递数据会存在强制注册属性。还有许多中间组件只有注册的数据，但并未使用数据。
- `Provide Inject` 就是解决以上问题，在提供数据的父组件通过 `Provide `把数据提供出来，然后组件下面的所有的子组件不管层级多深，数据都可以直接穿透(注入)任何的组件关系，让子组件能够直接的使用数据。
- 缺点是父组件 `provide `数据，子组件无论哪个层级的组件它用 `Inject `注入，但是数据绑定的时候并不是响应式的(默认情况)。父组件是不知道哪个组件使用了 `Provide `的数据。子组件也不知道哪个组件提供了数据，无法查询数据来源。
- 使用场景是在一个组件体系下，如果有深度嵌套的时候。在一个组件体系下，多层级多个组件使用的时候。
- 动态组件在交互中，组件的渲染是不确定的，根据交互的操作来决定渲染哪个组件。组件切换时，缓存组件和保存组件的状态，避免反复渲染导致性能问题。
- 没有必要在当前进行加载的组件称为异步组件，好处是不会打包在项目里，是按需从服务器上下载并加载。
- `suspense`组件是一个试验性组件，在正确渲染组件之前进行一些异步请求是很常见的事。组件通常会在本地处理这种逻辑，绝大多数情况下这是非常完美的做法。该 `<suspense>` 组件提供了另一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。
- `keep-alive`会缓存当前组件现有的虚拟节点，它不会经过卸载的过程。`keep-alive`缓存的是组件的实例，该实例对象里有保存虚拟节点。当组件`keep-alive`切换时，生命周期`mounted`和`unmounted`将不会调用，取而代之的是`activated`和`deactivated`。
- 单向数据流是一种组件化中数据流向的规范，从父组件流动向子组件，遵循子组件不可改变父组件流入的数据。





## 第三周

| **日期** |             **早**             |          **午**           |          **晚**          | **复习内容** | **完成度** |
| :------: | :----------------------------: | :-----------------------: | :----------------------: | :----------: | :--------: |
| 2月20日  |      attributes传递与继承      |        自定义事件         |        自定义事件        |  输入框事件  |    80%     |
| 2月21日  | 自定义指令概念、生命周期与参数 | 实现自定义指令v-show/v-if |     tab切换指令实现      |   滑入滑出   |    80%     |
| 2月22日  |           v-lazy实现           | teleport的特点与应用场景  | 插件化开发与UI组件库实现 |   滚屏优化   |    80%     |
| 2月23日  |         插件+teleport          |        插件+extend        |     mixin特性和场景      |   键盘事件   |    90%     |
| 2月24日  |            编译过程            |         渲染函数          |          h函数           |   页面解析   |    90%     |
| 2月25日  |            Dom diff            |         Dom diff          |         应用配置         |    DOM树     |    70%     |
| 2月26日  |              复习              |           复习            |           复习           |     复习     |    40%     |



**知识整理：**

- 在父子组件通信中最常用的操作是自定义事件。在子组件中自定义一个方法。

- `vue3`中子组件需要注册自定义事件。为了更好记录组件的工作流程。

- 子组件自定义事件注册时不仅支持数组，还可以支持对象，可以增加验证器。

- 实现父子组件如表单嵌套组件的双向绑定，子组件可以绑定一个自定义事件。

- **自定义指令**，开发者也可以给 `Vue `拓展指令，`v-自定义名称`，它可以提供一个直接操作`dom`的接口，在`vue`中属于底层行为，它不希望操作`DOM`。

- 单`JS`文件定义自定义指令相关的生命周期的函数。

- 它包含参数`el`是被绑定指令的元素，是一个`DOM`对象，非常常用。

- `bindings`参数是一个对象。

  - 该对象里的`arg`属性是视图模板中定义的指令的参数，如`v-my-show:abc`中`arg`对应的值是`abc`。
  - 该对象里的`dir`属性的值是一个对象，对象里的属性对应的是在自定义指令`JS`文件定义过的所有属性，如生命周期的函数，如`beforeMount`，`mounted`，`created`，`updated`等等。
  - 该对象里的`instance`属性的值是当前使用指令的组件实例。在做自定义指令的时候可以获取组件里的数据去完成特殊的功能。
  - 该对象里的`modifiers`属性的值是视图模板上定义自定义指令的后缀时保存的该后缀名称，即指令的修饰符对象集合，如`v-my-show:abc.test`中的`test`属性。
  - 该对象里的`oldValue`属性的值是更新前指令绑定的值。
  - 该对象里的`value`属性的值是当前指令绑定的新值。

- `vnode`参数是当前组件的虚拟节点。

- `prevNode`参数是上一个更新之前的组件虚拟节点。

- `<teleport>`组件用于解决视图组件嵌套层级关系的问题。如根组件和模态框`Modal`组件本来应该是同级的关系。

- `mixin`它是`option API`时期的产物，如果组件有同样的`data`或`method`，则可以将`data`单独拿出来放到`mixin`再混入到组件里，使代码减少重复性。

- 混入，跟普通的组件区别并不大，相当于一个公共的组件，在组件化中引入到组件内部就可以访问组件里面的属性和方法和视图，其实是一个组件类高度复用的工具。

- 用于多个组件的时候，可能会多出很多不必要的选项或属性，很可能会无限拆分`mixin`，不好管理也不好取名字，有可能导致命名冲突，导出的`mixin`对象它不是函数，没办法动态传参调整`mixin`的`option`的混入情况，极大的干扰了`mixin`合理性复用。

- `vue3.x`更好的解决方案是`Composition API`，它所有复用性的集成性的功能全部封装成函数，在`vue3.x`中它可以使用内置提供的`Composition API`更灵活的使用。

- 实现模板编译的过程：

  - 拿到 `template`模板
  - 将 `template`转换到 `AST`树(正则匹配模板内容重组`AST`树)
  - `AST `形成了以后转化为 `render `函数(一系列的字符串方法解析)
  - 通过`render `函数写完后转换为虚拟 `DOM `节点
  - 设置 `PATCH `补丁，对比新旧节点打补丁
  - 形成真实 `DOM`

- 在绝大多数情况下，`Vue `推荐使用模板语法来创建应用。然而在某些使用场景下，我们真的需要用到 JavaScript 完全的编程能力。这时**渲染函数**就派上用场了。

- `render`函数目的是把虚拟`dom`转为真实`dom`的渲染行为，在`vue`组件中会提取模板`template`(字符串)去编译模板。

- 在浏览器中它无法识别`vue`的指令，此时需要优化，首先将模板转为`AST`语法树，再优化`AST`树，将浏览器不能识别的指令转为逻辑，将优化后的`AST`结构树转为虚拟`dom`，通过渲染函数转为真实`dom`。

- `h`函数也叫`createNodeDescription`创建节点描述，`h`函数创建返回的是`VNode`虚拟节点，多个虚拟节点就会组成虚拟`dom`树，对真实`dom`的描述。

- 比对(`diff`)渲染更新前后产生两个虚拟`dom`对象的差异，并产出差异补丁对象，再将差异补丁对象应用到真实`dom`节点上。深度优先，从外到内嵌套比对。

- 在浏览器中，操作`dom`需要耗费性能的，尽可能的减少操作`dom`可以保证性能。

  



## 第四周

| **日期** |      **早**       |         **午**         |       **晚**       | **复习内容** | **完成度** |
| :------: | :---------------: | :--------------------: | :----------------: | :----------: | :--------: |
| 2月27日  | 派发器思想的尝试  |    派发器思想的尝试    | 从选项API到组合API |   节点创建   |    80%     |
| 2月28日  | 深入学习setup函数 | 深入学习Vue的生命周期  | activated应用场景  |   节点增加   |    80%     |
|  3月1日  |  provide与inject  | 获取当前实例与全局属性 |  响应式原理与实现  |   节点删除   |    90%     |
|  3月2日  |   nextTick实现    |      响应式特征1       |    响应式特征2     |   节点文本   |    90%     |
|  3月3日  |   依赖收集实现    |    React hooks集成     |  响应式hooks封装   |   节点替换   |    90%     |
|  3月4日  |    侦听器认知     |       watch应用        |      计算属性      |   属性新增   |    80%     |
|  3月5日  |       复习        |          复习          |        复习        |     复习     |    70%     |



**知识整理：**

- `Dispatcher`派发器模式来改造组件的逻辑部分。
- `Vue`中根据需求去更改数据是`methods`操作数据 `data`，更多的不想逻辑写在`methods`里面，因为一个组件它的逻辑部分非常多的话，`methods`里面就不好维护了。优点是给更多同步开发的开发者实现方法管理。
- 让`methods`不再臃肿的设计是抽离相应的部分，通过`type`找到一个对应事件，找到事件对应的逻辑，逻辑通过事件类型`type`去触发派发器，触发数据的改变，这样就横向的把`methods`拆分出来。
- `hooks `是 `vue3 `底层提供的钩子实现函数方式(不像 `vue2 options API`)，开发者只需写提供钩子里面的逻辑。
- 基于函数抽离的组合各种方法函数实现高内聚的情况(2.0 有横向拆分，各个组件都有如 `data，method,computed`)。
- **`CompositionAPI`** 解决问题是`vue 2.0`中当组件变得庞大复杂起来后，代码可阅读性降低。
- `setup`函数是组合式`API`的入口函数,所有组合式`API`都可以放入到`setup`内部执行。一个组件选项，在组件被创建**之前**，`props` 被解析之后执行。它是组合式 `API `的入口。`setup`返回一个对象，对象里的属性将被合并到`render`函数执行期上下文里，所以视图模板可以使用对象里的数据。
- 执行时期是组件被创建之前(`beforeCreate`)到`props`被解析后执行，即使用组合式`API`时，没有`beforeCreate`和`created`生命周期函数，在组件创建之前自动执行。当视图模板访问对象属性时，不需要`.value`写法。
- 当组件被缓存时是无法重新挂载`onMounted`组件的，`actatived`和`deactived`生命周期可以获取下次再次激活的组件数据。
- 使用一对 `provide` 和 `inject`。无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 `provide` 选项来提供数据，子组件有一个 `inject` 选项来开始使用这些数据。
- 使用场景一般用于父组件`provide`分发自定义的`hooks`逻辑任务给子组件，子组件穿透`inject`注册后视图模版传入数据从而修改父组件的值。
- 响应式是`vue`的核心，它继承`angular`相关的思想，响应式是数据与视图的联动关系，希望一个数据被更改时不必让开发者考虑视图如何驱动，让`vue`底层`vmmodel`去追踪数据依赖变化并及时更新视图。`vue2`是通过`Object.defineProperty`，`vue3`通过`proxy`代理响应式数据。丢失响应式的本质是不能正常的触发`getter`和`setter`，无法进行视图的更新。
- 定义响应式数据的两种方式是`ref`，`reactive`，`ref`主要用于简单数据，`reactive`用于复杂的数据组合，如对象数组等。
- **`reactive`导致响应式丢失的情况有以下：**
  - 情况1 解构对象里的属性，原因是解构后的属性并不会走`getter`，无法进行数据响应式代理，造成丢失。
  - 情况2 重复赋值给新的变量 因为 `Vue` 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。
  - 情况3 传参数无法追踪变量导致丢失。
- `watchEffect`侦听副作用的依赖，执行回调，与定义了`immediate`属性的`watch`函数一样立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖(数据)变更时重新运行该函数。副作用有`DOM`更新，异步请求任务等。
- `watch`侦听器主要监听的是依赖，当响应式数据变更的时候监听变化，从而给开发者提供接口去完成自定义的逻辑程序。
- 关于`computed`计算属性的一些概念：
  - 计算属性来描述依赖响应式状态的复杂逻辑供模板视图使用。
  - 计算属性缓存和方法机制的不同，不同之处在于**计算属性值会基于其响应式依赖被缓存**。
  - 一个计算属性仅会在其响应式依赖更新时才重新计算。
  - 计算属性无论多少次访问，都会立即返回先前的计算结果，而不用重复执行`getter`函数。
