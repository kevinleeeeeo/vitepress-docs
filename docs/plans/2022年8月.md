## 第一周

| **日期** |                  **早**                  |                  **午**                  |                **晚**                 | **复习内容** | **完成度** |
| :------: | :--------------------------------------: | :--------------------------------------: | :-----------------------------------: | :----------: | :--------: |
|  8月1日  | 添加购物车模型、使用查询参数、预生成内容 | 编辑页面、删除功能的开发、购物车功能完善 |   数据库的选择、设置MySQL、获取数据   |   useState   |    90%     |
|  8月2日  |        获取产品、往数据库插入数据        |   什么是Sequelize、定义模型、插入数据    |   获取数据、更新删除产品、创建关系    |  effectHook  |    90%     |
|  8月3日  |      创建用户、定义关系、创建购物车      |       完善购物车功能、添加订单模型       | 设置MongoDB、创建数据库连接、创建产品 |  useEffect   |    80%     |
|  8月4日  |     获取所有产品、编辑产品、删除产品     |         添加用户、添加购物车功能         |     完善购物车功能、添加订单功能      |  自定义Hook  |    80%     |
|  8月5日  |       使用Mongoose、产品的增删改查       |   添加用户模型、购物车和订单功能的开发   |         XSS攻击介绍和预防措施         |  useReducer  |    90%     |
|  8月6日  |       XSRF、CSRF攻击介绍和预防措施       |          SSRF攻击介绍和预防措施          |        点击劫持介绍和预防措施         |  useContext  |    100%    |
|  8月7日  |                   复习                   |                   复习                   |                 复习                  |     复习     |    50%     |



**知识整理：**

- **关系型**数据库是带有数据表，数据表里的每一行是records，不同的数据表之间有相对的数据关系，如一对一，一对多，多对多。
- Sequelize 提供了 **四种** 关联类型,并将它们组合起来以创建关联：
  - `HasOne` 关联类型
  - `BelongsTo` 关联类型
  - `HasMany` 关联类型
  - `BelongsToMany` 关联类型
- 在 Sequelize 中设置模型的验证和约束.
- 验证是在纯 JavaScript 中在 Sequelize 级别执行的检查.
- 约束是在 SQL 级别定义的规则. 约束的最基本示例是唯一约束. 
- **CSRF** 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态（cookie），绕过后台的用户验证，冒充用户向服务器执行一些操作。
- **防护方法：**
  1. 同源检测，服务器检测请求来源；
  2. 使用 token 来进行验证；
  3. 设置 cookie 时设置 Samesite，限制 cookie 不能作为被第三方使用；
- **XSS**是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。
- 恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的特殊目的。
- XSS攻击分成两类，一类是来自内部的攻击，主要指的是利用程序自身的漏洞，构造跨站语句，如:dvbbs的showerror.asp存在的跨站漏洞。
- 另一类则是来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当要渗透一个站点，自己构造一个有跨站漏洞的网页，然后构造跨站语句，通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。

## 第二周

| **日期** |                  **早**                  |                  **午**                  |                  **晚**                  |    **复习内容**     | **完成度** |
| :------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :-----------------: | :--------: |
|  8月8日  |          sql注入介绍和预防措施           |                  国际化                  |     Blob介绍、文件下载、文件分段上传     |       useMemo       |    80%     |
|  8月9日  |      Buffer介绍、Node中Buffer的使用      |             ArrayBuffer介绍              |             类型化数组、视图             |       useRef        |    80%     |
| 8月10日  |          6种跨域获取数据的方法           |          6种跨域获取数据的方法           |          6种跨域获取数据的方法           | useInperativeHandle |    80%     |
| 8月11日  |  【实战】JSONP跨域之『百度联想词搜索』   |  【实战】JSONP跨域之『百度联想词搜索』   |  【实战】JSONP跨域之『百度联想词搜索』   |   useLayoutEffect   |    90%     |
| 8月12日  | 【实战】iframe实用之网页导航、代码编辑器 | 【实战】iframe实用之网页导航、代码编辑器 | 【实战】iframe实用之网页导航、代码编辑器 |    useDebugValue    |    90%     |
| 8月13日  |         cookie增删改查、用户追踪         | 【实战】cookie+token实现网站『持久登录』 | 【实战】cookie+token实现网站『持久登录』 |      useEffect      |    80%     |
| 8月14日  |                   复习                   |                   复习                   |                   复习                   |        复习         |     0%     |



**知识整理：**

- SQL注入漏洞对于数据安全的影响
- 数据库信息泄漏、网页篡改、数据库被恶意操作、服务器被远程控制
- vue国际化，i18n插件可以集成到vue项目中
- react国际化，i18next, react-i18next集成到react项目
-  **Blob**是前端专门用于支持文件操作的二进制对象，同时，File是一种特殊的Blob对象 
-  **Buffer**缓冲区是暂时存放数据输入输出的一个内存，可以使用Buffer对二进制数据进行操作 
- `Blob.arrayBuffer()` 返回一个 promise 且包含 blob 所有内容的二进制格式的 `ArrayBuffer`
- `ArrayBuffer `对象用来表示通用的、固定长度的原始二进制数据缓冲区， 它是一个字节数组，通常在其他语言中称为“byte array”
- 为何使用buffer?
  - js自身只有字符串数据类型,没有二进制数据类型
  - 处理像TCP流或者文件流时必须使用二进制数据,所以定义了一个buffer类
  - buffer类用来创建一个专门存放二进制数据的缓存区
- `Buffer.alloc(size[,fill[,encoding]])`:返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0
- `Buffer.allocUnsafe(size)`： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据
- `Buffer.from(array)`： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）
- `Buffer.from(arrayBuffer[, byteOffset[, length]])`： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer
- `Buffer.from(buffer)`： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例
- `Buffer.from(string[, encoding])`： 返回一个被 string 的值初始化的新的 Buffer 实例
- 跨域解决方案:
  - 通过jsonp跨域
  - document.domain + iframe跨域
  - location.hash + iframe
  - window.name + iframe跨域，原理是window.name可以在父子iframe窗口中互相传值
  - postMessage跨域
  - 跨域资源共享（CORS）
  - nodejs中间件代理跨域
  - WebSocket协议跨域

## 第三周

| **日期** |                  **早**                  |                 **午**                  |                 **晚**                  | **复习内容** | **完成度** |
| :------: | :--------------------------------------: | :-------------------------------------: | :-------------------------------------: | :----------: | :--------: |
| 8月15日  |   【实战】AJAX之『大附件文件上传功能』   |  【实战】AJAX之『大附件文件上传功能』   | 【实战】AJAX之『后台列表管理模块』（1） |  工程化概念  |    90%     |
| 8月16日  |          『可拖动的穿梭框』组件          |         『可拖动的穿梭框』组件          |         『可拖动的穿梭框』组件          |    组件化    |    80%     |
| 8月17日  |              events模块重写              |             events模块重写              |             events模块重写              |     模块     |    70%     |
| 8月18日  |                 vite重写                 |                vite重写                 |                vite重写                 |     插件     |    80%     |
| 8月19日  |                 vite重写                 |                vite重写                 |     正则量词、属性、方法、使用技巧      |     入口     |    80%     |
| 8月20日  | match/exec、toString/valueOf、封装typeof | 正向预查、贪婪与非贪婪模式、replace方法 |        正则实例集合、不捕获分组         |    加载器    |    90%     |
| 8月21日  |                   复习                   |                  复习                   |                  复习                   |     复习     |    80%     |



**知识整理：**

- `application/x-www-form-urlencoded`可以把表单填写的数据键值对化(`wd=xxx&vid=xxx`)
- `enctype`属性是指定什么样的数据格式进行编码(`form`表单默认是`application/x-www-form-urlencoded`)
- `enctype="multipart/form-data"`：将上传的文件类型转为二进制类型
- `multiple`：多选
- `XMLHttpRequest.upload.onprogress`事件表示进度条进行时触发
-  Vite是一个开放服务器，它跟开发项目打包没有关系，Vite做开发Dev，而Rollup做打包Build 
- **创建开发服务**应用的原因是ES Module需要服务，让ES Module能正常使用，它跟ES Module有关系，因为现代浏览器都支持ES Module，可以直接在项目中import/export，但是ES Module不可以随便使用，它基于服务，每一次import都要发起一个HTTP请求资源，所以请求建立在基础服务上才有数据响应
- **编译工作**，对vue语法和依赖路径进行编译
  浏览器一般不解析`.vue`文件，所以通过Vite编译成.js文件并且转为浏览器可以解析的语法，如：正常解析`.vue`里的`<template>`,`<script>`,`<style>`等语法
  编译依赖路径，`import {createApp} from 'vue'`中`'vue'`，ES Module只认识`'./'`或`'../'`等路径的引入，期望将路径写法`./node_modules/@vue/dist/runtime.esm-browser.js`转为ES Module认识的路径
- **预构建**(Vite@2新增)，把项目涉及的所有的第三方依赖通过ES Build全部打包(pre-build)，打包后存放至`node_modules`底下的`.vite`文件夹里
- ES Build基于GO语言的一个快速打包的工具
  - 超级快的网络构建工具，无需缓存
  - 支持ES6和CommonJS模块
  - 支持ES6的Tree Shaking
  - 集成JavaScript和GO的API
  - 支持TypeScript和JSX语法
-  **Readable streams**  是来自nodejs里steam模块的一个接口，流（stream）是 Node.js 中处理流式数据的抽象接口。用于构建实现了流接口的对象。 
- **Es-Module-Lexer** 是一个可以对 ES Module 语句进行词法分析的工具包。 
- **magic-string** 这个库做一些字符串的魔术替换，这个库的目的就是在一些轻量级替换源代码的场景中替代 AST 这种过于庞大的解决方案。 



## 第四周

| **日期** |           **早**            |           **午**            |           **晚**            | **复习内容** | **完成度** |
| :------: | :-------------------------: | :-------------------------: | :-------------------------: | :----------: | :--------: |
| 8月22日  |      快速实现『Vuex』       |      快速实现『Vuex』       |      快速实现『Pinia』      |   图片处理   |    90%     |
| 8月23日  |      强缓存和协商缓存       |      强缓存和协商缓存       | if/else优化--策略模式优化_1 | file-loader  |    80%     |
| 8月24日  | if/else优化--策略模式优化_2 | if/else优化--策略模式优化_3 |  链式调用优化_责任链模式_1  |  url-loader  |    80%     |
| 8月25日  |  链式调用优化_责任链模式_2  |  链式调用优化_责任链模式_3  |        buffer&stream        |  css-loader  |    90%     |
| 8月26日  |        buffer&stream        |  ECMAScript深度基础拓展课   |  ECMAScript深度基础拓展课   | style-loader |    70%     |
| 8月27日  |          Sass初识           |       编译、输出方式        |       变量、混入mixin       | sass-loader  |    90%     |
| 8月28日  |            复习             |            复习             |            复习             |     复习     |    80%     |



**知识整理：**

- **Pinia**因为冗长的原因取消了mutation机制。

- Pinia里定义了一个store数据单独一个函数管理`useCounterStore`，该函数里面保存视图数据`state.count`和修改视图数据的方法`actions.plusAsync`。

- 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。

- 协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。

- **Pragma：no-cache**(http1.0)该响应头指示浏览器忽略资源缓存副本，每次访问需要到服务器获取

- **Cache-Control**(http1.1)缓存控制(响应头)
  - no-cache：指示浏览器忽略资源缓存副本，强制到服务器获取资源(**浏览器依旧缓存**)
  - no-store：强制缓存再任何情况下都不要保留任何副本
  - max-age=31536000：指示缓存副本的有效时长，从请求时间开始到过期事件之间的秒数
  - public：表明响应可以被任何对象(包括：发送请求的客户端，代理服务器等)缓存
  - private：表面响应只能被单个用户缓存，不能作为共享缓存(即代理服务器不能缓存它)
  
- **Expires**存储格林威治时间，启用缓村和定义缓存时间，告诉浏览器资源缓存过期时间，未过期不请求。在HTTP1.1版本时用`Cache-Control: max-age=xxxx`替代。

- **协商缓存**也叫对比缓存，针对根目录`index.html`文件首页缓存，根据当前的时间，获取最后一次修改时间，设置响应头(`res.setHeader('Last-Modified', stat.ctime.toGMTString())`)，如果修改时间不一样就会重新请求资源，**缺点**是如果内容没有变化时，它也会重新请求，在1秒内多次更改不会重新请求，**解决方案**是通过电子标识(指纹)`eTag`如`MD5`摘要算法`res.setHeader('Etag', crypto.createHash('md5').update('123').digest('base64'))`还有拿到上次文件内容摘要哈希`req.header['if-modified-since']`和`req.headers['if-none-match']`对比检测内容是否一致，如不一致时响应304

- 响应可读流代表的是资源的地址，继承`emit`，能够注册对应的`data`或`end`事件触发对应的回调函数。

- Buffer缓冲区是暂时存放数据输入输出的一个内存，可以使用Buffer对二进制数据进行操作。

- `Buffer.allocUnsafe (size)`是未经初始化的一段内存空间，创建一个指定大小的buffer，但是buffer中可能含有敏感数据。

- `Buffer.alloc(10)`方法是经过初始化的一段内存空间，会将内存的数据进行清空之后再分配就会安全很多，但是缺点是性能没有allocUnsafe高。

- ***utf8和utf16有什么区别？***一个字节8个位，utf8表现一个字节，前128位是和acsii码重叠。NodeJS默认utf8，JavaScript默认utf16。

- NodeJS是多线程的，主线程是单线程的。当同步读取文件时，必须等待请求结果回来，会阻塞后续程序。在后端中不会用同步，后端所有API全部都是异步的。

- 异步读取的文件是对内存的输入和输入(I/O)才输出到指定文件。读取内容至buffer中和将buffer内容写入对应文件。

- 文件读取到内存中的弊端是一次就读取完毕。

- Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令。Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。

- chmod命令可以使用八进制数来指定权限。

- ***关键字`typeof`可以对类型进行检查，却为什么无法区分`object`是`null`，或是`array`，或是对象？***

  `typeof`是从底层抛给上层一个关键字，关键字都是从底层抛出的，它更接近原生JavaScript编译之前的语法，它属于底层语法并遵循ECMA-262规范。

  `typeof`最开始触及的是内存，从内存出发告诉类型。JavaScript都是偏向所有的原始值，变量声明不赋值系统默认为`undefined`，类型也是`undefined`。`typeof`不会对对象类型进行分类的原因是对于内存来说只有原始值和引用值的区别(语法和规范层面)，所以对引用值只有`object`并没有区分。

  对于引用值无法区分的问题，因为许多项目已经上线进行类型检查使用了`typeof`关键字所以不能再修改了。所以在ES5中新增了`use strict`检测限制，避免之前的使用了的项目出现报错的情况。

- ***为什么是中括号显示`[object Object]`？***

  ES3版本草案说了双括号`[[]]`是内部属性(Internal Property)，用单括号`[]`表示的是内部信息(Internal Information)。如作用域`[[scope]]`，原型`[[prototype]]`。

- ***为什么使用`Object.prototype.toString.call()`方法?***

  因为可以让所有的类型都可以调用对象原型上的这个方法来检测类型，简写为`({}).toString.call()`。

- Scss 是css的预编译器，能补充css中的一些缺点如重复的代码块，可以实现把公用的代码块规划成可复用的区块。css预处理器语言实际上是通过该处理器的语法来产生css程序。它包括了纯css语法里没有的变量，还有一些简单的逻辑程序，如函数，对于结构和维护更为方便。 

## 第五周

| **日期** |            **早**             |               **午**                |               **晚**                |    **复习内容**    | **完成度** |
| :------: | :---------------------------: | :---------------------------------: | :---------------------------------: | :----------------: | :--------: |
| 8月29日  |         继承、占位符          |         Sass运算、控制命令          |        字符串函数、数字函数         |    图标文字处理    |    90%     |
| 8月30日  |     get、eq 方法源码实现      |        add、end方法源码实现         |       jQuery源码分析之extend        |      插件配置      |    90%     |
| 8月31日  |     jQuery源码分析之init      |         on、trigger源码实现         |   queue、dequeue、animate源码实现   |     sourceMap      |    80%     |
|  9月1日  |  Callbacks、Deferred源码实现  |           Vuex的设计理念            |    搭建项目与Vuex的使用方法（1）    |     externals      |    80%     |
|  9月2日  | 搭建项目与Vuex的使用方法（2） | 基本实现与设计思想、方案与技巧（1） | 基本实现与设计思想、方案与技巧（2） |      后缀处理      |    80%     |
|  9月3日  |   forEach/filter使用与重写    |     、map/every/some使用与重写      |    reduce/reduceRight使用与重写     | webpack-dev-server |    90%     |
|  9月4日  |             复习              |                复习                 |                复习                 |        复习        |    70%     |



**知识整理：**

- sass可以把公用的代码块存放至mixin里，不同选择器里使用`@include`关键字可以使用。
- Ruby是一个面向对象的脚本语言，20世纪90年代由日本人，松本行洪开发的。
- sass语法的特点是缩进换行，不需要分号，对前端代码编写体验不太友好。
- `$`是变量的声明符号，定义在其它嵌套代码块的变量是无法访问的。
- Mixin混合宏，用来解决需要写兼容性属性，如css3属性。将公共样式代码提取作为一个类似模块的块，对应传入的参数作为样式属性值。
- `jQuery.prototype.get`方法根据索引返回jQuery对象里匹配索引的那一项元素(原生DOM)。
- `jQuery.prototype.eq`方法根据索引返回jQuery对象里一组DOM元素里的某一项元素(jQuery DOM)。
- `jQuery.prototype.add`方法根据用户填写的选择器(样式或id)，将符合的选择器元素添加至一个新的jQuery对象里，返回一个新的jQuery对象(jQuery元素集合)包含所有符合选择器元素和索引为0的父级元素(调用者)
- `jQuery.prototype.end`方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。
- `jQuery.prototype.init`方法根据用户填写的选择器(样式或id)，遍历该选择器底下所有的元素并包装成一个jQuery对象，对象底下包含的是所有元素。
- `jQuery.prototype.on`方法在被选元素及子元素上添加一个或多个事件处理程序。
- `jQuery.prototype.trigger`方法触发被选元素上指定的事件以及事件的默认行为。
- `jQuery.prototype.queue`方法是入列 显示被选元素上要执行的函数队列 队列是一个或多个等待运行的函数。一个元素可以有若干队列。大部分通常只有一个，"fx" 队列，即默认的 jQuery 队列。
- `jQuery.prototype.dequeue`方法是出列 从队列中移除下一个函数，然后执行函数。
- `jQuery.prototype.animate`方法执行 CSS 属性集的自定义动画。
- `jQuery.Callbacks`方法一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。
- `jQuery.Deferred`方法返回一个链式实用对象方法来注册多个回调，并且调用回调队列，传递任何同步或异步功能成功或失败的状态。
- Vuex4.0主要是配合3.0，为了配合函数接口也做了相应的函数接口。Vuex是**状态管理模式和库**，采用集中式存储管理应用的所有组件的状态。
- 中央状态管理器把所有组件需要统一管理的数据全部放在Vuex的仓库中统一进行管理。组件内部的`data`属性是视图数据，状态和数据的区别是状态要高于数据，有更加规范的操作，且是全局性的更改方案。
- Vue组件会触发Dispatch一个Action行为去修改State的方案，在Action函数里可以实现后端的异步数据请求，Action可以Commit调用Mutations完成修改State任务的函数，State变化后引起视图的重新渲染。
- 对于Redux或Vuex来说，某一步骤进行到流程中的某一项，开发者通过步骤就可以知道如何操作数据，操作数据的同时还做了什么逻辑，固化开发步骤和流程。

