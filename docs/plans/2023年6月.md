# 学习计划

## 第一周

| **日期** |               **早**                |                **午**                |                  **晚**                  |   **复习内容**    | **完成度** |
| :------: | :---------------------------------: | :----------------------------------: | :--------------------------------------: | :---------------: | :--------: |
| 5月29日  |             数组扁平化              |              扁平化原理              |              扁平化函数封装              |  `express`中间件  |    90%     |
| 5月30日  |           基础Vue组件封装           |            Vue路由的使用             |            Koa基础之基本使用             | `express`静态文件 |    80%     |
| 5月31日  |          Koa基础之基本使用          |           TS在Vue中的使用            |          Axios的基本使用（一）           | `express`中`MVC`  |    80%     |
|  6月1日  |        Axios的基本使用（二）        |     NodeJS中使用jwt进行身份验证      |        Vue动态组件、CSS3翻转动画         | `express`模版处理 |    80%     |
|  6月2日  | VueRouter介绍、两种模式、编程式导航 | 路由参数、查询参数、命名视图、重定向 | 过渡动效、滚动行为、导航守卫、路由懒加载 |   `JS`编译过程    |    70%     |
|  6月3日  |         Vuex之介绍、Getters         |       Vuex之Mutations、Actions       |                Vuex之模块                |   `NodeJS`概念    |    70%     |
|  6月4日  |             react-redux             |             react-redux              |               react-redux                |       复习        |    60%     |

**知识整理：**

- `Getters`会暴露为 `store.getters` 对象，可以以属性的形式访问定义的值 
- `getter`属性让其返回一个函数，来实现给 `getter`传参,对 `store`里的数组进行查询时非常有用 

- `mutation` 更改 `Vuex`的 `store`中的状态的唯一方法是提交 `mutation` 

- 每个 `mutation`都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)** 

- `Action`提交的是 `mutation`，而不是直接变更状态 

- `module`可以 `Vuex`允许我们将 `store`分割成**模块（module）**。每个模块拥有自己的 `state`、`mutation`、`action`、`getter`、甚至是嵌套子模块——从上至下进行同样方式的分割 

- 关于派发器的由来：在`vue`中强规范的`template`,`script`,`style`的固定写法，存在弱点，在`method`里的业务逻辑实现时写了大量的紧耦合的方法，利用派发器的机制横向切割的方式实现抽离`script`里的`methods`代码编写区域出去(松耦合) 

- **派发器如何实现抽离？**
  派发器根据一个又一个的事情来指定一个`type`，`type`的作用是遇到`type`对应的事情就触发一个方法的执行，每件事所对应的方法集合是根据每件事情的`type`去触发的 

- 派发器的作用：  派发器(`dispatcher`)根据`action`里面的`type`去调用相应的`method`方法 

- `redux`**和派发器有什么关系？**
  基本原理一致，但有一点不同，不同页面的组件想拿到数据状态是不同的，`redux`可以解决 

- **数据状态存放在**`localStorage`**有什么弊端？**
  `localStorage`是不联动的，状态变更也不会导致所有页面马上发生变更 

- **为什么大部分场景都没有必要用**`redux`**?**
  目前开发的所有单页面应用组件是属于重新加载组件的过程(`componentDidMount`)，当组件关闭时,它不是`alive`的，并且有许多方法可以避免使用`redux` 

- **有什么情况必须要用到**`redux`**?** 

- 页面组件是`alive`的，它不能触发组件加载(`componentDidMount`),就需要中央管理状态机制 

- 在`react native`开发中某些页面(`alive`) 

- **为什么需要两个子模块分开处理？**
  因为如果两个模块一起编写，在修改其中模块时会影响另一个模块，而且不方便维护，且逻辑之间杂乱不清 

- **两个分开模块之间如何实现数据联动管理？**
  利用观察者模式实现管理数据更新 

- **观察者原理：**
  每一个观察者实际上是一个函数，一旦触发事件，执行一个函数完成一个程序，当一个程序分为1，2，3件事情，那么这个程序就为一个`observers`，当执行程序123(`observers`)时不能单独执行，利用`obsevers`里面的`notify`通知特性，将123一次性执行，真正事件触发时仅仅执行的是`notify`函数
  也就是说，希望123函数作为一个个`obsevers`放入数组里，统一用`notify`一次去执行，在项目里，点击单击事件时触发执行`notify`函数，然后`notify`里面所有的`observers`会依次执行 

## 第二周

| **日期** |               **早**                |               **午**                |              **晚**              |    **复习内容**    | **完成度** |
| :------: | :---------------------------------: | :---------------------------------: | :------------------------------: | :----------------: | :--------: |
|  6月5日  |     Proxy与ES-14种对象操作方法      |     Proxy与ES-14种对象操作方法      |    Proxy与ES-14种对象操作方法    |    MongoDB 模型    |    70%     |
|  6月6日  |         观察模式-购物车案例         |         观察模式-购物车案例         |       观察模式-购物车案例        | MongoDB 模型增删查 |    80%     |
|  6月7日  |         观察模式-购物车案例         |         观察模式-购物车案例         |       观察模式-购物车案例        |    MongoDB 实例    |    70%     |
|  6月8日  |      手写Promise之状态基本实现      |      手写Promise之状态基本实现      |      手写Promise之链式操作       |    MongoDB 创建    |    80%     |
|  6月9日  |        手写Promise之链式操作        |    手写Promise之rejected状态实现    |  手写Promise之rejected状态实现   |     react概念      |    70%     |
| 6月10日  | keep-alive、动态组件与异步组件（1） | keep-alive、动态组件与异步组件（2） | 深入应用动态、异步与suspense组件 |     react搭建      |    90%     |
| 6月11日  |                复习                 |                复习                 |               复习               |        复习        |     0%     |

**知识整理：**

- **严格模式设计的目的：**

  - 减少语法层面的不合理
  - 不严谨
  - 不安全
  - 怪异行为

- 在严格模式下的区别有：

  - 变量层面
    - 全局变量声明时必须用`var`，否则使用严格模式时变量为`undefined`
    - 保留字和关键字不允许使用，如`var eval`
    - 全局变量的`delete`操作符失效问题(静默失败)，通过报错方式解决
  - 对象层面
    - 对象属性描述符造成的操作失败的问题(静默失败)，报错
    - `for...in`循环不会报错
  - 函数层面
    - 函数参数需要唯一的
    - 形参实参就没有相互映射关系
    - `caller`和`callee`会报错
    - `arguments.callee`指的是调用函数本身
    - `函数名称.caller`是函数属性，它指向当前调用函数的作用域
    - `eval`和`with`语句报错

- **派发器的思维模式**

  分组件，子组件，功能1,2,3, 希望集中管理而不去调用，通过接口的**任务类型**统一去派发，派发之后执行某一个任务，相当于把功能集成起来，使用派发接口时不用管如何实现，也不用管具体任务

- 状态模式：将一个类抽象多个状态的类，这些类和主类保持了继承关系和依赖关

- **什么是`solid`设计原则？**

  - 单一职责原则(胖函数减肥)
  - 开放封闭(拓展开发修改)
  - 里氏替换
  - 接口开放
  - 依赖倒置

- **什么是高阶函数？**

- 只要函数的参数是函数，或者返回值是函数的形式时，都成为高阶函数

- **高阶函数具体有什么应用场景？**

  - 能够将代码划分为若干片段，然后按顺序执行
  - 将功能或复用的业务能够抽离成一个函数，如参数是函数的形式(`axios`的封装)
  - 一个函数只能做一件事情(单独的业务功能)，如具有高度相似业务逻辑的工具函数的再封装(返回值是函数的形式)

- **函数的短板？**

- 函数作为另外函数的参数，函数赋值遍历，函数作为返回值，操作比较繁琐，需要通过指针，代理的方式实现。

- **面向对象与函数式编程的关系**

  - 面向对象：适用于高度复用场景，有复杂`this`指向问题
  - 函数式编程的优点：易读易维护
  - 函数式编程是第一类对象，不依赖任何其他对象独立存在(概念)

- **函数组合：**

- 若干个纯函数，偏函数，柯里化函数组合成一个新的函数形成数据传递，并实现一种有序执行的效果

- **左倾方式：**

- 函数参数自右向左边执行函数的方式

- 结合律是在组合函数的参数中再进行分组，它和原来函数组合得出的结果是一样的

- 柯里化：接受多个参数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

- 偏函数：部分应用，在计算机科学中，偏函数叫做部分应用，局部应用，指固定一个函数的一些参数，然后产生另一个更小元的函数，实际上是一种降元的过程

- 惰性函数：适用于底层代码封装，程序优化等方面，优化函数本身，函数内部改变自身的机制

- 缓存函数：函数优化的一种方式

- 防抖：实现延迟执行，防止用户交互时产生多次触发

- 节流：事件被触发，`n`秒之内只执行一次事件处理函数

- 归类：数据归类技术，前端处理后端接口数据

- 扁平化：将多维数组变为一维数组

## 第三周

| **日期** |           **早**           |               **午**               |            **晚**             | **复习内容** | **完成度** |
| :------: | :------------------------: | :--------------------------------: | :---------------------------: | :----------: | :--------: |
| 6月12日  |   `attributes`传递与继承   |       `attributes`传递与继承       |        自定义事件（1）        |   `state`    |    80%     |
| 6月13日  |      自定义事件（2）       |   自定义指令概念、生命周期与参数   | 实现自定义指令`v-show`/`v-if` |  单向数据流  |    90%     |
| 6月14日  |       `tab`切换指令        |           `tab`切换指令            |         `tab`切换指令         |  `setState`  |    90%     |
| 6月15日  |         懒加载指令         |             懒加载指令             |          懒加载指令           |     事件     |    80%     |
| 6月16日  | `teleport`的特点与应用场景 | 深入研究插件化开发与`UI`组件库实现 |       `Vue3`插件化开发        |   事件传参   |    80%     |
| 6月17日  |      `Vue2`插件化开发      |      `mixin`的特性与应用场景       |  编译过程、渲染函数与`h`函数  |   列表渲染   |    90%     |
| 6月18日  |            复习            |                复习                |             复习              |     复习     |    60%     |

**知识整理：**

- **组件渲染流程：**

- 1. `template`模板编译转为`AST`树，描述了`template`的形状，并含有`vue`指令的特性写法
  2. `AST`树过滤`vue`特性转为`JS`逻辑的`DOM`树
  3. 最后由虚拟节点转为真实节点

- **视图更新时：**

- 更新内容转为虚拟节点对比之前组件`keep-alive`缓存的虚拟节点(如果没有之前的节点则重新组装)，缓存的节点不会经过`unmount`组件卸载的过程，找差异形成补丁，更新真实节点

- **关于`keep-alive`标签：**

- 用一个 `<keep-alive>` 元素将其动态组件包裹起来。可以使组件实例能够被在它们第一次被创建的时候缓存下来。它不走`mounted`和`unmounted`生命周期函数，转而用`activated`激活和`dectivated`未激活函数使用

- **自定义指令：**

  开发者也可以给 `Vue `拓展指令，`v-自定义名称`，它可以提供一个直接操作`dom`的接口

- `teleport`实现一个模态框，它可以将一个嵌套关系的`modal`组件移动到`<body>`标签里，实现该组件可以复用

- 在` Vue 2.x` 中，`Vue.extend` 曾经被用于创建一个基于 `Vue `构造函数的“子类”，其参数应为一个包含组件选项的对象

- **为什么使用`Vue.extend`?**

  - 脱离根节点
  - 脱离应用实例`app`
  - 希望通过插件的方式能够不在模板上调用，而是用方法操作组件的状态，需要`Vue.extend`创建一个新的应用的构造函数，可以多次实例化不同的应用

- **`mixin`是什么？**

  它是`option API`时期的产物，如果组件有同样的`data`或`method`，则可以将`data`单独拿出来放到`mixin`再混入到组件里，使代码减少重复性

- **为什么`vue3.x`不推荐使用`mixin`？**

  - 用于多个组件的时候，可能会多出很多不必要的选项或属性
  - 很可能会无限拆分`mixin`
  - 不好管理也不好取名字，有可能导致命名冲突
  - 导出的`mixin`对象它不是函数，没办法动态传参调整`mixin`的`option`的混入情况，极大的干扰了`mixin`合理性复用

- **`mixin`总结：**

  1. 当`mixin`和组件的定义的属性冲突时，组件自身的内容优先
  2. 生命周期钩子函数混入时，优先执行`mixin`后执行组件
  3. 对象`options`像`methods`,`components`,`directives`等，会合并对象，存在同名时组件优先

## 第四周

| **日期** |                  **早**                  |                  **午**                  |                  **晚**                  | **复习内容** | **完成度** |
| :------: | :--------------------------------------: | :--------------------------------------: | :--------------------------------------: | :----------: | :--------: |
| 6月19日  |           结合react深度学习JSX           |        渲染函数与h函数的使用事项         |            DOM Diff专题（1）             |   状态组件   |    60%     |
| 6月20日  |            DOM Diff专题（2）             |              应用配置专题课              |            深入学习setup函数             |   受控组件   |    70%     |
| 6月21日  |       组合式API 学习Vue的生命周期        |      【组合式API】activated应用场景      |           Vue2.x实现方案（1）            |   表单操作   |    70%     |
| 6月22日  |           Vue2.x实现方案（2）            |           Vue2.x实现方案（3）            |       React Hooks普通设计方案实现        |  非受控组件  |    80%     |
| 6月23日  |       复习派发器方案及总结设计思想       |             编写后端API接口              |                跑通前后端                |   组件通信   |    80%     |
| 6月24日  | Vue3『封装可编辑表格组件』【插件化开发】 | Vue3『封装可编辑表格组件』【插件化开发】 | Vue3『封装可编辑表格组件』【插件化开发】 |   状态提升   |    70%     |
| 6月25日  |                   复习                   |                   复习                   |                   复习                   |     复习     |    50%     |

**知识整理：**

- **什么是`Dom Diff`？**

  比对(`diff`)渲染更新前后产生两个虚拟`dom`对象的差异，并产出差异补丁对象，再将差异补丁对象应用到真实`dom`节点上

- **为什么要用`Dom Diff`?**

  在浏览器中，操作`dom`需要耗费性能的，尽可能的减少操作`dom`可以保证性能

- **`Dom Diff`算法的特点：**

  - 平级对比，如`ul`对`ul`，不跨级对比
  - 里层元素只是位置顺序不一样，但是内容一样时不会重新渲染
  - 深度优先，从外到内嵌套比对

- **`setup`是什么？**

  它是组合式`API`的入口函数,所有组合式`API`都可以放入到`setup`内部执行

- **执行时期：** 组件被创建之前(`beforeCreate`)到`props`被解析后执行，即使用组合式`API`时，没有`beforeCreate`和`created`生命周期函数，在组件创建之前自动执行

- 派发器在`vue`项目中结合`reducer`的使用原理：

  视图绑定的方法和属性都来自于中央状态管理，它包含了`state`数据和`todoDispatch`方法，该方法根据`type`去执行相应的`reducer`程序以便于分支执行相应的`state`数据操作

- ***为什么使用派发器？***

  使组件更纯净，专注与视图，业务逻辑任务抽离外部，仅一个方法通过任务类型区分自动执行逻辑程序

- **派发器思想机制：**

  它是一个任务机制，任务可以被封装成函数，将逻辑尽可能合理的转为任务，结合派发器同步异步分配，简单的任务分配到同步或异步，通过通知机制使程序自动运行，命名空间的方式，按照不同任务的类型去自动执行

- `defineExpose`：暴露当前 `<script setup>` 组件里的属性或方法供外界访问，如应用实例或组件

- `<transition>`作为根节点的组件从外部被切换时将不再触发过渡效果

- `clientHeight`/`clientWidth`/`offsetHeight`/`offsetWidth`：返回该元素的像素高度和宽度，是一个整数，单位`px`

- `offsetTop `/`offsetLeft`：返回当前元素相对于节点(包含层级上的最近的)顶部边界的偏移像素值

- `Touch.clientY`：返回触点相对于可视区上边沿的`Y`坐标