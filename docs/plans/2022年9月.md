## 第一周

| **日期** |         **早**          |        **午**        |                **晚**                |      **复习内容**       | **完成度** |
| :------: | :---------------------: | :------------------: | :----------------------------------: | :---------------------: | :--------: |
|  9月5日  |      路由权限解析1      |    路由权限解析2     |            路由权限解析3             |           HMR           |    90%     |
|  9月6日  |      路由权限解析4      |    路由权限解析5     |      标签的属性与特性、Math方法      | babel-loader/babel-core |    80%     |
|  9月7日  |      归类函数封装       | 图片的预加载与懒加载 |        浅谈从DOM操作到虚拟DOM        |     babel/polyfill      |    80%     |
|  9月8日  |  函数防抖、函数节流、   |   防抖和节流的应用   |        函数性能优化、缓存函数        |        .babelrc         |    80%     |
|  9月9日  |      函数记忆应用       |   函数名/对象拓展    |        描述符、getter/setter         |      tree shaking       |    80%     |
| 9月10日  | 对象密封4种方式、assign |    取值函数的拷贝    | super、4种遍历方式、原型、symbol遍历 |    esmodule/commonjs    |    80%     |
| 9月11日  |          复习           |         复习         |                 复习                 |          复习           |    50%     |



**知识整理：**

- 数据归类技术常用于后端，但有些数据需要前端进行整合处理，如一些后端不太完美的接口数据。需要一种整理的后端数据的方式是归类函数。
- 归类往往是以某一个类别来进行划分，分开存储数据。
  - 单一归类：一条数据对应一个分类
  - 复合归类：一条数据对应多个类别
- 虚拟DOM是通过JavaScript去模拟DOM结构。
- 原生DOM操作弊端是当改变某个节点内容时，重新渲染时会导致父节点链条重新渲染，造成大量的性能消耗，影响网页的加载速度。可以通过`snabbdom`虚拟DOM库来解决。
- 防抖操作实现延迟执行，防止用户交互时产生多次触发

  - 延迟执行：对于在事件被触发`n`秒后再执行的回调
  - 如果在这`n`秒内再次触发事件时，重新开始计时
- 防抖在发送网络请求时进行防抖处理，初次下拉不会延迟操作，再次触发时才需要延迟操作。
- 节流是事件被触发，`n`秒之内只执行一次事件处理函数。
- 函数记忆是函数优化的一种方式，也叫缓存函数(`memorize`)。
- `ES5`之前没有检测对象属性的方法，是否是只读，是否是可遍历，`ES5`之后提供属性描述符。
- 属性描述符的方法有：

  - `Object.defineProperty()`
  - `Object.defineProperties()`
- 因为`JavaScript`是弱类型语言，对于对象属性，变量的描述是不够彻底的，所以才有属性描述符方法对其进行完善处理。
- `get/put`操作是获取属性/赋值操作，`ES5`中`getter/setter`的存在为了改写当前的`[[Get]]/[[Put]]`的默认操作，`getter/setter`操作时会可以增加额外的操作。



## 第二周

| **日期** |           **早**           |            **午**            |       **晚**       | **复习内容** | **完成度** |
| :------: | :------------------------: | :--------------------------: | :----------------: | :----------: | :--------: |
| 9月12日  |      1-2_算法和复杂度      |        3_算法和复杂度        |   4_算法和复杂度   |   网络请求   |    90%     |
| 9月13日  |         1_栈和队列         |          2_栈和队列          |     3_栈和队列     | URI/URN/URL  |    90%     |
| 9月14日  |       1_链表概念梳理       |      2_链表的追加与插入      | 3_链表的删除与查找 |     C/S      |    90%     |
| 9月15日  |        4_链表的反转        |        树与二叉搜索树        |   树与二叉搜索树   | DNS解析过程  |    90%     |
| 9月16日  | 虚拟列表基本原理与实现方案 | 设置与编写响应式数据及其逻辑 | 响应式与渲染和更新 |      IP      |    80%     |
| 9月17日  | 滚动节流技巧与白屏解决方案 |   入门Vue3 Composition API   |   Vue3中代码复用   |     TCP      |    80%     |
| 9月18日  |            复习            |             复习             |        复习        |     复习     |    80%     |



**知识整理：**

- 算法是一个被定义好的，计算机可执行的指示的有限步骤或次序。解决一类问题，有限步骤，有具体的行之有效的步骤，按需执行。
- **素数筛选**，只能被1和自身整除的数据称为素数。先找能被2整除的数，再找能被3整除的数，再找能被5整除的数...。
- **四色算法**，给地图上色的方法，一张地图最多只要用4种颜色标记出各个国家的地域。
- **Google PageRank**，搜索引擎中基于网络节点重要性排序的权重排序算法，权重基于page rank算法。
- **数据可视化**，如气泡图。
- 算法应用场景集中在智能AI上，手势识别，VR虚拟现实技术，游戏，数据可视化。为了能够写好一个程序，不仅仅是提高效率。
- 数量级是指尺寸或大小的级别，一般是10的幂，即10的3次方。
- 程序中的算法是输入到输出的映射。数量级的限制是算法输入的规模，即数组的长度决定，导致算法最终的执行结果。
-  hadoop集群，它是一个分布式系统的架构，利用分布式算法把不同的CPU，上千个服务器的算力合并起来。 
- 时间复杂度衡量算法的执行时间，随着输入规模的增加而增加的一种关系，也是对算法的一种分类。 
- 栈 相当于一个有底的兜，放入东西时由下往上层叠，遵循后进先出的原则。JavaScript中通过数组的方式实现栈。JavaScript中没有栈和队列，它和数组非常的相似，栈也可以简单的理解为一个数组，一个有底的兜，执行栈是一个作用域链(记录着AO,GO)，多个作用域链按照栈的方式存储起来。 
- 队列  相当于一根管子，先入先出FIFO(first in first out)。涉及排队时，优先级排队需要设置优先级。 
- 链表  和数组的相同点是都是线性结构，线性结构可以通过`next`指针访问下一个数据元素。数组是相邻的内存空间，链表则有可能相邻有可能又不是。链表不像数组可以通过索引来寻找元素，它只能通过`head.next`指针1次或多次执行才可以找到。 
- 链表有分为单向，双向，单向循环，双向循环，环形链表。
-  树是一种数据结构，数组属于线性结构，通过索引获取当前数组成员，是一种线性的排列方式。栈，队列，数组都属于线性结构，但是树并不是线性结构。 
-  二叉树指的是度为2的树，树的每一个节点都是用于存放数据的，而数据的成员并不是线性结构，并没有办法通过索引的方式访问成员。 
- 节点有分为顶部的节点称为根节点，其余的节点称为子节点，也有兄弟或父子节点关系。diff算法，dom结构，路由配置，文件夹目录会使用到树形结构，dom树本质上也是属于树的一种。
- 子树分为左子树和右子树。
- 度是子树的个数，二叉树中的叉指的是度，每个节点有区分左树和右树。如果每一个子节点的个数都有时称为满二叉树。
- 叶子节点指的是度为0的节点，通常在树的最末端。非叶子节点一般在中间位置。
- 节点深度是顶部节点到当前节点所经过节点的总数。
- 节点高度是当前节点到最远节点所经过节点的总数。
- 长度指当前所有子节点的个数。
-  虚拟列表的难点在于优化上，特殊的需求如虚拟列表中间穿插着数据请求时，用户快速滑动显示白屏等问题。用户滑动时还存在不是性能问题而是渲染不及时造成的卡顿问题。滑动底部预留空间需要微调，而不同场景下微调的结果也不相同。
- 虚拟列表开发需要有规划开发的而不是一次性就可以实现的。给虚拟列表在有限的DOM里做无限的结构渲染。 



## 第三周

| **日期** |             **早**             |              **午**              |              **晚**               |  **复习内容**  | **完成度** |
| :------: | :----------------------------: | :------------------------------: | :-------------------------------: | :------------: | :--------: |
| 9月19日  |      vue3 composition API      |             ref对象              |    方法，计算属性，响应式语法     | 三次握手的过程 |    90%     |
| 9月20日  |   Vue基础深入之介绍、响应式    |          Vue3使用Proxy           |        Vue中实例方法、指令        |      UDP       |    90%     |
| 9月21日  | Vue中事件处理函数绑定、v-model | Vue中自定定义一个表单控件、watch | Vue中计算属性、过滤器、自定义属性 |   HTTP&HTTPS   |    80%     |
| 9月22日  |      Vue中生命周期、组件       |  Vue中Render函数、父子组件传值   |          Vue中插槽的使用          |  HTTP协议版本  |    90%     |
| 9月23日  |          Vue渲染机制           |             渲染函数             |                JSX                |      报文      |    90%     |
| 9月24日  |          Dom Diff算法          |           Vue应用配置            |             路由控制              | 请求头和响应头 |    80%     |
| 9月25日  |              复习              |               复习               |               复习                |      复习      |    80%     |



**知识整理：**

- `hooks `是 `vue3 `底层提供的钩子实现函数方式(不像 `vue2 options API`)，开发者只需写提供钩子里面的逻辑。
- 基于函数抽离的组合各种方法函数实现高内聚的情况(2.0 有横向拆分，各个组件都有如 `data，method,computed`)。
- **`CompositionAPI`** 解决问题是`vue 2.0`中当组件变得庞大复杂起来后，代码可阅读性降低。
- **_什么时候使用`CompositionAPI`?_**
  - 希望有最理想的 `TypeScript `支持
  - 当组件的内容变得庞大复杂起来的时候，并且希望通过功能来管理组件
  - 可能会有一些想要在不同的组件里使用的代码(代码复用)
  - 团队倾向新的`CompositionAPI`
- **`vue2.0`代码复用的三种方式:**

  1. `mixin`提取公共代码到数组管理
  2. `Mixin Factories`工厂
  3. `Scoped Slots`作用域插槽方式
- `reactive()` 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。为此，Vue 提供了一个 `ref()` 方法来允许我们创建可以使用任何值类型的响应式。
- 计算属性来描述依赖响应式状态的复杂逻辑供模板视图使用。
- 计算属性缓存和方法机制的不同，不同之处在于**计算属性值会基于其响应式依赖被缓存**。
- 一个计算属性仅会在其响应式依赖更新时才重新计算。
- 计算属性无论多少次访问，都会立即返回先前的计算结果，而不用重复执行`getter`函数。
- 响应式是组件状态都是由响应式的 JavaScript 对象组成的。当更改它们时，视图会随即自动更新。
- Vue 的渲染系统是基于虚拟 DOM概念构建的。一个运行时渲染器将会遍历整个虚拟 DOM 树，并据此构建真实的 DOM 树。这个过程被称为**挂载** (mount)。
- 如果我们有两份虚拟 DOM 树，渲染器将会有比较地遍历它们，找出它们之间的区别，并应用这其中的变化到真实的 DOM 上。这个过程被称为**更新** (patch)。
- 虚拟 DOM 带来的主要收益是它让开发者能够灵活、声明式地创建、检查和组合所需 UI 的结构，同时只需把具体的 DOM 操作留给渲染器去处理。
- `render`函数目的是把虚拟`dom`转为真实`dom`的渲染行为，在`vue`组件中会提取模板`template`(字符串)去编译模板。
- 在浏览器中它无法识别`vue`的指令，此时需要优化，首先将模板转为`AST`语法树，再优化`AST`树，将浏览器不能识别的指令转为逻辑，将优化后的`AST`结构树转为虚拟`dom`，通过渲染函数转为真实`dom`。
- `h`函数创建返回的是`VNode`虚拟节点，多个虚拟节点就会组成虚拟`dom`树，对真实`dom`的描述。
- JSX 是 ECMAScript 的类似 XML 的语法扩展，没有任何定义的语义。它不打算由引擎或浏览器实现。**这不是将 JSX 纳入 ECMAScript 规范本身的提议。**它旨在供各种预处理器（转译器）使用，以将这些标记转换为标准的 ECMAScript。
- JSX目的是为定义具有属性的树结构定义一种简洁且熟悉的语法。通用但定义良好的语法使独立的解析器和语法高亮器社区能够符合单一规范。
- 在浏览器中，操作`dom`需要耗费性能的，尽可能的减少操作`dom`可以保证性能。
- Dom Diff 比对(`diff`)渲染更新前后产生两个虚拟`dom`对象的差异，并产出差异补丁对象，再将差异补丁对象应用到真实`dom`节点上。
- **`Dom Diff`算法的特点：**
  - 平级对比，如`ul`对`ul`，不跨级对比
  - 里层元素只是位置顺序不一样，但是内容一样时不会重新渲染
  - 深度优先，从外到内嵌套比对



## 第四周

| **日期** |                  **早**                  |                  **午**                  |                **晚**                |    **复习内容**     | **完成度** |
| :------: | :--------------------------------------: | :--------------------------------------: | :----------------------------------: | :-----------------: | :--------: |
| 9月26日  |        ECMA、编程语言、变量、JS值        | 语法、规范、错误、运算符、判断分支、注释 | 循环、引用值初识、显示及隐式类型转换 | 串行连接/持久化连接 |    80%     |
| 9月27日  |          函数基础与种类、形实参          |              映射、变量类型              |           参数默认值、递归           |   管道话持续连接    |    80%     |
| 9月28日  |           预编译、暗示全局变量           |         作用域、作用域链、预编译         |   闭包基础、立即执行函数、闭包深入   |   Content-Length    |    90%     |
| 9月29日  |           逗号运算符、闭包高级           |          对象、构造函数、实例化          |     构造函数及实例化原理、包装类     |       Referer       |    90%     |
| 9月30日  | 原型、原型链、闭包立即执行函数、插件开发 |                闭包与回调                |      原型与原型链深入、对象继承      |      请求方式       |    80%     |
| 10月1日  |          继承深入、call_apply、          |             圣杯模式、模块化             |          原型相关内容的总结          |    GET/POST区别     |    70%     |
| 10月2日  |                   复习                   |                   复习                   |                 复习                 |        复习         |    50%     |



**知识整理：**

-  脚本语言基于脚本引擎，通过脚本引擎的解释器来正常解析文本的过程。前后端都有脚本语言，如`JavaScript`客户端脚本，如`PHP`服务器脚本。 
-  ECMAScript包含语法，变量，关键字，保留字，值，原始类型，引用类型，运算，对象，继承，函数。 
-  JavaScript引擎是单线程，它可以模拟多线程，如单线程的机制是轮转时间片，短时间内轮流执行多个任务的片段。 

- `src`这个属性定义引用外部脚本的 URI，这可以用来代替直接在文档中嵌入脚本。指定了 src 属性的 script 元素标签内不应该再有嵌入的脚本。
- `type`属性定义`src`引用的脚本语言，如`text/javascript`，`application/javascript`，`text/tpl`定义错误的目的是可以使其标签脚本不执行，仅用来做模板文件使用。
- `async`属性可以使脚本文件异步执行，且同时解析文档加载。
- `defer`属性通知浏览器该脚本将在文档完成解析后，触发 `DOMContentLoaded ()` 事件前执行。 有 `defer` 属性的脚本会阻止 `DOMContentLoaded` 事件，直到脚本被加载并且解析完成。
- `crossorigin`属性可以使用本属性来使那些将静态资源放在另外一个域名的站点打印错误信息。
-  JavaScript 语言是动态语言也是脚本语言也是解释型语言也是弱类型语言(根据值的类型成为被赋值的变量)。Java 语言是静态语言也是编译型语言也是强类型语言。 
-  逻辑运算就是与或非。与是`&&`，或是`||`，非是`!`。假包括：`undefined`，`null`，`NaN`，`空字符串`，`0`，`false`，除了这些以上假的都为真。 
-  当`&&`前面和后面都满足条件才能使`if`语句(为真)继续进入往下执行。 
-  当`||`前面或后面有一个能满足条件`if`语句(为真)条件就可继续进入往下执行。 
-  函数是固定的一个功能或者是程序块被封装的过程，实现一个固定的功能或程序需要在封装体中需要一个入口和一个出口，入口是参数，出口是返回值。 
-  **耦合**是代码块里有重复高的代码，编程的基本原则是遵循高内聚低耦合，让一个功能体(代码块)具有强功能性和高独立性。模块的单一责任制(独立完成功能且不依赖其他模块)。 
-  **高内聚**指开发时一个功能模块时，代码的相关性紧密，使得该模块的独立性强。 
-  **低耦合**是将重复代码抽象化组成一个独立的功能模块。  当遇到一个复杂功能的代码时，可以通过函数的方式去解耦合。 
- **形参**的作用是占位，形式上去占位。
- **实参**当调用的时候，有实际参数的赋值 。
- `arguments` 查询函数内部其实是知道实参的个数。返回一个像数组结构的参数列表，其实是一个类数组的参数列表。 
- 函数内部没有写`return`JS引擎会默认隐式加上。
- 函数内部`return`下面的语句是不会执行的。
- `return` 后面接数据会返回相应的数据值。
-  `callee`返回的是正在被执行的函数对象 。
- `caller` 返回调用所在的函数本身 。
- 在JavaScript中慎用递归，`for`循环也许会是更好的解决方案。函数自己调用自己，要考虑性能问题，找规律，找出口避免无限递归死循环。**总结**是总是走到出口的时候，再向上一步一步的**赋值计算**，然后返回结果。 
- **闭包**的常见形式：
  1. 函数的返回值是函数
  2. 返回的变量是函数
  3. 全局变量定义的闭包
  4. 函数的参数的方式
-  返回的闭包的函数上下文里面的属性称为**私有属性**，通过对象形成闭包。 
- IIFE 自动执行，执行完成以后立即销毁。**作用**是初始化函数。 
-  通过`new`关键字去实例化一个对象。用系统内自带的构造函数创建出的一个对象实例，与对象字面量创建的对象是相等的。 
-  在项目中的自定义构造函数会大量使用，涉及到模块化，插件化，组件化会使用到自定义构造函数。自定义构造函数是一般区别于普通函数是大驼峰写法。相当于一个构造工厂，必须`new`实例才能存在`this`。 
-  一旦执行构造函数，`this`就会存在，并指向`window` 。
-  一旦实例化构造函数`this`指向实例对象 。
- 实例对象的`__proto__`指向构造函数的原型，所有的对象都有自己的原型(包括原型本身)。
- 原型链是沿着`__proto__`去找原型里的属性一层一层的继承原型的属性的这条链。

