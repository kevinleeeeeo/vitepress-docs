## 第一周

| **日期** |               **早**                |                **午**                |                  **晚**                  |    **复习内容**    | **完成度** |
| :------: | :---------------------------------: | :----------------------------------: | :--------------------------------------: | :----------------: | :--------: |
|  5月2日  |                休息                 |                 休息                 |                   休息                   |        休息        |     0%     |
|  5月3日  |                休息                 |                 休息                 |                   休息                   |        休息        |     0%     |
|  5月4日  |           基础Vue组件封装           |            Vue路由的使用             |            Koa基础之基本使用             |    MongoDB 模型    |    90%     |
|  5月5日  |          Koa基础之基本使用          |           TS在Vue中的使用            |          Axios的基本使用（一）           | MongoDB 模型增删查 |    80%     |
|  5月6日  |        Axios的基本使用（二）        |     NodeJS中使用jwt进行身份验证      |        Vue动态组件、CSS3翻转动画         |    MongoDB 实例    |    80%     |
|  5月7日  | VueRouter介绍、两种模式、编程式导航 | 路由参数、查询参数、命名视图、重定向 | 过渡动效、滚动行为、导航守卫、路由懒加载 |    MongoDB 创建    |    80%     |
|  5月8日  |                复习                 |                 复习                 |                   复习                   |        复习        |    50%     |



**知识整理：**

- `vue`组件优点：提高开发效率，可重复使用，简化调试步骤，提升整个项目的可能性，便于协同开发
- 全局注册/局部注册写法
- 组件封装通信问题
- `vue-router`是基于路由和组件的
  - 路由用户设定访问路径的，将路径和组件映射起来
  - 在单页面应用中，页面的路径的改变就是组件的切换
- 在路径中使用一个动态字段来实现为路由参数
- 借助`router`实例方法来实现编程式路由导航
- 通过调用`this.$router.push`来访问路由实例实现跳转
- 命名视图：给`<router-view name="xxx"/>`组件命名
- 重定向：通过`routes`配置来完成`const routes = [{ path: '/home', redirect: '/' }]`
- 滚动行为：自定义路由切换时页面如何滚动
- 导航守卫：`vue-router `供的导航守卫主要用来通过跳转或取消的方式守卫导航
- 路由懒加载：实现动态导入取代静态导入对应的代码块



## 第二周

| **日期** | **早**                     | **午**                        | **晚**                        | **复习内容**    | **完成度** |
| -------- | -------------------------- | ----------------------------- | ----------------------------- | --------------- | ---------- |
| 5月9日   | Vuex之介绍、Getters        | Vuex之Mutations、Actions      | Vuex之模块                    | react概念       | 90%        |
| 5月10日  | react-redux                | react-redux                   | react-redux                   | react搭建       | 90%        |
| 5月11日  | Proxy与ES-14种对象操作方法 | Proxy与ES-14种对象操作方法    | Proxy与ES-14种对象操作方法    | react元素       | 90%        |
| 5月12日  | 观察模式-购物车案例        | 观察模式-购物车案例           | 观察模式-购物车案例           | ReactDOM        | 80%        |
| 5月13日  | 手写Promise之状态基本实现  | 手写Promise之状态基本实现     | 手写Promise之链式操作         | createElement   | 90%        |
| 5月14日  | 手写Promise之链式操作      | 手写Promise之rejected状态实现 | 手写Promise之rejected状态实现 | React.Component | 90%        |
| 5月15日  | 复习                       | 复习                          | 复习                          | 复习            | 80%        |



**知识整理：**

-  `Getters`会暴露为 `store.getters` 对象，可以以属性的形式访问定义的值 

-  `getter`属性让其返回一个函数，来实现给 `getter`传参,对 `store`里的数组进行查询时非常有用 

-  `mutation` 更改 `Vuex`的 `store`中的状态的唯一方法是提交 `mutation` 

-  每个 `mutation`都有一个字符串的**事件类型 (type)**和一个**回调函数 (handler)** 

-  `Action`提交的是 `mutation`，而不是直接变更状态 

-  `module`可以 `Vuex`允许我们将 `store`分割成**模块（module）**。每个模块拥有自己的 `state`、`mutation`、`action`、`getter`、甚至是嵌套子模块——从上至下进行同样方式的分割 

-  关于派发器的由来：在`vue`中强规范的`template`,`script`,`style`的固定写法，存在弱点，在`method`里的业务逻辑实现时写了大量的紧耦合的方法，利用派发器的机制横向切割的方式实现抽离`script`里的`methods`代码编写区域出去(松耦合) 

-  **派发器如何实现抽离？**
  派发器根据一个又一个的事情来指定一个`type`，`type`的作用是遇到`type`对应的事情就触发一个方法的执行，每件事所对应的方法集合是根据每件事情的`type`去触发的 

-  派发器的作用：  派发器(`dispatcher`)根据`action`里面的`type`去调用相应的`method`方法 

-  `redux`**和派发器有什么关系？**
  基本原理一致，但有一点不同，不同页面的组件想拿到数据状态是不同的，`redux`可以解决 

-  **数据状态存放在**`**localStorage**`**有什么弊端？**
  `localStorage`是不联动的，状态变更也不会导致所有页面马上发生变更 

-  **为什么大部分场景都没有必要用**`**redux**`**?**
  目前开发的所有单页面应用组件是属于重新加载组件的过程(`componentDidMount`)，当组件关闭时,它不是`alive`的，并且有许多方法可以避免使用`redux` 

-  **有什么情况必须要用到**`**redux**`**?** 

-  页面组件是`alive`的，它不能触发组件加载(`componentDidMount`),就需要中央管理状态机制 

-  在`react native`开发中某些页面(`alive`) 

-  **为什么需要两个子模块分开处理？**
  因为如果两个模块一起编写，在修改其中模块时会影响另一个模块，而且不方便维护，且逻辑之间杂乱不清 

-  **两个分开模块之间如何实现数据联动管理？**
  利用观察者模式实现管理数据更新 

-  **观察者原理：**
  每一个观察者实际上是一个函数，一旦触发事件，执行一个函数完成一个程序，当一个程序分为1，2，3件事情，那么这个程序就为一个`observers`，当执行程序123(`observers`)时不能单独执行，利用`obsevers`里面的`notify`通知特性，将123一次性执行，真正事件触发时仅仅执行的是`notify`函数
  也就是说，希望123函数作为一个个`obsevers`放入数组里，统一用`notify`一次去执行，在项目里，点击单击事件时触发执行`notify`函数，然后`notify`里面所有的`observers`会依次执行 



## 第三周

| **日期** | **早**             | **午**             | **晚**             | **复习内容** | **完成度** |
| -------- | ------------------ | ------------------ | ------------------ | ------------ | ---------- |
| 5月16日  | 数组方法的总结1    | 数组方法的总结2    | 数组方法的总结3    | JSX          | 90%        |
| 5月17日  | 正则1              | 正则2              | 正则3              | 组件         | 90%        |
| 5月18日  | 原型链、继承、类   | 原型深入           | 浏览器控制台       | props        | 90%        |
| 5月19日  | 严格模式           | 严格模式           | 派发器             | 组件渲染过程 | 80%        |
| 5月20日  | 派发器             | 状态模式           | 状态模式           | 组合组件     | 80%        |
| 5月21日  | 享元模式和性能优化 | 享元模式和性能优化 | 享元模式和性能优化 | props校验    | 80%        |
| 5月22日  | 复习               | 复习               | 复习               | 复习         | 50%        |



**知识整理：**

- **严格模式设计的目的：**

  - 减少语法层面的不合理
  - 不严谨
  - 不安全
  - 怪异行为

- 在严格模式下的区别有：

  - 变量层面
    - 全局变量声明时必须用`var`，否则使用严格模式时变量为`undefined`
    - 保留字和关键字不允许使用，如`var eval`
    - 全局变量的`delete`操作符失效问题(静默失败)，通过报错方式解决
  - 对象层面
    - 对象属性描述符造成的操作失败的问题(静默失败)，报错
    - `for...in`循环不会报错
  - 函数层面
    - 函数参数需要唯一的
    - 形参实参就没有相互映射关系
    - `caller`和`callee`会报错
    - `arguments.callee`指的是调用函数本身
    - `函数名称.caller`是函数属性，它指向当前调用函数的作用域
    - `eval`和`with`语句报错

- **派发器的思维模式**

  分组件，子组件，功能1,2,3, 希望集中管理而不去调用，通过接口的**任务类型**统一去派发，派发之后执行某一个任务，相当于把功能集成起来，使用派发接口时不用管如何实现，也不用管具体任务

- 状态模式：将一个类抽象多个状态的类，这些类和主类保持了继承关系和依赖关

- **什么是`solid`设计原则？**

  - 单一职责原则(胖函数减肥)
  - 开放封闭(拓展开发修改)
  - 里氏替换
  - 接口开放
  - 依赖倒置



## 第四周

| **日期** | **早**              | **午**             | **晚**             | **复习内容** | **完成度** |
| -------- | ------------------- | ------------------ | ------------------ | ------------ | ---------- |
| 5月23日  | 享元模式和性能优化  | 享元模式和性能优化 | 函数组合、结合律、 | state        | 90%        |
| 5月24日  | pointfree、实用案例 | 高阶函数           | 柯里化             | 单项数据流   | 90%        |
| 5月25日  | 偏函数              | 惰性函数           | 缓存函数           | setState     | 90%        |
| 5月26日  | 防抖                | 节流               | 归类               | 事件         | 70%        |
| 5月27日  | 扁平化              | 结合律             | 响应式             | 事件传参     | 90%        |
| 5月28日  | 工厂模式            | 工厂模式           | 工厂模式           | 列表渲染     | 50%        |
| 5月29日  | 复习                | 复习               | 复习               | 复习         | 60%        |



**知识整理：**

- **什么是高阶函数？**

- 只要函数的参数是函数，或者返回值是函数的形式时，都成为高阶函数

- **高阶函数具体有什么应用场景？**

  - 能够将代码划分为若干片段，然后按顺序执行
  - 将功能或复用的业务能够抽离成一个函数，如参数是函数的形式(`axios`的封装)
  - 一个函数只能做一件事情(单独的业务功能)，如具有高度相似业务逻辑的工具函数的再封装(返回值是函数的形式)

- **函数的短板？**

- 函数作为另外函数的参数，函数赋值遍历，函数作为返回值，操作比较繁琐，需要通过指针，代理的方式实现。

- **面向对象与函数式编程的关系**

  - 面向对象：适用于高度复用场景，有复杂`this`指向问题
  - 函数式编程的优点：易读易维护
  - 函数式编程是第一类对象，不依赖任何其他对象独立存在(概念)

- **函数组合：**

- 若干个纯函数，偏函数，柯里化函数组合成一个新的函数形成数据传递，并实现一种有序执行的效果

- **左倾方式：**

- 函数参数自右向左边执行函数的方式

- 结合律是在组合函数的参数中再进行分组，它和原来函数组合得出的结果是一样的

- 柯里化：接受多个参数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

- 偏函数：部分应用，在计算机科学中，偏函数叫做部分应用，局部应用，指固定一个函数的一些参数，然后产生另一个更小元的函数，实际上是一种降元的过程

- 惰性函数：适用于底层代码封装，程序优化等方面，优化函数本身，函数内部改变自身的机制

- 缓存函数：函数优化的一种方式

- 防抖：实现延迟执行，防止用户交互时产生多次触发

- 节流：事件被触发，`n`秒之内只执行一次事件处理函数

- 归类：数据归类技术，前端处理后端接口数据

- 扁平化：将多维数组变为一维数组

  



