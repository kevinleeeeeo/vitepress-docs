## 第一周

| **日期** |            **早**             |           **午**            |               **晚**                | **复习内容**  | **完成度** |
| :------: | :---------------------------: | :-------------------------: | :---------------------------------: | :-----------: | :--------: |
| 10月31日 | 搭建环境、阅读Promises A+规范 |    完成一个基本的Promise    | 处理Promise中的异步与多次调用的问题 | 内联块级元素  |    90%     |
| 11月1日  | 原生Promise链式调用的特性总结 | 解决Promise的链式调用（1）  |     解决Promise的链式调用（2）      |   meta标签    |    90%     |
| 11月2日  | 实现resolve与reject的静态方法 |       实现Promise.all       |         实现Promise.settle          |     视口      |    80%     |
| 11月3日  |   实现Promise.race与finally   | 实现promisify与promisifyAll |    generator实现与babel编译实现     |    import     |    80%     |
| 11月4日  |  generator+co实现async+await  |  事件环相关的基本概念认知   |  事件环的运行流程与基本案例的分析   |     link      |    80%     |
| 11月5日  |        事件环分析训练         |       事件环分析训练        |           事件环分析训练            | 兼容/标准模式 |    80%     |
| 11月6日  |             复习              |            复习             |                复习                 |     复习      |    70%     |



**知识整理：**

- `promise`是一个对象或一个函数，带有遵守规范的`then`方法。

- `thenable`是一个可往下执行的对象或函数并定义一个`then`方法。

- `value` 值是一个合法的`JavaScript`的值包括`undefined`/`thenable`/新的`promise`。

- `exception`是一个值，另外是一个抛出的异常。

- `reason`一个值，指示为什么造成失败或拒绝的值。

- `Promise`有三个状态(等待`pending`, 被满足`fulfilled`, 拒绝`reject`)。

- `promise`必须提供一个`then()`方法去访问它当前值/最终值/原因，`then()`方法接收两个参数(均为函数)

- `onFulfilled`: 必须作为函数被调用(不可用`this`代替)，不是函数时会被忽略掉，必须为异步不阻塞程序向下执行。

- `onRejected`: 必须作为函数被调用(不可用`this`代替)，不是函数时会被忽略掉 ，必须为异步不阻塞程序向下执行。

- 以上两个参数都是可选填写。

- 如果参数是函数时，在`fulfilled`或`rejected`状态时才能执行且只能执行一次。

- 转为成功态或失败态之前是不可以调用的。

- 传值， `resolve(123)`该传值是` promise.then(res => console.log(res))`里`then()`的第一个参数里函数里的形参。

- `then()`可以被多次调用，链式调用，调用时里面的函数参数是依次顺序调用。

- 当`promise`是成功态的时候，所有各自的`onFulfilled`的回调函数必须按原有的调用顺序来执行。

- 当`promise`是失败态的时候，所有各自的`onRejected`的回调函数必须按原有的调用顺序来执行。

- generator重要的意义是可以封装一个异步的迭代函数实现异步迭代功能。它是一个生成器函数，生成一个东西(对象)的函数。

- 迭代器对象`iterator`，`yield`是一个暂停标识，每次执行一次next方法会产出一个值。

- 它最大的好处是异步迭代。假如读取文件的同步操作进行异步化处理。当读取文件后返回的结果通过`yield`停止不往下异步执行。期间并对获取的结果进行`json`处理，且进行额外的操作如根据传入的`uid`进行数据过滤。此时仍通过`yield`暂停并接收读取另外一份数据表。最后并对获取的两份结果进行组装输出新的数据结果。

- 嵌套写法非常的难以管理和阅读，希望这个异步迭代过程是通过一个函数去完成CO库，主要是完成异步迭代的，可以通过这个过程去获取最终的结果。

- `CO`函数它的参数是一个`generator`生成的迭代对象，返回值是一个`promise`实例对象。另外需要定义一个递归的函数需要对每次迭代进行递归执行，该递归函数接受一个上层嵌套获取的数据，从而无限`then`获取新的数据直到获取最终的数据。

- 其实`yield`关键字看起来有点像`await`。将上面应用的`yield`改造成`await`的写法，成为一个异步函数。

- 侧面说明了，生成器函数加上yield加上CO异步迭代函数就相当于async函数加上await关键字。

  

## 第二周

| **日期** |         **早**         |       **午**       |          **晚**          | **复习内容** | **完成度** |
| :------: | :--------------------: | :----------------: | :----------------------: | :----------: | :--------: |
| 11月7日  |     事件环分析训练     | 宏任务与微任务专题 | setImmediate与setTimeout | html5新特性  |    90%     |
| 11月8日  |     MessageChannel     |    postMessage     |  requestAnimationFrame   |   新增属性   |    90%     |
| 11月9日  |        nextTick        |   nodejs基本认知   |     nodeji擅长做的事     |   新增标签   |    80%     |
| 11月10日 | js单线程与多线程的对比 |     同步与异步     |       阻塞与非阻塞       |   Cookies    |    70%     |
| 11月11日 |        node系统        |   事件环基本认知   |         运行流程         | Set-cookies  |    70%     |
| 11月12日 |      基本案例分析      |    复杂案例分析    |        事件环总结        |   History    |    80%     |
| 11月13日 |          复习          |        复习        |           复习           |     复习     |     0%     |



**知识整理：**

- 宏任务是浏览器规定的一些 WebAPIs，而微任务是ES6语法规定的，如`promise.then()`。
- 创建线程的目的是**为了实现异步的执行条件**。区分宏任务和微任务主要是实现优先级的问题，微任务实际上是优先级要高于宏任务，每一次微任务在执行队列里的任务执行完毕后要清空微任务当前任务队列，也就是先对微任务进行处理，然后去渲染，去执行宏任务。
- `Promise.then`优先于下一个宏任务去处理的原因是需要跟后续代码保持异步关系。
- `setImmediate`有点类似`setTimeout`，用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。
- 在`vue`中，使用`setImmediate`会比使用`setTimeout`会是一个更好的选择，在宏任务里，使用`setTimeout`会有一些怪异的行为。
- MessageChannel在通信方法具有一定的作用，创建一个新的消息通道，并通过它的两个MessagePort属性发送数据。
- 可以通过这两个端口的`postMessage`方法来发送信息。`onmessage`方法可以绑定事件获取信息。
- `requestAnimationFrame`，请求一个动画帧，告诉浏览器希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
- 当调用`requestAnimationFrame`方法时会传入一个函数，该函数来定义动画的实现过程。移动导致的重绘，并在重绘之前执行，并且每次重绘都会执行一次。
- `requestAnimationFrame`与`setTimeout`的区别是`setInterval`回调有多少次dom操作，就会进行多少次计算和绘制。
- `requestAnimationFrame`会把所有dom操作集中起来，一次性进行统一的计算和绘制，性能要更好。
- 在窗口最小化时，`setInterval`会一直执行回调函数，`requestAnimation`会暂停程序，页面打开时从暂停的时候重新开始。`setInterval`当计时时间间隔小于刷新率时导致无意义的回调执行，而`requestAnimationFrame`就不会。
- `process.nextTick`在node环境中的方法与vue的用法是一致的。它是微任务，而且优先于`promise.then`的执行。
- MutationObserver提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。
- 在vue1.0版本利用它做`nextTick`方法。在模块化的各个文件中通过导出`port2`，其他模块导入使用`port`来实现通信。
- 除了浏览器环境的事件环，node也有相应的事件环。node的11及以上版本或与浏览器的结果一样。但仍有不同的地方。
- 浏览器的常见宏任务有`<script>`脚本，UI渲染，用户交互事件，Ajax，`setTimeout`，`setInterval`，`requestAnimation`，`messageChannel`,`setImmediate`在IE新版本和EDGE和NodeJS的0.1以上版本支持，但在新版浏览器里是没有的，`window.setImmediate`显示`undefined`，其实可以通过兼容性解决。
- 微任务有`promise.then`，`mutationObserver`监听dom变化，NodeJS上的`process.nextTick`，`vue.$nextTick`具有时效性，利用宏任务和微任务滞后的特性完成一个同步化的程序。
- node事件环不像浏览器的事件环是一个真正的环，它把所有的任务事件都分配到不同的阶段，在宏任务基础上进行从上到下不停的执行直至每一个阶段都没有任务了，node环境不存在微任务队列只有宏任务队列，而宏任务队列分为Timers，Poll，Check阶段。
- **Timer队列**，只执行`setTimeout`和`setInterval`，但是他们的callback不会执行，而是推到宏任务的队列之中。
- **Poll队列**，会先执行符合条件的微任务，比如Promise的异步完成，如果是`setImmediate`，则只会执行，不执行他的callback，然后执行定时器的callback，比如timeout。这里会适当得暂停一会，看看会不会有新任务进入队列。如果有`setImmediate`的callback则进入Check 阶段，否则回到Timer继续新一轮循环。
- **Check队列**，当Poll阶段的队列完成，则会轮到Check，这时会执行`setImmediate`的callback。如果没有需要关闭callbacks，那么就回到Timer继续新一轮的循环。



## 第三周

| **日期** |          **早**          |          **午**          |        **晚**        | **复习内容** | **完成度** |
| :------: | :----------------------: | :----------------------: | :------------------: | :----------: | :--------: |
| 11月14日 |     回调函数深度认识     |      回调和异步问题      |      原生JS策略      |  WebWorkers  |    90%     |
| 11月15日 |   代理模式封装表单验证   |   代理模式封装表单验证   | 代理模式封装表单验证 |  WebSocket   |    90%     |
| 11月16日 |  Vue策略及代理模式封装   |  Vue策略及代理模式封装   |  ReactHooks策略模式  |   地理位置   |    80%     |
| 11月17日 |    ReactHooks策略模式    |   回调实现watcher功能    | 回调实现watcher功能  |    Canvas    |    80%     |
| 11月18日 | 表格操作的封装自定义指令 | 表格操作的封装自定义指令 |    课程表排课系统    |     SVG      |    90%     |
| 11月19日 |      课程表排课系统      |      课程表排课系统      |    课程表排课系统    |   History    |    80%     |
| 11月20日 |           复习           |           复习           |         复习         |     复习     |    50%     |



**知识整理：**

- 回调加闭包是一个高阶函数，当一个函数作为另外一个函数的参数是，这叫回调函数。
- 回调传参的目的是帮助回调函数完成接下来的任务。依赖函数可以与本函数无关，本函数可以给回调函数提供参数。
- 本函数的执行意味着回调函数可以在本函数程序中任意地方进行执行(同步化)。本函数并不关心回调函数的逻辑。
- 回调其实是本函数的扩展，本函数完成一部分固定的程序任务，回调函数完成一个不固定的程序任务。回调函数的封装可以在集成特定功能的前提下，提供接口进行各种程序编写。
- Async await写法可以使异步任务保持同步化关系，它会形成阻塞，直到拿到结果才会继续后续程序，假如有错误时，需要try..catch来捕获错误。
- 原生JS策略模式以及代理模式封装一个表单验证。获取表单相关的元素，表单里所有的值的临时保存。
- 使用策略模式定义相应的校验规则，策略可以解决一个对象里通过key拿到想要的数据，不需要遍历或其他方法实现。



## 第四周

| **日期** |      **早**       |        **午**        |       **晚**        | **复习内容** | **完成度** |
| :------: | :---------------: | :------------------: | :-----------------: | :----------: | :--------: |
| 11月21日 |       循环        |         迭代         |     遍历，枚举      |     let      |    90%     |
| 11月22日 | vue项目构建的方式 |   DOM初探、JS对象    | XML、幻灯片案例展示 |    const     |    90%     |
| 11月23日 |   document对象    |    获取元素、节点    |       遍历树        |   kiss原则   |    90%     |
| 11月24日 |  节点属性、方法   |  封装方法、DOM结构   |    节点创建删除     |  暂时性死区  |    90%     |
| 11月25日 | 元素属性设置获取  |       节点属性       |      日期对象       |  块级作用域  |    80%     |
| 11月26日 |      计时器       | 日期对象与计时器练习 |    数学取整方法     |   解构赋值   |    80%     |
| 11月27日 |       复习        |         复习         |        复习         |     复习     |    30%     |



**知识整理：**

- 循环是计算机底层提供的一种多次运行同一程序的一种功能，`for`循环是这种功能的接口。
- 迭代的存在必须建立在遍历循环的基础上，每一次遍历的过程中的每一个部分叫做一次迭代，它是**有序**的。
- 遍历是针对一组数据而进行的按顺序抽取的行为。
- 枚举是概率学上的一个名称，分为单次枚举和多次枚举，把一个集合中的**无序**状态的成员逐一抽取的过程。
- 循环机制和循环方法的区别，循环机制如`for`仅仅是一个机制，可以提供`break`，`continue`，`return`控制循环的功能，它不参与数据的读取和修改。`forEach`是一个遍历方法，它针对于数据，并确保遍历过程的完整性，所以从职能来讲，`forEach`并不能具备循环机制的功能。
- 数组和字符串是有序列表的，数据意义来自于顺序，它可以迭代。
- 对象是无序列表，不可以迭代。类数组最早用于DOM，具有顺序的一种对象结构，但同时也有数组的操作方法和索引。
- Document Object Model 文档对象模型，它本身是一个对象，又叫宿主对象，浏览器本身封装文档对象模型并提供一系列的相关接口和方法集合并从中找到相应的方法去处理一些问题。
- DOM存在的目的通过浏览器提供的这一套方法(JavaScript语法)可以去操作HTML和XML文档，DOM无法操作CSS，它能改变样式是通过操作DOM元素里的`style`属性，给属性增加了内联样式，内联样式的优先级高于外部样式表并将其覆盖。
- **JavaScript有三种对象**，本地对象和内置对象都是ECMAScript内部对象，宿主对象。
- 浏览器对象有window的所有方法都在BOM对象里，document所有的方法都在DOM对象里，实际上BOM包含DOM，拆分出来的原因是DOM有W3C规范，而BOM没有的原因是浏览器之间的运行方式和方法实现是不同的，所以不同浏览器之间会存在不同的BOM对象从而无法实现统一的标准和规范，导致开发者需要在不同浏览器做相应不同的兼容性。
- 关于`querySelector`& `querySelectorAll`，他两性能比较低，因为有临时缓存导致数据不实时更新，业务场景下应少用。
- 遍历节点树即为元素节点树，节点不是元素，节点包含元素。
- `Node.childNodes`查找子节点集合，它包括文本节点，元素节点，还有注释节点。
- `Node.nodeName`查看节点名称。节点名称，发现无法更改，只读。
- `Node.nodeValue`返回当前节点的值，值只能是字符串的文本或注释内容。
- `Node.nodeValue`也可以获取属性的值，跟`value`的结果一致。节点的值是可以更改的。
- `Node.nodeType`可以查看节点类型。
- `Element.attributes`返回一个元素属性的结合。
- `Element.getAttributeNode`返回指定元素的指定属性节点。可以通过索引访问，也可以通过属性名去访问，访问属性的值时需要`Node.nodeValue`或者`value`拿到。返回的属性节点是可以更改值的。
- document的原型是HTMLDocument，HTMLDocument的原型是Document，Document的原型是Node，Node的原型是EventTarget，EventTarget的原型是Object。Object的原型是Object.prototype。
- 节点的创建方法仅存在`Document`，不存在`Elemnet`和`HTMLElement`的原型上。`document`创建的节点引用临时存放在内存里，还没有挂载到DOM树上。
- `Node.appendChild`总是在父级元素的子节点列表的最后面。
- `Node.appendChild`不仅有增加节点，还有剪切节点的功能。剪切功能能动态的改变dom结构，有着非常重要的作用。
- `Node.insertBefore`，在父级`c`节点下的子节点`b`之前插入`a`节点。
- `Node.insertAfter`方法，原理是找到下一个兄弟节点并插入在其前面，需要先排除父节点列表里的非元素节点，如果没有下一个兄弟节点时，可以直接`Node.appenedChild`进去。
- `Node.removeChild`的移除子节点的写法是父节点调用执行，子节点作为参数传入。实际上从dom树上移除节点，但是没有真正的在内存中进行回收销毁，被移除的节点仍然保存在内存中。
- `Node.remove`销毁的写法是需要销毁的节点调用执行，不用传入参数，节点删除并销毁不会存入内存中。
- 设置`innerHTML`内的值，会覆盖原来的字符串内容。使用`+=`语法可以追加内容，同样可以解析内容为html的内容。
- 父节点内的`innerText`内容，它会过滤所有标签，仅仅打印文本内容。同样`+=`语句可以追加内容，但是追加html内容时只打印字符串而不会去解析html标签，原因是它将`<`或`>`解析为字符实体`&lt;`或`&gt;`。
- HTML5中获取元素自定义属性如`data-xxx`。可以通过`HTMLElement.dataset`属性去拿到(网页兼容性不及移动端，IE9及以下不支持)，也可以通过`ELement.getAttribute`方法去拿到。
- `Document.createDocumentFragment`方法创建一个空白的文档片段。每次循环都新增插入节点元素，给浏览器渲染进程增加了负担，大量消耗性能，最好只进行一次回流操作。把循环计算好的的节点插入到文档片段，再将文档片段最终插入文档中。
