# 学习计划

## 第一周

| **日期** |            **早**            |            **午**            |              **晚**               | **复习内容** | **完成度** |
| :------: | :--------------------------: | :--------------------------: | :-------------------------------: | :----------: | :--------: |
| 11月28日 |        滚动距离与高度        |      兼容模式，可视尺寸      |           读写样式属性            |   对象简写   |    90%     |
| 11月29日 |       日期对象、计时器       |     日期对象与计时器练习     |           数学取整方法            |   箭头函数   |    90%     |
| 11月30日 |   滚动距离与高度、兼容模式   |           可视尺寸           |     操作伪元素、元素运动初探      |   this指向   |    80%     |
| 12月1日  | 冒泡捕获流、事件与事件源对象 |           事件委托           |         自动阅读插件开发          |     rest     |    80%     |
| 12月2日  |      模块化开发Todolist      |     面向对象开发Todolist     |    鼠标行为坐标系、pageXY封装     |  展开运算符  |    90%     |
| 12月3日  |         拖拽函数封装         | 鼠标事件深入、点击与拖拽分离 | 双击事件,状态改变事件、京东搜索框 |  函数名拓展  |    90%     |
| 12月4日  |             复习             |             复习             |               复习                |     复习     |    60%     |



**知识整理：**

- 实例化日期对象。直接打印实例化的对象和直接执行`Date`都会打印时间。`Data`的原型的原型是`Object`。集成了`OBject.toString`方法。
- `Date.prototype.getTime()`返回一个时间的格林威治时间数值 (时间戳)。表示从 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC，即协调世界时）距离该日期对象所代表时间的毫秒数。可以利用两个时间差来做很多事情。
- 当`new Date`实例化传入时间戳参数时就会返回该时间戳对应的时间的格林威治时间数值。它与`Date.prototype.setTime()`设置实例对象的时间的结果一致。
- `Date.prototype.getDate()`返回一个月中的哪一日（1-31）。
- `Date.prototype.getDay()`返回一周的第几天，0 表示星期天。(0-6)
- `Date.prototype.getMonth()`返回返回一个指定的日期对象的月份。月份是实际月份-1。 (1-12)
- `Date.prototype.getFullYear()`根据本地时间返回指定的年份。
- `Date.prototype.getMinutes()`返回本地时间的分钟数。(1-59)
- `Date.prototype.getMilliseconds()`返回本地时间的毫秒数。(0-999)
- 滚动距离返回文档在窗口左上角水平和垂直方向滚动的像素。
- 常规滚动条的距离有`Window.pageXOffset`和`Window.pageYOffset`属性相等于`scrollX`和`scrollY`属性(不常见)，IE9/IE8 及以下不支持，支持的属性对应是`document.body.scrollLeft`和`document.body.scrollTop`。对应`document.documentElement.scrollLeft`和`document.documentElement.scrollTop`属性也同样支持。
- 浏览器有自己各自的兼容模式如怪异模式和标准模式，浏览器本身具有向后兼容的机制。怪异模式是厂商自己定义的标准，标准模式是w3c的标准。
- 获取浏览器可视区域的尺寸(窗口的尺寸宽高)。`clientWidth`不包含滚动条，`innerWidth`包含滚动条。
- `document.body.scrollWidth`获取页面的宽度和高度，也可以获取一个盒子的宽度和高度`div.scrollWidth`。
- 如页面宽高的数值比可视窗口还大时，会显示滚动条，实际上溢出看不见的部分也是页面的内容。可以理解为滚动条滚动距离加上可视窗口大小就等于页面(或一个大盒子)的宽高。
- `Element.getBoundingClientRect`方法返回一个`DOMRect`对象，该对象包含盒子的大小和相对于视口的位置信息。
- 兼容性问题，在IE浏览器里，`DOMRect`对象并没有`width`和`height`属性。但是还是可以通过计算来获取宽高的值，如盒子宽度`width = right - x`。
- `Element.getBoundingClientRect`方法还存在一个不实时的问题，所以少用。
- `HTMLElement.offsetTop`或`HTMLElement.offsetLeft`返回相对于父元素节点顶部内边距(左或上)的距离。
- `HTMLElement.offsetParent`返回一个有定位的父级元素。假如给子元素和父元素都定义了定位，当查找子元素的`offsetParent`时，返回父元素节点。
- 操作滚动条的方法有`window.scroll`和`window.scrollTo`，滚动到多少跳至目标位置，返回值默认是`undefined`。
- 通过某个事件而产生的效果，叫绑定事件处理程序，也叫事件处理函数。事件是节点元素天生具备的特性。绑定事件等于绑定事件的处理函数而不是绑定事件本身。事件不需要绑定的，而绑定的是一个反馈效果，该反馈效果由处理函数去做的。
- 事件句柄的绑定事件处理函数的方式，为某一个HTML元素指定了一个JS事件句柄等于一个函数的形式。此绑定的方式的缺点某个元素的一个事件只能绑定一个处理程序，再次绑定的程序会覆盖上一次绑定的程序。
- 事件源是一个对象，事件所作用在某个元素的身上，该元素就是事件源。注册事件监听器。IE9 及以下不兼容(w3c 标准)，且可以给同一事件源绑定多个事件。
- 描述从页面中接收事件的顺序，和冒泡或捕获相关。
- IE 提出事件冒泡流Event Bubbling。
- 网景 Netscape 提出事件捕获流 Event Capturing。
- 事件捕获流与冒泡行为相反。如果事件源顶层父级有相同事件源 ，优先执行父级的事件处理程序，然后接着向内执行子级的事件处理程序。
- 当同时定义了冒泡和捕获时，事件流就分为三个阶段。
  - 事件捕获阶段(默认不执行)
  - 处于目标阶段(触发时候) 按照先后顺序执行事件处理函数
  - 事件冒泡阶段
- 事件代理的核心是事件对象`event`，IE对应的是`window.event`，和事件源对象`event.target`。火狐只有`event.target`，IE只有`srcElement`。
- `clientX/Y` :鼠标位置相对于当前可视区域的坐标(不包括滚动条的距离)。
- `pageX/pageY`：鼠标位置相对于当前文档的坐标(包含滚动条的距离), IE9 以下不支持。
- `screenX/Y`：鼠标位置相对于屏幕边缘的坐标。
- `X/Y`: 同`clientX/Y`相当 ,fireFox 不支持。
- `layerX/Y`：同`pageX/Y`相同，IE11 以下同`clientX/Y`。
- `offsetX/Y`:鼠标位置相对于块元素(仅仅拿到块级宽高数值范围内)的坐标(包括边框)，`safari`不包括边框。



## 第二周

| **日期** |              **早**              |           **午**           |            **晚**             | **复习内容**  | **完成度** |
| :------: | :------------------------------: | :------------------------: | :---------------------------: | :-----------: | :--------: |
| 12月5日  | 解决事件代理和鼠标移动事件的窘态 |      鼠标行为预测技术      |       鼠标行为预测技术        |      Map      |    80%     |
| 12月6日  |    电商网站商品图片放大镜效果    | 电商网站商品图片放大镜效果 |           键盘事件            |      Set      |    80%     |
| 12月7日  |          贪吃蛇运动原理          |       开发贪吃蛇游戏       |        开发贪吃蛇游戏         |    WeekMap    |    80%     |
| 12月8日  |     从事件冒泡到事件代理机制     |         innerHTML          |   转义符号与字符、正则基础    |    WeekSet    |    90%     |
| 12月9日  |           修饰/元字符            |       正则量词、属性       |      正则方法、使用技巧       | Object.assign |    90%     |
| 12月10日 |   match/exec、toString/valueOf   |    封装typeof，正向预查    | 贪婪与非贪婪模式、replace方法 |     原型      |    90%     |
| 12月11日 |               复习               |            复习            |             复习              |     复习      |    70%     |



**知识整理：**

- 事件代理是解决了多次重复绑定事件函数的一种方案。事件代理的核心是事件对象`event`，IE对应的是`window.event`，和事件源对象`event.target`。火狐只有`event.target`，IE只有`srcElement`。
- 假如想给列表新增一项，并给列表底下的每一项都绑定点击事件，发现无法给新增的那一项绑定点击事件，原因是循环已经完毕后才去新增一项，所以新增的那一项是无法绑定点击事件。
- 解决方法是事件委托或事件代理，不打算给列表项绑定点击事件，而是给列表绑定事件。把点击事件委托给父级，通过事件源被点击后冒泡的特性，可以省略整个列表项绑定的过程。
- 按键的3个事件分为`keydown`是按下事件，`keyup`是抬起事件。
- `keydown`加上`keyup` 是否等于 `keypress`？结果是不成立的，`keydown`之后是`keyprress`，再之后是`keyup`。`keydown`和`keypress`具有相似性。
- 键盘事件的构造函数为`KeyboardEvent`，`keydown`和`keypress`实例对象里保存一个`charCode`属性，属性值分别为`0`和`103`。说明`keydown`事件是没有`charCode`，`charCode`实际上是ASCII码。`keyCode`为键盘顺位码，`keypress`事件可以用两个码，`charCode`和`keyCode`的属性值是一样的。
- `keypress`事件可以利用`e.charCode`去做更多的操作，如区分大小写，但是由于`keydown`没有而不能做更多的操作。
- `innerHTML`注意点：
  - 父节点 HTML 不要写错
  - 在`innerHTML`里 HTML 字符串不要写，旧版浏览器报错。
  - document 写法 1：`document.body.innerHTML`
  - document 写法 2：`document.documentElement.innerHTML`
  - `innerHTML`元素内部的所有内容都会被删除掉
  - `outterHTML`元素外部的所有内容都会删除替换
- ***设置`innerHTML`到底发生了什么?***
  1. `innerHTML= '<h1>123</h1>'`
  2. `<h1>123</h1>`解析为 HTML 文档结构
  3. 用 DocumentFragment 将这个 HTML 文档结构变成 DOM 节点
  4. 原本父结点上的所有内容都会被替换成这个 DOM 节点
- `innerHTML`的性能并不高效，普通文本尽量避免使用`innerHTML`。
- HTML5 和现代的新的浏览器都会阻止这种通过`innerHTML`嵌入 `script` 脚本的程序执行。插入纯文本的时候就不用`innerHTML`，应该使用`Node.textConent`，它创建了一个文本节点，不会去解析HTML，只会将文本插入到元素内部去。
- `Node.textContent`可以赋值更改，但不能解析HTML，不能成为一个DOM节点，仅仅是一个文本节点。
- `textContent`：获取所有元素的内容，如`<script>`和`<style>`，把非标签的内容全部剔除，显示非标签内容。
- `innerText`：只会获取给人看的内容，忽略`<br>`，`<style>`标签。会受到 CSS 的影响，导致回流，重新计算样式。
- 非 html 尽量用`textContent`, 能避免用`innerText`
- 避免使用`innerHTML`可以用`createElement`
- 转义的意思是转换意义，或改变意义。
- JavaScript对待语法来说，先解析正常的语法，分析完才做文本输出，此时发现变量与字符串中间没有加号，此时会报语法错误。
- 让字符本来的功能变为另外的意义和功能。
- `\n` 只给编辑系统使用，在页码不显示换行，只显示空格(占用了字符)，原因HTML是纯文本而不是编辑系统。但在控制台日志会换行。
- RegExp - regular expression，按照一定的规则匹配或检索这个规则当中指定的或指定类型的某些字符，或者是一些特殊的字符的方法。
- 匹配规则则是正则表达式，对字符串操作的一种逻辑公式，对某一些字符串中的某一些字符进行检索，但逻辑需要一种方式 去写成一种规则，然后让程序调用这种规则。
- `i`：igore case 忽略大小写
- `g`：global 全局匹配
- `m`：multi-line 多行匹配
- `()`：子表达式
- `[]`：区间
- `^`：非
- `|`：或
- `?`：个数，或贪婪匹配
- `\w`：`[0-9A-z_]`
- `\W`：`[^\w]` 非`\w`区间的所有字符
- `\d`：`[0-9]` digit 数字
- `\D`：`[^\d]` 非数字
- `\s`：`[\r\n\t\v\f]` -> `[回车\换行\制表\垂直\换页]`
- `\S`：`[^\s]`
- `\b`： 单词边界
- `\B`： 非单词边界
- `.`： 可以匹配除了回车和换行的所有字符
- 正则的两个原则: 
  - 不回头
  - 贪婪模式(能匹配多就不匹配少)
- 量词的意思是修饰多少个字符。简单来说，量词就是可以让元字符**重复匹配**。毕竟每个元字符只能匹配一个字符，如果要匹配 100 个字符，难道要写 100 个元字符吗？这个时候用上元字符 加 限定符就可以解决这个问题了。
- `n+`：`{1,正无穷}` 出现1次到正无穷，只要有一个个数就可以
- `n*`：`{0,正无穷}` 出现0次(即使无匹配也算1次)到正无穷，任何个数都可
- `n?`：`{0,1}` 出现0次到1次, 只要有一个个数就可以
- 子表达式，反向引用方法。写法是`(xxx)\1`，反向引用第一个子表达式，用于匹配类似`xxxx`，`xxyy`结构的方法。
- `reg.global`：判断是否用`g`。
- `reg.ignoreCase`：判断是否用忽略大小写`i`。
- `reg.multiline`：判断是否用换行`m。`
- `reg.source`：正则本体，如`/(\w)/`。
- `reg.lastIndex`：用来指定下一次匹配的起始索引。可读可写可配置。查到跟`exec()`执行后类数组里面的`index`的值是一样的，可更改`lastIndex`值去调整`index`下标。
- `reg.test(str)`：判断是否能匹配出来。
- `reg.exec()`：在一个指定字符串中执行一个搜索匹配。返回一个结果数组或` null`。
- 正向预查是匹配一个有条件的字符串，字符串后面指定一个特定的字符或者字符串。

## 第三周

| **日期** |               **早**               |            **午**            |               **晚**               | **复习内容**  | **完成度** |
| :------: | :--------------------------------: | :--------------------------: | :--------------------------------: | :-----------: | :--------: |
| 12月12日 |            正则实例集合            |          不捕获分组          |      用正则进行模板替换的方法      |     super     |    80%     |
| 12月13日 |        JSON基础与数据解析、        |      JSON方法、AJAX初识      |    模板渲染、缓存数据、案例实战    |  属性描述符   |    90%     |
| 12月14日 |    模板渲染、缓存数据、案例实战    | 模板渲染、缓存数据、案例实战 |    前端缓存数据设计、前端缓存池    |     Class     |    90%     |
| 12月15日 |    前端缓存数据设计、前端缓存池    |     DOM/CSS/渲染树、解析     |          加载、回流与重绘          |     继承      |    90%     |
| 12月16日 |         时间线、解析与渲染         |     封装文档解析完毕函数     |         渲染引擎、声明HTML         | Getter,setter |    90%     |
| 12月17日 | 渲染模式、剖析JavaScript的执行机制 |  标签的属性与特性、Math方法  | 封装byClassName、断点测试、bug调试 |     proxy     |    80%     |
| 12月18日 |                复习                |             复习             |                复习                |     复习      |    50%     |



**知识整理：**

- 捕获分组是用`()`包括的子表达式不仅能匹配两个字表达式合并的内容，还可以匹配子表达式之间独立的内容。分组捕获的意思是不仅将各个子表达式的内容匹配出来，并将他们中匹配的内容合并一起的内容也匹配出来形成分组。
- JSON是JavaScript Object Notation (JavaScript对象标记)，JSON是轻量级数据交互的格式，数据型的交换里面不包含方法。JavaScript对象的一种表达方式，是包含方法的。JSON是JavaScript对象的一个衍生，JSON选用映射的关系来形成一个轻量级的数据结构。
- 所有编程语言都离不开的三大数据类型是：
  - scalar标量(字符串和数字)
  - sequence序列(数组和列表)
  - mapping映射(键值对)，如函数参数的映射关系，将两个不同的东西映射在一起，如键值对，hash表
- 早期使用XML进行前后端的数据交互，优点是可以自定义标签，关于XML的缺点：
  - 数据文档很大
  - 不易读
  - 解析难度比较大
- `JSON.parse()`将JSON字符串转换成JSON对象。`JSON.stringify()`将JSON数据转为字符串。前后端交互的数据只能是字符串。
- 在聊天室应用中，建立长链接通信时，使用`websocket`去通信，数据必须是字符串的JSON数据并传递后端，后端通过解析JSON数据并进行更改再广播出去。
- 缓存池是请求过的数据不再去请求，只要请求过一次就会缓存到前端，以便于减轻服务器的压力。
- 前端做数据缓存有以下方法：
  - `localStroge`
  - `sessionStroge`
  - `cookies`
  - JS脚本(适用于更新不太频繁的情况)
- **DOM树**是多组HTML标签组成的一个树形结构，它满足深度优先解析原则，**DOM树构建**是HTML元素节点的解析过程。
- **CSS树**(样式结构体)，跟DOM的构建是类似的，也满足深度优先解析原则，它会忽略浏览器不能识别的样式。
- **渲染树**(renderTree)是CSS树构建完毕时会形成一个渲染树，它实际上是DOM树结合CSS树的形成新的树的结果，浏览器会根据渲染树(构建完毕)去绘制页面。
- 如`<img src="xxx" />`标签是一个解析的过程，它不需要等待图片资源加载(异步)完成才能向下解析，解析的过程伴随着加载的开始(先有解析再有异步加载的过程)，跟解析的快慢是没有关系的，资源加载是不会影响DOM树的构建。
- 当JavaScript对页面节点操作时就会产生**回流**和**重绘**，或者只产生重绘。
- 回流又叫重排(reflow)，回流的产生一定会引起重绘，但重绘不一定是回流的后续反应。因为节点的尺寸，布局，是否显示等改变时，渲染树中的一部分或者全部需要重新构建，这种重新构建的现象称为回流。首页页面加载也会形成至少一次回流，只要构建渲染树必定会引起回流。
- **引起回流的因素有：**
  - DOM节点增加与删除
  - DOM节点位置发生变化
  - 元素的尺寸，边距，填充，边框，宽高
  - DOM节点`display`属性的是否显示
  - 页面的渲染初始化(首次加载)
  - 浏览器窗口尺寸变化，如`window.resize`更改
  - 向浏览器请求某些样式信息时，如`offset`,`scroll`,`client`,`width`,`height`,`getComputedStyle()`,`currentStyle`
- 重绘(repaint)，除了会**影响回流那一部分因素时**，如更改字体颜色，它不会引起回流但会引起重绘。回流时，浏览器会重新构建时会受影响部分的渲染树，一旦渲染树被改变或重新构建就一定会引起重绘。
- 回流完成后，浏览器会根据新的渲染树重新绘制回流影响的部分或全部节点。这个重新绘制的过程称为重绘。
- 回流产生的性能问题比重绘的代价更高。
- 回流产生的性能问题跟渲染树的节点数量导致重新构建有关。
- 需要考虑回流次数的问题。
- 需要考虑回流涉及的节点数量问题。
- 尽可能避免在定位元素之前插入节点，会导致大量回流和重绘。
- 时间线是浏览器开始加载页面(HTML)的开始到整个页面加载结束的过程中按顺序发生的每一件事情的总流程，有了时间线概念就避免使用`window.onload`，因为文档解析完成后里面会执行`DOMContentLoaded`事件, 而`window.onload`仍要等待`<script async>`脚本加载完毕后才能触发。
- 可以访问`document`对象，DOM生效，JS起作用。
- 解析文档，浏览器从HTML第一行阅读到最后一行，中间会构建DOM树，文档加载页面的第1阶段为加载中`document.readyState = 'loading';`。
- 遇到`<link>`会新开**线程**异步加载CSS外部资源，同时异步构建CSSDOM。
- 遇到非异步加载的`<script>`时会阻塞文档解析，等待JS脚本加载并执行完毕后，继续解析文档。
- 遇到异步加载的`<script>`时异步加载JS脚本并执行的同时解析文档，但是不能使用`document.write()`会报错。
- 遇到`<img>`时先解析节点，有`src`属性会创建加载**线程**异步加载资源，不阻塞文档解析。
- 文档解析完成，文档加载页面的第2阶段为解析完成可交互`document.readyState = 'interactive';`。 
- `<script>`元素有`defer`属性时等待文档解析完成后，JS脚本会按照顺序执行。
- 文档解析完成才会触发监控文档解析完成的`DOMContentLoaded`事件，同步的脚本执行阶段往事件驱动阶段演化。
- `<script async>`加载并执行完毕，`<img>`等资源加载完毕，`window.onload`事件才触发，文档加载页面的第3阶段为页面加载完成`document.readyState = 'complete';`。
- `defer`或`async`属性可以显性声明脚本是异步的，防止阻塞DOM构建和渲染。
  - `defer`异步后台加载脚本，不中止文档解析，文档解析**完毕后执行**后台加载完毕的脚本。
  - `async`异步后台加载脚本，加载的过程不会中止文档解析，但是加载完毕时会**马上执行**脚本，在执行脚本期间会中止文档解析(阻塞)，直到脚本执行完毕后继续解析文档。
- **文档加载页面的三个重要阶段：**
  - `document.readyState = 'loading';`，页面加载的第一个阶段
  - `document.readyState = 'interactive';`，DOM和CSS文档**解析**完成阶段
  - `document.readyState = 'complete';`，页面**加载**完成，资源加载完毕，脚本加载和执行完毕，`onload`事件触发的阶段
- 浏览器组成
  - 用户界面，用户看到的浏览器的样子
  - 浏览器引擎，让浏览器运行的程序接口集合，主要是查询和操作渲染引擎
  - 渲染引擎，解析HTML,CSS，将解析的结果渲染到页面的程序
  - 网络，进行网络请求的程序
  - UI后端，绘制组合选择框及对话框等基本组件的程序
  - JS解释器，解释执行JS代码的程序
  - 数据存储，浏览器存储相关的程序 cookie/storage
- 渲染模式DTD，文档类型定义。(Document Type Definition)，分为严格版本，过渡版本，框架版本。
  - 严格模式，Strict DTD，文档结构表现形式实现了更高的分离，页面的外观用CSS来控制。
  - 过渡版本，Transitional DTD，包含了HTML4.0版本的全部标记，从HTML的使用过渡到XHTML。
  - 框架版本，Frameset DTD，使用`<frameset>`以框架的形式将网页分为多个文档。





## 第四周

| **日期** |            **早**             |        **午**        |              **晚**              | **复习内容**  | **完成度** |
| :------: | :---------------------------: | :------------------: | :------------------------------: | :-----------: | :--------: |
| 12月19日 |           HTML基础            |    编码、基础标签    |     基础标签补充、有无序列表     | document 对象 |    90%     |
| 12月20日 |     定义列表、表格、框架      |    数据提交、表单    |      表单标签属性、标签总结      |   获取元素    |    80%     |
| 12月21日 |      HTML5历史、标记法、      | 新增标签和属性、拖拽 | requestAnimationFrame、循环字母  |   遍历节点    |    90%     |
| 12月22日 | localStorage、sessionStorage  |        cookie        |     cookie增删改查、用户追踪     | 遍历节点元素  |    90%     |
| 12月23日 |        history、worker        | 读取文件、分割文件、 |         监控读取文件进度         |   节点属性    |    80%     |
| 12月24日 | webSocket、与HTTP请求的不同、 |       聊天应用       | 获取当前位置、设备速度、设备方向 |  DOM 结构树   |    80%     |
| 12月25日 |             复习              |         复习         |               复习               |     复习      |    70%     |



**知识整理：**

- `<head>`标签向浏览器传递基本的信息和配置。`<body>`标签区域是页面呈现区域。`<head>`标签里的三大件有`<title>`标签，`<meta name="description">`标签，`<meta name="keywords">`标签。搜素引擎认知的优先级：`title > description > keywords`。
- 表单是用户提交数据的时候使用的，第一要素是数据的名称，第二要素是数据的值。表单信息一般前后端都需要通过MD5摘要加密算法(不可逆加密算法)校验，且加密方式是不需要密钥的。
- `<form>`标签是一个表单的总标签，一个块级元素，没有任何样式。`method`属性定义提交的方式。
- `action`属性是提交后端数据的地址。
- `<input>`是一个内联块级元素，具有宽高。
- 若想通过提交按钮提交的`url`地址能接收表单信息，需要在`<input>`标签里定义`name`属性来定义提交的信息。
- `maxlength`属性可以限制最大的提交信息的字符长度。
- `<textarea>`标签里的`cols`和`rows`属性来定义可见宽度，以平均字符数为准，如默认字体为`16px`时，计算后约为宽度为`8px * cols + 17px`宽度。
- `<label>`标签是一个内联元素，用处是自定义单项或者多选。
- 使用`<fieldset>`标签可以对部分表单内容进行打包分组。
- 迅速在页面中搭建一个框架。`<frameset>`标签不能嵌套在`<body>`标签内部。
- 为了更好地处理今天的互联网应用，`HTML5`添加了很多新元素及功能，比如： 图形的绘制，多媒体内容，更好的页面结构，更好的形式处理，和几个`api`拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者等。
- `HTML5 `的一些最有趣的新特性：
  - 新的语义元素，比如 `<header>`, `<footer>`, `<article>`, `<section>`。
  - 新的表单控件，比如数字、日期、时间、日历和滑块。
  - 强大的图像支持（借由 `<canvas>` 和 `<svg>`）
  - 强大的多媒体支持（借由` <video>` 和 `<audio>`）
  - 强大的新 `API`，比如用本地存储取代 `cookie`
- `Cookie `主要用于以下三个方面：
  - 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
  - 个性化设置（如用户自定义设置、主题等）
  - 浏览器行为跟踪（如跟踪分析用户行为等）
- `history`接口(历史栈)，它保存用户在当前浏览器窗口访问过的一些历史记录，在`history`对象下有一些方法，如模拟前进和后退。
- 在HTML5中可以操作`history`栈的方法有`pushState`和`replaceState`。 
- `popState`事件可以监听浏览器窗口上的前进和后退按钮。该事件的`PopStateEvent`对象下的`state`属性保存了`pushState`新增定义的对象(等同于参数1对象)。
- `Web Worker` 为 `Web` 应用在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。
- WebSocket protocol是HTML5的一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。全双工又称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式。
- WebSocket是应用层协议，Socket是传输层协议。像一些应用APP像聊天，游戏等需要HTTP轮询服务器来拿到更新信息，这样做存在弊端：
  - 请求和响应的连接每次都是不一样的
  - 就算没有数据，HTTP请求头的字节数是必不可少的
  - 每次处理数据客户端要分清楚哪次响应对于哪次请求
- `Navigator.geolocation`只读属性返回一个 `Geolocation `对象，通过这个对象可以访问到设备的位置信息。使网站或应用可以根据用户的位置提供个性化结果。





## 第五周

| **日期** |             **早**             |                 **午**                 |               **晚**               | **复习内容** | **完成度** |
| :------: | :----------------------------: | :------------------------------------: | :--------------------------------: | :----------: | :--------: |
| 12月26日 |    px、em、rem的区别及应用     | 渐进式框架、三大框架对比、数据流和绑定 |       Vue项目的几种构建方式        |   节点创建   |    90%     |
| 12月27日 |  Webpack从0开始搭建Vue2/3项目  |        认识Vue以及它的基本用法         |       认识Vue以及组件化构建        |   节点增加   |    90%     |
| 12月28日 | 应用实例、组件实例与根组件实例 |            认识以及实现MVC             |          认识以及实现MVC           |   节点删除   |    90%     |
| 12月29日 |       认识和实现MVVM轮子       |           认识和实现MVVM轮子           |         认识和实现MVVM轮子         |   节点文本   |    80%     |
| 12月30日 |     认识Mustache与Vue编译      |           认识Vue的内置指令            |         认识Vue的内置指令          |   节点替换   |    80%     |
| 12月31日 |      插值表达式的使用指南      |       ES5-ES6贯穿对象深拷贝问题        | 深入研究data属性以及数据响应式实现 |   属性新增   |    80%     |
|  1月1日  |              复习              |                  复习                  |                复习                |     复习     |    40%     |



**知识整理：**

- Vue是一套用于构建用户界面的渐进式框架，被设计为可以自底向上逐层应用，核心库只关心视图层。渐进式框架，`progressive framework`, `vue `对自己框架和其他框架对比后，生成的一个特定名词，自底向上逐层开发。
- 用模板的方式进行一系列的编译，有自己的核心库会编译模板，然后会渲染 `DOM`，`Vue `将数据于 `DOM `进行关联，并建立响应式关联，数据改变视图更新。
- Vue应用范围广，生态环境友好，社区完善，易上手，代码轻量，发展迅速。
- 数据绑定是数据与视图渲染之间的关系，React是单向数据绑定，必须通过用户事件去触发才能对状态数据进行修改，导致视图的变更。Vue是双向数据绑定，它本身有`v-model`的机制可以完成视图变化导致状态数据的变更和视图变更。
- 数据流是数据流淌的方向，在父子组件中，数据按照方向去流动。Vue和React都符合单向数据流的原则，通过父组件的state来传递数据给子组件props接收。子组件只能通过emit去通知父组件更改state状态数据。
- `template`里面的一些 `HTML `字符串内部除开 `HTML `本身特性以外 如`Vue `的特性，如文本，表达式，属性，指令等。`Vue `模板都是基于 `HTML `的，模板中直接写 `HTML `都是能够被 `HTML `解析器解析的。
- `Vue `提供一套模板编译系统，基本是开发者写的`template`，然后分析它将 `HTML `字符串变成`AST`树，把表达式/自定义属性/指令等转化为新的原生的 `HTML`，把 `JS `写法的 `HTML `模板遍历出来后形成虚拟 `DOM `树节点，最后根据虚拟 `DOM `树变成真实 `DOM `树渲染到页面上。
- **插值**是数据绑定最常见的形式就是使用`Mustache`语法 (双大括号) 的文本插值。
- **关于`mustache.js`：** 用更少的逻辑来渲染模版，它是一个零依赖的模板系统，`mustache `中是不支持在 `HTML `属性中插值的，`Vue `中因为用底层的模板编译系统，支持内置的属性。
- `attribute`属性：给HTML做拓展用的，如 `title/src/href`。
- `property`属性：在对象内部存储数据，通常用来描述数据结构 `prop`。
- **表达式**作用是数学运算/字符串拼接/判断/`JS API`/不能绑定多个表达式/绑定语句。
- 指令 `(Directives)` 是带有 `v-` 前缀的特殊 `attribute`，它一般结合视图模板使用，响应式的作用于`dom`，指令是一种控制视图的集成方式。指令是模板应该按照怎样的逻辑进行渲染或绑定行为。
- **内置指令有：**`v-if`/`v-else`/`v-else-if`/`v-for`/`v-show`/`v-html`/`v-once`...
- **自定义指令**，开发者也可以给 `Vue `拓展指令，`v-自定义名称`，它可以提供一个直接操作`dom`的接口。
- **双向绑定**，`v-model`：数据双向绑定 用`v-model="数据来源"`实现，也是一个语法糖，是`@input="方法"`和`:input="数据"`的语法糖。适用元素：`input`/`textarea`/`select`/`checkbox`/`radio`。`v-bind`绑定属性，目的是引号内部看做变量，`vue `会对它进行解析。
- 应用实例是通过`createApp`创建 `APP `返回一个应用实例。实例里的大多数方法都会返回 `createApp `创建出来的应用实例，目的是允许链式调用操作。
- **关于后端 `MVC`：**视图 `View `需要数据去找 `Controller `对应的方法，调用 `Model `的方法，获取数据，返回给 `Contronller `对应的方法，渲染 `render `到视图 `View `中。
  - `M：Model `数据模型(模型层)，操作数据库(增删改查)
  - `V：View`视图层，显示视图或视图模板
  - `C：Controller `控制器层(逻辑层)，数据和视图关联挂载和基本的逻辑操作
- **关于前端 `MVC`：**`API `层，前端请求的 `API `对应的是控制器中的方法，前端异步请求 `URL `对应控制器中的方法，调用 `Model `层的方法，操作数据库，然后获取数据返回给控制器方法，控制器方法响应回前端。
  - `Model`：需要管理视图所需要的数据，数据与视图的关联
  - `View`：管理 HTML 模板和视图渲染
  - `Controller`：管理事件逻辑
-  `MVC `是 `MVVM `的雏形，`MVVM `解决了驱动不集中，不内聚的方式，更加解决了视图与模型之间完全隔离开来的一种关系。从而演变成 `MVVM `的形式，将 `ViewModel `隔离出来，剩下 `M data` 和 V view`供开发者使用，更加说明`vue `是只关注于视图渲染。`ViewModel 里有收集依赖，模板编译，数据劫持等重要方法。
- MVC的缺点是驱动被MVC分离成三部分，跟M V 逻辑混合在一起了。MVVM的优点是自身的驱动ViewModel让Model数据保存和处理的层的数据更改驱动View视图，而视图的更新也需要ViewModel。
