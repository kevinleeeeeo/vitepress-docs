# 学习计划

## 第一周

| **日期** |      **早**      |       **午**       |       **晚**       | **复习内容** | **完成度** |
| :------: | :--------------: | :----------------: | :----------------: | :----------: | :--------: |
|  5月1日  |   `generator`    |      `async`       |      `await`       |   响应模版   |    80%     |
|  5月2日  |    `ECMA`深度    |     `ECMA`深度     |     `ECMA`深度     |    数据库    |    80%     |
|  5月3日  |   浏览器发展史   |    浏览器发展史    |    浏览器发展史    |  后端`MVC`   |    90%     |
|  5月4日  | `JavaScript`特点 | `JavaScript`发展史 | `JavaScript`发展史 |    中间层    |    90%     |
|  5月5日  |   编程语言概述   |    `C`语言尝鲜     |     `C++`尝鲜      |  前端`MVC`   |    80%     |
|  5月6日  |    `php`尝鲜     |     `Java`尝鲜     |      `Go`尝鲜      |    `MVP`     |    90%     |
|  5月7日  |       复习       |        复习        |        复习        |     复习     |    40%     |

**知识整理：**

- 迭代器基于数据抽取，有序和连续的消耗数据的模式。迭代器接口一般会返回一个迭代器对象。迭代器对象里面有一个`next()`方法。根据遍历的索引长度去决定返回的对象内容，如`{ value: xxx, done: false }`。

- 在后端中的内部迭代器指的是一个系统内部定义好的规则函数。外部迭代器指的是像上面的写法是手动定义部署的迭代器接口。

- 对象身上不具备迭代器接口的原因是因为对象上键值对成员是无序的。

- **默认调用`iterator`接口的场合：**

  - `...`拓展运算符
  - `for of`
  - `Array.from()`
  - `map`
  - `set`
  - `Promiss.all()`
  - `yeild`

- 生成器`generator`函数语法。作用是访问迭代器对象，返回值是迭代器对象。只要执行生成器函数就会生成一个迭代器对象。

- 生成器函数一定要和`yeild`结合使用，可以自定义产出内容和返回值，用法和迭代器有点像`yeild`：产出的意思，产出的同时暂停程序向下执行。

- `yeild`暂停，找上一次暂停的位置，有记忆功能。

- `return`结束程序执行。

- `next()`传值问题蛇形传值方式。`next()`方法执行的返回值是`yeild`产出的值，`yeild`的返回值是`next()`方法传入的参数。

- `async`/`await`适用于异步函数的`ES6`语法，本质上也是一个语法糖，来源于生成器函数。具有内置的执行器(`co`函数)，更好的语义，更广的实用性。`async`的返回值是一个`Promise`对象，也有三种状态，每种状态对应每种回调。

- 迭代器和生成器的应用，如装饰器，在项目中非常常用的写法。

- 异步迭代的过程是由一个`Co`函数去实现。该函数接收一个迭代器对象作为参数。该函数的返回值是一个`promise`对象。声明一个用于递归的函数，该函数内部执行`next()`方法并传入数据作为参数。`next()`方法返回的对象并解构出`value`和`done`属性。

  - 当没有迭代完成时，即生成器函数内部仍有`yield`关键字时，对`promise`包装后的普通值进行`then()`操作，将获取的结果递归执行。
  - 当迭代完成时，将`next()`返回的对象里的`value`通过`resolve()`方法进行向往抛出。

- 一个空对象与另外一个空对象进行运算时，会隐式的通过`toString()`方法转为字符串，而且字符串是有长度的。

- 一个空数组与另一个空数组进行运算时，会隐式的通过`toString()`方法转为字符串，数组转为空的字符串，所以它的长度为零。

- 一个匿名函数是有长度的，该长度对应的是形参的数量，因为没有定义，所以长度为零。匿名函数也有`toString()`方法转字符串，该字符串是函数本身。

- 对象格式的字符串有实际意义，在前后端交互时，需要一种`JSON`数据类型来传递，实际上`JSON`借鉴了对象的格式，加以对对象里属性的描述。`JSON`对象里是不能有函数方法的，它代表一种数据的格式。

- 在`JavaScript`程序中，对象格式字符串也具有意义，除了数据交互以外就没有实际意义，因为对象的属性是无序性的，当无序列表变为字符串并没有实际意义。一个对象经过`toString`后不会变成`'{}'`的形式，因为它没有数据含义。

- 字符串`1,2,3`也有数据意义，字符串跟数组一样也是有序列表，可以根据索引获取当前元素的值。在`JavaScript`中大量的处理字符串，字符串也算是一种数据结构作为存储。

- `'function test(){}'`字符串也存在意义，在`JavaScript`中一切代码都是字符串，而且有专门处理字符串程序的方法，如`eval()`，`new Function()`。

- 字符串`[object Object]`也有存在意义，历史遗留问题，`JavaScript`的`ES3`中本来有先天不足，对象的`toString`是没有直接意义的，所以让其编程开发有意义的写法是`[object Object]`。

- 关键字`typeof`可以对类型进行检查，却为什么无法区分`object`是`null`，或是`array`，或是对象 的原因是`typeof`是从底层抛给上层一个关键字，关键字都是从底层抛出的，它更接近原生`JavaScript`编译之前的语法，它属于底层语法并遵循`ECMA-262`规范。

- `typeof`最开始触及的是内存，从内存出发告诉类型。`JavaScript`都是偏向所有的原始值，变量声明不赋值系统默认为`undefined`，类型也是`undefined`。`typeof`不会对对象类型进行分类的原因是对于内存来说只有原始值和引用值的区别(语法和规范层面)，所以对引用值只有`object`并没有区分。

- 对于引用值无法区分的问题，因为许多项目已经上线进行类型检查使用了`typeof`关键字所以不能再修改了。所以在ES5中新增了`use strict`检测限制，避免之前的使用了的项目出现报错的情况。

- `ES6`要新增箭头函数的原因是`this`是执行期上下文，`JavaScript`中，谁调用`this`指向谁。箭头函数在定义时就明确指向了父作用域的上下文，目的是在`JavaScript`中存在着大量的`this`不稳定现象，比如事件处理函数的绑定，面向对象编程，需要给`this`大量的指向改变，所以对于程序上大量使用`bind`返回的新函数某程度来说是臃肿的。

- 在解决方案中，优先考虑使用函数，函数具有优先原则，`First-class Function`，头等函数，在`JavaScript`编程中，函数同时也可以作为参数，函数也可以赋值给变量，函数也可以作为返回值的形式返回会外界，函数在`JavaScript`编程中是非常灵活作为各种场景的解决方案。

- 在多种计算机语言中，`JavaScript`属于一个超轻量级语言，首先它是弱类型的，对值的定义没有类型的限制。其次是语法简单灵活，没有固定的范式去解决某一些场景，如可以用面相对象，或面相过程，或面向函数的范式去解决某个问题。再者容错率高，对于语法及写法的容忍度非常大，很少会有报错。

- `JavaScript`在整个项目中开发与形成一个程序的效率非常高。属于解释型语言，没有编译过程的，不需要一个二进制的可执行文件去运行。`JavaScript`可以在宿主环境中直接运行，如浏览器环境可以解析编译分析。减轻开发负担，不需要关心编译过程，只需要关心代码运行时进行解释执行的过程。

- 浏览器环境是`JavaScript`语言的第一宿主环境，在浏览器的`JS`引擎上运行，旧版本浏览器是运行在渲染引擎上，直到`IE4.0`版本时把`JS`引擎独立出来，专门负责脚本的解析执行。由于`Google Chrome`开发的`V8`引擎可以在服务器上运行，脚本也可以在服务器上解析运行，如`NodeJS`也是基于`V8`引擎开发服务器`I/O`运行环境。

- `JavaScript`支持多种不同编程的方式与思想去做编程过程化，可以面向过程开发，也可以基于原型的面向对象开发，也可以支持函数式编程开发，如柯里化，偏函数，缓存函数开发，也可以支持函数闭包，回调函数的方式去编程。多范式也是`JavaScript`的难点，需要考虑用哪些设计思想或方式去解决相应的问题。

- `JavaScript`引擎线程是单线程，同一时间只能执行一个任务，任务必须在单线程的条件下去执行。

- `JavaScript`在运行时才能确定数据的类型，是弱类型语言。在运行时推断值赋值给了变量时推断变量的类型。当更改某个值时又会重新去推断值和变量的类型。

  

## 第二周

| **日期** |    **早**    |      **午**       |      **晚**      |     **复习内容**     | **完成度** |
| :------: | :----------: | :---------------: | :--------------: | :------------------: | :--------: |
|  5月8日  |   `JS`组成   |     同步异步      |     进程线程     |        `MVVM`        |    80%     |
|  5月9日  |   `JS`任务   |     渲染互斥      |   脚本程序注意   |      `MVVM`实现      |    80%     |
| 5月10日  |  时间片轮转  |      标识符       |       变量       |      `AJAX`历史      |    70%     |
| 5月11日  |   内存存储   |      `IEEE`       |   变量声明设计   | 创建`XMLHttpRequest` |    70%     |
| 5月12日  |   设计逻辑   | `let`和块级作用域 | `for`中`let`使用 |        状态码        |    80%     |
| 5月13日  | 面向对象设计 |   面向对象设计    |   面向对象设计   | `XMLHttpRequest`版本 |    80%     |
| 5月14日  |     复习     |       复习        |       复习       |         复习         |    60%     |

**知识整理：**

- `JavaScript`技术基本由四部分组成：
  - `ECMAScript`语言标准规范
  - 文档对象模型 (`DOM`) - `document object model`(`W3C`规范)
  - 浏览器对象模型(`BOM`) - `browser object model`(没有规范)
  - `NodeJS`服务器开发模型

- `ECMAScript`包含语法，变量，关键字，保留字，值，原始类型，引用类型，运算，对象，继承，函数。
- `HTML`中的 `<script>` 标签用于嵌入或引用可执行脚本。它可以引入外部文件或者内部脚本代码块。当内外脚本都定义时，只解析执行外部脚本。脚本与脚本之间是按照定义顺序同步执行的，原因是`<script>`脚本在解析执行期间是阻塞的，只有脚本执行完毕才会去进行`GUI`渲染，避免冲突问题。
- 外部脚本需要加载和解析执行程序，有服务器下载的过程。内部脚本是解析执行程序。
- 多个脚本之间存在作用域，引用错误是互不影响的，隔离的。`JavaScript`的运行三个步骤的第一步是语法检查，第二步是在执行脚本之前进行预编译预解析，在代码执行之前要对代码的变量，函数，函数参数进行顺序上的调整以便于以后更好的去调用执行，第三步是执行代码。
- `type`属性定义`src`引用的脚本语言，如`text/javascript`，`application/json`，`text/tpl`定义错误的目的是可以使其标签脚本不执行，仅用来做模板文件使用。
- `type="module"`属性定义使用的原因是`ES6`之前没有模块化，脚本程序可以是符合`ES6 Module`规范，可以使用`import`关键字并对其他模块导入的支持，并需要开启服务器对`HTML`进行访问，因为模块化的导入是需要发起`HTTP`请求。
- `type="nomodule"`属性定义对于不支持`ES6 Module`的脚本的浏览器。
- 正常情况下，`JS`的单线程引擎的主执行栈里的同步代码是逐一执行的，不存在前后代码的同时执行。
- 为了达到同步的效果，`JS`有个伪装的机制是时间片轮询的机制，把`setInterval`定义的回调函数切分为多个任务，如任务`1`切分`4`个小切片(`s1 - s4`)，任务`2`切分`4`个小切片(`t1 - t4`)，在时间片队列中的执行。
- 时间片队列中，每执行一个小切片就轮到`GUI`渲染线程进行渲染该小切片的部分。如此微小的及微妙级别的任务穿插机制，开发者是很难发现不是同时执行的，其实还是单线程同步的前后执行顺序的。
- 标识符`Identifier`是程序员可以自己决定命名的名字或内容，有变量名，常量名，函数名，类名等。这些名称其实都与内存有关系。
- 标识符包含了大小写字母`A-Za-z`，数字`0-9`，下划线`_`，美元符号`$`。规则是不能以数字开头，严格区分大小写字母，不允许使用空格，不允许使用`ES`[关键字与保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar)，语义化清晰完整且尽量简洁。可以使用驼峰及蛇形命名法。
- 标识符可以用来充当变量名称。内存中存储数据的最基本的单元标识，`JavaScript`是一门动态语言，变量与数据类型没有关系，变量与值的数据类型无关，声明变量使用`var`关键字去声明变量，将一个值赋值给变量。一个变量，就是一个用于存放数值的容器。声明变量 `var`有两个过程，第一个是变量声明，第二个是变量赋值。变量的`3`要素包括值类型，变量名称，变量值。
- `Java`语言的静态性。`int`声明为一个整形数据并赋值给一个整形，赋值其他类型数据将会报错。
- `JavaScript`是一门弱类型语言，当值操作不匹配既定的数据类型时，系统会做隐式类型转换。
- 变量的运算和变量的赋值存在优先级问题，先运算后赋值。
- 编程语言的基本能力有变量声明，指的是开辟值存储的内存空间的能力，有数据结构，指的是具备表达数据不同结构的能力，有函数声明，指的是具有对程序进行封装集成的能力，有运算，指的是完成算数与逻辑运行的能力。
- 内存存储情况如`Java`中声明一个变量`int a = 1`，由于是强类型语言，在`int a`的时候已经决定了当前要开辟的空间是一个`32`位的整形空间，整形是一个四字节`32`位，`JavaScript`不存在整形，并将`1`存储起来，存储的是`32`位整形的二进制补码。此时会有一个十六进制的地址对应上变量标识，通过地址访问标识去访问值。
- 内存存储情况如`JavaScript`中声明一个变量`var a = 1`，由于是弱类型语言，值可以决定开辟的空间，因为`JavaScript`在运行时去赋值，赋值的时候可以确定并推断出值的类型，值确定了类型后就会变成双精度的浮点型的标准进行存储。`JavaScript`所有的数字采用`64`位双精度浮点型的原因是选用`double`类型的双精度`64`位浮点型的取值范围是所有类型中最大的，所以会存在精度上的损失的问题。
- `IEEE`二进制浮点数算术标准（`IEEE 754`）是`20`世纪`80`年代以来最广泛使用的浮点数运算标准，由电器和电子工程师协`Institute of Electrical and Electronics Engineers`会来定义`754`号规范里的二进制浮点数算数标准，其中的公式是`V = (-1)^s * M * 2^E`，`V`是二进制浮点数表示方法，`s`是符号(`0`代表正数，`1`代表负数)，`M`是有效数字，`E`代表了指数(往左移动为正，往右为负)，为许多`CPU`与浮点运算器所采用。
- 变量的声明有`var`，`const`，`let`关键字，都与预编译，作用域以及提升有关系。声明式是把值绑定给标识符号的过程，语句是执行任务行为。`var`后来没有归类到声明式的原因是存在了特殊的情况，会产生作用域的副作用，即无法避免地去创建全局作用域属性的，这种副作用交叉性太强会导致非常多的问题，所以后来`ES6`规范中对其声明式的作用进行移除，使用`const`或`let`来代替。
- 块是`ES6`提出的，是一个大括号。外部无法访问大括号内部定义的变量。目的是封装独立的作用域。块级作用域生效的条件是在严格模式下，或者是模块内部。
- `var`在`ES3`使用的原因是`JavaScript`借助了数学对变量的表述，`const`和`let`并非在`ES6`的时候才提出，而在`ES3`草案时提出。`ES3`在设计语言方面存在极大的问题，在早期浏览器无法承载太多的脚本代码，没有单独的`JS`引擎，早期与渲染引擎一起来做语法分析，超过十几行代码就会崩溃，所以对变量声明上并不会做出区分，`const`和`let`在`JavaScript`中需要有复杂的语言分析的机制，如果列入到代码里会使内存溢出，对`CPU`造成很大的性能损耗，而且渲染本身也需要耗费很大的性能，导致早期的`JavaScript`设计必须要简单。
- 在浏览器性能方面，`var`关键字是比较贴切于`JavaScript`作为一门动态脚本语言，宿主是浏览器环境，浏览器不可能作为一个编译器去编译强类型语言再转为弱类型再去转机器码。针对宿主为浏览器的脚本必须设计的简单化，动态化，这样才可以让浏览器作为解释器有效的去解释和执行脚本代码，并节省开支。所以在`ES3.1`版本时也也没有通过新增`let`，`const`的草案。
- 在语言本身复杂度方面，对于浏览器对新语法的支持上以及浏览器厂商对规范的支持等问题只能选择`var`声明，并不希望把脚本语言的规范做的更加的复杂，而且早期的业务场景需求较为单一，仅是对`DOM`的操作的动态操作。到如今，`ES6`对`const`和`let`的新增是对日益硬件技术的提升的发展需求的补充。
- `let`声明块级作用域的局部变量，`ES6`模块化中的模块也是一个块级作用域，默认严格模式，`window`对象访问是`undefined`。在`ES6`中的块级作用域与`ES3`的立即执行函数创建的作用域性质是一样的，为了保证变量没有全局污染的一个解决方案。
- 标识符被重复声明的报错。在`ES6`中，对`ES3`的`var`的重复赋值是不合理的，所以才新增了`let`声明来让变量可以被重复赋值。
- 在预编译过程`var`声明的变量会提升，会存在短暂的暂时性死区。而`JS`系统中，`undefined`是唯一自动化生成的默认值。预编译阶段拿到声明，但不进行初始化`undefined`或者是其他的值，而初始化的过程放到执行期阶段为了解决声明后可访问变量的问题。
- `const`声明常量的关键字，`const`声明的变量并不能重新被赋值。指向引用值，内部属性可删除或更改。如果是常量性质，命名时要大写。如果是变量性质，命名时用小驼峰写法。
- `ES6`解决方法是`for`循环中初始块用了`let`触发并创建特殊的一种作用域机制，在每次迭代的时候，系统会为`for`的`loop`本体创建一个词法作用域，在词法作用域中新`let`声明一个`i`，将上一次迭代或初始化的值赋值给新的`i`变量，对新词法作用域内的`i`进行操作，如`i++`，这就是形成块作用域的原因。
- `JavaScript`是一门基于对象的语言，但并不是真正面向对象的编程语言。把具有相同属性和行为的事物抽象成一个事物类别，通过实例化，让这个事物类别构造成一个具体的事物对象。
- 面向对象是以创建对象为基础，利用对象完成程序的集成。有一个工具来创建对象，这个对象提供一系列的属性，这些属性帮助开发者完成程序中的功能。最大的特点是具有复用性，每次创建一个新的引用对象，不会造成对象之间的互相引用。
- 面向对象的简称是`OOP`，对象面向编程`Object Oriented Programming`的思想。面向对象具有封装性，继承性，多态性的三大特性。
- 面向对象与`new`关键字相关，`JS`引擎通过`new`关键字执行一个函数并返回一个新的对象。`new`过程相当于是执行一个函数，函数内部定义一个对象，给这个对象的属性进行赋值，再将对象返回外界，这就是实例化一个对象的过程。
- 对于`new`关键字实例化时，实际上省略了内部创建对象，会返回对象的部分，仅需要定义对象属性。在构造函数执行时，会产生一个执行期上下文`this`，并确定指向的对象。在严格模式或模块化脚本中`this`为`undefined`。在非严格模式下，`this`默认指向`window`对象。`this`关键字是一个指针，如内存中栈指向堆地址。
- 在`JavaScript`中，函数都可以充当创建对象的工具，叫构造函数，构造一个新的对象的函数，写法是`new Xxx()`。在开发过程中，注意约定规范，大驼峰命名函数名称，默认为一个构造函数`constructor`。
- 一个函数的声明是一个引用值，`typeof function(){}`结果也是一个对象，在`JavaScript`中的对象都可以使用`.`语法或`['xxx']`进行访问，所以可以给函数引用对象新增属性。在函数上挂载属性的方式叫静态添加属性，该属性叫静态属性或静态方法。
- 在函数上默认具有`prototype`静态原型属性，值是一个对象，也可以是一个数组，也可以是一个函数，主要为了函数充当`prototype`对象的构造器。
- 实例对象可以通过原型继承可将定义在静态属性的方法内部中的`this`指向实例对象。通过继承的原型链可以找到原型内部的属性和方法，不需要通过`xx.__proto__`去访问也可以拿到原型上的属性和方法。
- 直接给构造函数的`this`对象新增方法会存在弊端。当每一次`new`实例化都会在`this`对象中新增新的函数引用，但是一般来说方法都是固定不变的，是静态的，所以没有必要每次实例化都创建新的方法。可以将方法作为一个静态的方法定义在原型上，此面向对象设计写法可以节省开销。

## 第三周

| **日期** |  **早**  |  **午**  | **晚** |       **复习内容**       | **完成度** |
| :------: | :------: | :------: | :----: | :----------------------: | :--------: |
| 5月15日  | 有序数据 | 无序数据 |  循环  | `XMLHttpRequest`兼容问题 |     0%     |
| 5月16日  | 枚举封装 |  待计划  | 待计划 |       `xhr`的事件        |     0%     |
| 5月17日  |  待计划  |  待计划  | 待计划 |      `responseText`      |     0%     |
| 5月18日  |  待计划  |  待计划  | 待计划 |      `responseXML`       |     0%     |
| 5月19日  |  待计划  |  待计划  | 待计划 |      `axios`拦截器       |     0%     |
| 5月20日  |  待计划  |  待计划  | 待计划 |    `express`应用创建     |     0%     |
| 5月21日  |   复习   |   复习   |  复习  |           复习           |     0%     |

**知识整理：**
