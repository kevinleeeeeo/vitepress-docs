# 学习计划

## 第一周

| **日期** |      **早**      |       **午**       |       **晚**       | **复习内容** | **完成度** |
| :------: | :--------------: | :----------------: | :----------------: | :----------: | :--------: |
|  5月1日  |   `generator`    |      `async`       |      `await`       |   响应模版   |    80%     |
|  5月2日  |    `ECMA`深度    |     `ECMA`深度     |     `ECMA`深度     |    数据库    |    80%     |
|  5月3日  |   浏览器发展史   |    浏览器发展史    |    浏览器发展史    |  后端`MVC`   |    90%     |
|  5月4日  | `JavaScript`特点 | `JavaScript`发展史 | `JavaScript`发展史 |    中间层    |    90%     |
|  5月5日  |   编程语言概述   |    `C`语言尝鲜     |     `C++`尝鲜      |  前端`MVC`   |    80%     |
|  5月6日  |    `php`尝鲜     |     `Java`尝鲜     |      `Go`尝鲜      |    `MVP`     |    90%     |
|  5月7日  |       复习       |        复习        |        复习        |     复习     |    40%     |

**知识整理：**

- 迭代器基于数据抽取，有序和连续的消耗数据的模式。迭代器接口一般会返回一个迭代器对象。迭代器对象里面有一个`next()`方法。根据遍历的索引长度去决定返回的对象内容，如`{ value: xxx, done: false }`。

- 在后端中的内部迭代器指的是一个系统内部定义好的规则函数。外部迭代器指的是像上面的写法是手动定义部署的迭代器接口。

- 对象身上不具备迭代器接口的原因是因为对象上键值对成员是无序的。

- **默认调用`iterator`接口的场合：**

  - `...`拓展运算符
  - `for of`
  - `Array.from()`
  - `map`
  - `set`
  - `Promiss.all()`
  - `yeild`

- 生成器`generator`函数语法。作用是访问迭代器对象，返回值是迭代器对象。只要执行生成器函数就会生成一个迭代器对象。

- 生成器函数一定要和`yeild`结合使用，可以自定义产出内容和返回值，用法和迭代器有点像`yeild`：产出的意思，产出的同时暂停程序向下执行。

- `yeild`暂停，找上一次暂停的位置，有记忆功能。

- `return`结束程序执行。

- `next()`传值问题蛇形传值方式。`next()`方法执行的返回值是`yeild`产出的值，`yeild`的返回值是`next()`方法传入的参数。

- `async`/`await`适用于异步函数的`ES6`语法，本质上也是一个语法糖，来源于生成器函数。具有内置的执行器(`co`函数)，更好的语义，更广的实用性。`async`的返回值是一个`Promise`对象，也有三种状态，每种状态对应每种回调。

- 迭代器和生成器的应用，如装饰器，在项目中非常常用的写法。

- 异步迭代的过程是由一个`Co`函数去实现。该函数接收一个迭代器对象作为参数。该函数的返回值是一个`promise`对象。声明一个用于递归的函数，该函数内部执行`next()`方法并传入数据作为参数。`next()`方法返回的对象并解构出`value`和`done`属性。

  - 当没有迭代完成时，即生成器函数内部仍有`yield`关键字时，对`promise`包装后的普通值进行`then()`操作，将获取的结果递归执行。
  - 当迭代完成时，将`next()`返回的对象里的`value`通过`resolve()`方法进行向往抛出。

- 一个空对象与另外一个空对象进行运算时，会隐式的通过`toString()`方法转为字符串，而且字符串是有长度的。

- 一个空数组与另一个空数组进行运算时，会隐式的通过`toString()`方法转为字符串，数组转为空的字符串，所以它的长度为零。

- 一个匿名函数是有长度的，该长度对应的是形参的数量，因为没有定义，所以长度为零。匿名函数也有`toString()`方法转字符串，该字符串是函数本身。

- 对象格式的字符串有实际意义，在前后端交互时，需要一种`JSON`数据类型来传递，实际上`JSON`借鉴了对象的格式，加以对对象里属性的描述。`JSON`对象里是不能有函数方法的，它代表一种数据的格式。

- 在`JavaScript`程序中，对象格式字符串也具有意义，除了数据交互以外就没有实际意义，因为对象的属性是无序性的，当无序列表变为字符串并没有实际意义。一个对象经过`toString`后不会变成`'{}'`的形式，因为它没有数据含义。

- 字符串`1,2,3`也有数据意义，字符串跟数组一样也是有序列表，可以根据索引获取当前元素的值。在`JavaScript`中大量的处理字符串，字符串也算是一种数据结构作为存储。

- `'function test(){}'`字符串也存在意义，在`JavaScript`中一切代码都是字符串，而且有专门处理字符串程序的方法，如`eval()`，`new Function()`。

- 字符串`[object Object]`也有存在意义，历史遗留问题，`JavaScript`的`ES3`中本来有先天不足，对象的`toString`是没有直接意义的，所以让其编程开发有意义的写法是`[object Object]`。

- 关键字`typeof`可以对类型进行检查，却为什么无法区分`object`是`null`，或是`array`，或是对象 的原因是`typeof`是从底层抛给上层一个关键字，关键字都是从底层抛出的，它更接近原生`JavaScript`编译之前的语法，它属于底层语法并遵循`ECMA-262`规范。

- `typeof`最开始触及的是内存，从内存出发告诉类型。`JavaScript`都是偏向所有的原始值，变量声明不赋值系统默认为`undefined`，类型也是`undefined`。`typeof`不会对对象类型进行分类的原因是对于内存来说只有原始值和引用值的区别(语法和规范层面)，所以对引用值只有`object`并没有区分。

- 对于引用值无法区分的问题，因为许多项目已经上线进行类型检查使用了`typeof`关键字所以不能再修改了。所以在ES5中新增了`use strict`检测限制，避免之前的使用了的项目出现报错的情况。

- `ES6`要新增箭头函数的原因是`this`是执行期上下文，`JavaScript`中，谁调用`this`指向谁。箭头函数在定义时就明确指向了父作用域的上下文，目的是在`JavaScript`中存在着大量的`this`不稳定现象，比如事件处理函数的绑定，面向对象编程，需要给`this`大量的指向改变，所以对于程序上大量使用`bind`返回的新函数某程度来说是臃肿的。

- 在解决方案中，优先考虑使用函数，函数具有优先原则，`First-class Function`，头等函数，在`JavaScript`编程中，函数同时也可以作为参数，函数也可以赋值给变量，函数也可以作为返回值的形式返回会外界，函数在`JavaScript`编程中是非常灵活作为各种场景的解决方案。

- 在多种计算机语言中，`JavaScript`属于一个超轻量级语言，首先它是弱类型的，对值的定义没有类型的限制。其次是语法简单灵活，没有固定的范式去解决某一些场景，如可以用面相对象，或面相过程，或面向函数的范式去解决某个问题。再者容错率高，对于语法及写法的容忍度非常大，很少会有报错。

- `JavaScript`在整个项目中开发与形成一个程序的效率非常高。属于解释型语言，没有编译过程的，不需要一个二进制的可执行文件去运行。`JavaScript`可以在宿主环境中直接运行，如浏览器环境可以解析编译分析。减轻开发负担，不需要关心编译过程，只需要关心代码运行时进行解释执行的过程。

- 浏览器环境是`JavaScript`语言的第一宿主环境，在浏览器的`JS`引擎上运行，旧版本浏览器是运行在渲染引擎上，直到`IE4.0`版本时把`JS`引擎独立出来，专门负责脚本的解析执行。由于`Google Chrome`开发的`V8`引擎可以在服务器上运行，脚本也可以在服务器上解析运行，如`NodeJS`也是基于`V8`引擎开发服务器`I/O`运行环境。

- `JavaScript`支持多种不同编程的方式与思想去做编程过程化，可以面向过程开发，也可以基于原型的面向对象开发，也可以支持函数式编程开发，如柯里化，偏函数，缓存函数开发，也可以支持函数闭包，回调函数的方式去编程。多范式也是`JavaScript`的难点，需要考虑用哪些设计思想或方式去解决相应的问题。

- `JavaScript`引擎线程是单线程，同一时间只能执行一个任务，任务必须在单线程的条件下去执行。

- `JavaScript`在运行时才能确定数据的类型，是弱类型语言。在运行时推断值赋值给了变量时推断变量的类型。当更改某个值时又会重新去推断值和变量的类型。

  

## 第二周

| **日期** |  **早**  |  **午**  |  **晚**  |     **复习内容**     | **完成度** |
| :------: | :------: | :------: | :------: | :------------------: | :--------: |
|  5月8日  | `JS`组成 | 同步异步 | 进程线程 |        `MVVM`        |     0%     |
|  5月9日  |  待计划  |  待计划  |  待计划  |      `MVVM`实现      |     0%     |
| 5月10日  |  待计划  |  待计划  |  待计划  |      `AJAX`历史      |     0%     |
| 5月11日  |  待计划  |  待计划  |  待计划  | 创建`XMLHttpRequest` |     0%     |
| 5月12日  |  待计划  |  待计划  |  待计划  |        状态码        |     0%     |
| 5月13日  |  待计划  |  待计划  |  待计划  | `XMLHttpRequest`版本 |     0%     |
| 5月14日  |   复习   |   复习   |   复习   |         复习         |     0%     |

**知识整理：**
