# 学习计划

## 第一周

| **日期** |      **早**      |       **午**       |       **晚**       | **复习内容** | **完成度** |
| :------: | :--------------: | :----------------: | :----------------: | :----------: | :--------: |
|  5月1日  |   `generator`    |      `async`       |      `await`       |   响应模版   |    80%     |
|  5月2日  |    `ECMA`深度    |     `ECMA`深度     |     `ECMA`深度     |    数据库    |    80%     |
|  5月3日  |   浏览器发展史   |    浏览器发展史    |    浏览器发展史    |  后端`MVC`   |    90%     |
|  5月4日  | `JavaScript`特点 | `JavaScript`发展史 | `JavaScript`发展史 |    中间层    |    90%     |
|  5月5日  |   编程语言概述   |    `C`语言尝鲜     |     `C++`尝鲜      |  前端`MVC`   |    80%     |
|  5月6日  |    `php`尝鲜     |     `Java`尝鲜     |      `Go`尝鲜      |    `MVP`     |    90%     |
|  5月7日  |       复习       |        复习        |        复习        |     复习     |    40%     |

**知识整理：**

- 迭代器基于数据抽取，有序和连续的消耗数据的模式。迭代器接口一般会返回一个迭代器对象。迭代器对象里面有一个`next()`方法。根据遍历的索引长度去决定返回的对象内容，如`{ value: xxx, done: false }`。

- 在后端中的内部迭代器指的是一个系统内部定义好的规则函数。外部迭代器指的是像上面的写法是手动定义部署的迭代器接口。

- 对象身上不具备迭代器接口的原因是因为对象上键值对成员是无序的。

- **默认调用`iterator`接口的场合：**

  - `...`拓展运算符
  - `for of`
  - `Array.from()`
  - `map`
  - `set`
  - `Promiss.all()`
  - `yeild`

- 生成器`generator`函数语法。作用是访问迭代器对象，返回值是迭代器对象。只要执行生成器函数就会生成一个迭代器对象。

- 生成器函数一定要和`yeild`结合使用，可以自定义产出内容和返回值，用法和迭代器有点像`yeild`：产出的意思，产出的同时暂停程序向下执行。

- `yeild`暂停，找上一次暂停的位置，有记忆功能。

- `return`结束程序执行。

- `next()`传值问题蛇形传值方式。`next()`方法执行的返回值是`yeild`产出的值，`yeild`的返回值是`next()`方法传入的参数。

- `async`/`await`适用于异步函数的`ES6`语法，本质上也是一个语法糖，来源于生成器函数。具有内置的执行器(`co`函数)，更好的语义，更广的实用性。`async`的返回值是一个`Promise`对象，也有三种状态，每种状态对应每种回调。

- 迭代器和生成器的应用，如装饰器，在项目中非常常用的写法。

- 异步迭代的过程是由一个`Co`函数去实现。该函数接收一个迭代器对象作为参数。该函数的返回值是一个`promise`对象。声明一个用于递归的函数，该函数内部执行`next()`方法并传入数据作为参数。`next()`方法返回的对象并解构出`value`和`done`属性。

  - 当没有迭代完成时，即生成器函数内部仍有`yield`关键字时，对`promise`包装后的普通值进行`then()`操作，将获取的结果递归执行。
  - 当迭代完成时，将`next()`返回的对象里的`value`通过`resolve()`方法进行向往抛出。

- 一个空对象与另外一个空对象进行运算时，会隐式的通过`toString()`方法转为字符串，而且字符串是有长度的。

- 一个空数组与另一个空数组进行运算时，会隐式的通过`toString()`方法转为字符串，数组转为空的字符串，所以它的长度为零。

- 一个匿名函数是有长度的，该长度对应的是形参的数量，因为没有定义，所以长度为零。匿名函数也有`toString()`方法转字符串，该字符串是函数本身。

- 对象格式的字符串有实际意义，在前后端交互时，需要一种`JSON`数据类型来传递，实际上`JSON`借鉴了对象的格式，加以对对象里属性的描述。`JSON`对象里是不能有函数方法的，它代表一种数据的格式。

- 在`JavaScript`程序中，对象格式字符串也具有意义，除了数据交互以外就没有实际意义，因为对象的属性是无序性的，当无序列表变为字符串并没有实际意义。一个对象经过`toString`后不会变成`'{}'`的形式，因为它没有数据含义。

- 字符串`1,2,3`也有数据意义，字符串跟数组一样也是有序列表，可以根据索引获取当前元素的值。在`JavaScript`中大量的处理字符串，字符串也算是一种数据结构作为存储。

- `'function test(){}'`字符串也存在意义，在`JavaScript`中一切代码都是字符串，而且有专门处理字符串程序的方法，如`eval()`，`new Function()`。

- 字符串`[object Object]`也有存在意义，历史遗留问题，`JavaScript`的`ES3`中本来有先天不足，对象的`toString`是没有直接意义的，所以让其编程开发有意义的写法是`[object Object]`。

- 关键字`typeof`可以对类型进行检查，却为什么无法区分`object`是`null`，或是`array`，或是对象 的原因是`typeof`是从底层抛给上层一个关键字，关键字都是从底层抛出的，它更接近原生`JavaScript`编译之前的语法，它属于底层语法并遵循`ECMA-262`规范。

- `typeof`最开始触及的是内存，从内存出发告诉类型。`JavaScript`都是偏向所有的原始值，变量声明不赋值系统默认为`undefined`，类型也是`undefined`。`typeof`不会对对象类型进行分类的原因是对于内存来说只有原始值和引用值的区别(语法和规范层面)，所以对引用值只有`object`并没有区分。

- 对于引用值无法区分的问题，因为许多项目已经上线进行类型检查使用了`typeof`关键字所以不能再修改了。所以在ES5中新增了`use strict`检测限制，避免之前的使用了的项目出现报错的情况。

- `ES6`要新增箭头函数的原因是`this`是执行期上下文，`JavaScript`中，谁调用`this`指向谁。箭头函数在定义时就明确指向了父作用域的上下文，目的是在`JavaScript`中存在着大量的`this`不稳定现象，比如事件处理函数的绑定，面向对象编程，需要给`this`大量的指向改变，所以对于程序上大量使用`bind`返回的新函数某程度来说是臃肿的。

- 在解决方案中，优先考虑使用函数，函数具有优先原则，`First-class Function`，头等函数，在`JavaScript`编程中，函数同时也可以作为参数，函数也可以赋值给变量，函数也可以作为返回值的形式返回会外界，函数在`JavaScript`编程中是非常灵活作为各种场景的解决方案。

- 在多种计算机语言中，`JavaScript`属于一个超轻量级语言，首先它是弱类型的，对值的定义没有类型的限制。其次是语法简单灵活，没有固定的范式去解决某一些场景，如可以用面相对象，或面相过程，或面向函数的范式去解决某个问题。再者容错率高，对于语法及写法的容忍度非常大，很少会有报错。

- `JavaScript`在整个项目中开发与形成一个程序的效率非常高。属于解释型语言，没有编译过程的，不需要一个二进制的可执行文件去运行。`JavaScript`可以在宿主环境中直接运行，如浏览器环境可以解析编译分析。减轻开发负担，不需要关心编译过程，只需要关心代码运行时进行解释执行的过程。

- 浏览器环境是`JavaScript`语言的第一宿主环境，在浏览器的`JS`引擎上运行，旧版本浏览器是运行在渲染引擎上，直到`IE4.0`版本时把`JS`引擎独立出来，专门负责脚本的解析执行。由于`Google Chrome`开发的`V8`引擎可以在服务器上运行，脚本也可以在服务器上解析运行，如`NodeJS`也是基于`V8`引擎开发服务器`I/O`运行环境。

- `JavaScript`支持多种不同编程的方式与思想去做编程过程化，可以面向过程开发，也可以基于原型的面向对象开发，也可以支持函数式编程开发，如柯里化，偏函数，缓存函数开发，也可以支持函数闭包，回调函数的方式去编程。多范式也是`JavaScript`的难点，需要考虑用哪些设计思想或方式去解决相应的问题。

- `JavaScript`引擎线程是单线程，同一时间只能执行一个任务，任务必须在单线程的条件下去执行。

- `JavaScript`在运行时才能确定数据的类型，是弱类型语言。在运行时推断值赋值给了变量时推断变量的类型。当更改某个值时又会重新去推断值和变量的类型。

  

## 第二周

| **日期** |    **早**    |      **午**       |      **晚**      |     **复习内容**     | **完成度** |
| :------: | :----------: | :---------------: | :--------------: | :------------------: | :--------: |
|  5月8日  |   `JS`组成   |     同步异步      |     进程线程     |        `MVVM`        |    80%     |
|  5月9日  |   `JS`任务   |     渲染互斥      |   脚本程序注意   |      `MVVM`实现      |    80%     |
| 5月10日  |  时间片轮转  |      标识符       |       变量       |      `AJAX`历史      |    70%     |
| 5月11日  |   内存存储   |      `IEEE`       |   变量声明设计   | 创建`XMLHttpRequest` |    70%     |
| 5月12日  |   设计逻辑   | `let`和块级作用域 | `for`中`let`使用 |        状态码        |    80%     |
| 5月13日  | 面向对象设计 |   面向对象设计    |   面向对象设计   | `XMLHttpRequest`版本 |    80%     |
| 5月14日  |     复习     |       复习        |       复习       |         复习         |    60%     |

**知识整理：**

- `JavaScript`技术基本由四部分组成：
  - `ECMAScript`语言标准规范
  - 文档对象模型 (`DOM`) - `document object model`(`W3C`规范)
  - 浏览器对象模型(`BOM`) - `browser object model`(没有规范)
  - `NodeJS`服务器开发模型

- `ECMAScript`包含语法，变量，关键字，保留字，值，原始类型，引用类型，运算，对象，继承，函数。
- `HTML`中的 `<script>` 标签用于嵌入或引用可执行脚本。它可以引入外部文件或者内部脚本代码块。当内外脚本都定义时，只解析执行外部脚本。脚本与脚本之间是按照定义顺序同步执行的，原因是`<script>`脚本在解析执行期间是阻塞的，只有脚本执行完毕才会去进行`GUI`渲染，避免冲突问题。
- 外部脚本需要加载和解析执行程序，有服务器下载的过程。内部脚本是解析执行程序。
- 多个脚本之间存在作用域，引用错误是互不影响的，隔离的。`JavaScript`的运行三个步骤的第一步是语法检查，第二步是在执行脚本之前进行预编译预解析，在代码执行之前要对代码的变量，函数，函数参数进行顺序上的调整以便于以后更好的去调用执行，第三步是执行代码。
- `type`属性定义`src`引用的脚本语言，如`text/javascript`，`application/json`，`text/tpl`定义错误的目的是可以使其标签脚本不执行，仅用来做模板文件使用。
- `type="module"`属性定义使用的原因是`ES6`之前没有模块化，脚本程序可以是符合`ES6 Module`规范，可以使用`import`关键字并对其他模块导入的支持，并需要开启服务器对`HTML`进行访问，因为模块化的导入是需要发起`HTTP`请求。
- `type="nomodule"`属性定义对于不支持`ES6 Module`的脚本的浏览器。
- 正常情况下，`JS`的单线程引擎的主执行栈里的同步代码是逐一执行的，不存在前后代码的同时执行。
- 为了达到同步的效果，`JS`有个伪装的机制是时间片轮询的机制，把`setInterval`定义的回调函数切分为多个任务，如任务`1`切分`4`个小切片(`s1 - s4`)，任务`2`切分`4`个小切片(`t1 - t4`)，在时间片队列中的执行。
- 时间片队列中，每执行一个小切片就轮到`GUI`渲染线程进行渲染该小切片的部分。如此微小的及微妙级别的任务穿插机制，开发者是很难发现不是同时执行的，其实还是单线程同步的前后执行顺序的。
- 标识符`Identifier`是程序员可以自己决定命名的名字或内容，有变量名，常量名，函数名，类名等。这些名称其实都与内存有关系。
- 标识符包含了大小写字母`A-Za-z`，数字`0-9`，下划线`_`，美元符号`$`。规则是不能以数字开头，严格区分大小写字母，不允许使用空格，不允许使用`ES`[关键字与保留字](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar)，语义化清晰完整且尽量简洁。可以使用驼峰及蛇形命名法。
- 标识符可以用来充当变量名称。内存中存储数据的最基本的单元标识，`JavaScript`是一门动态语言，变量与数据类型没有关系，变量与值的数据类型无关，声明变量使用`var`关键字去声明变量，将一个值赋值给变量。一个变量，就是一个用于存放数值的容器。声明变量 `var`有两个过程，第一个是变量声明，第二个是变量赋值。变量的`3`要素包括值类型，变量名称，变量值。
- `Java`语言的静态性。`int`声明为一个整形数据并赋值给一个整形，赋值其他类型数据将会报错。
- `JavaScript`是一门弱类型语言，当值操作不匹配既定的数据类型时，系统会做隐式类型转换。
- 变量的运算和变量的赋值存在优先级问题，先运算后赋值。
- 编程语言的基本能力有变量声明，指的是开辟值存储的内存空间的能力，有数据结构，指的是具备表达数据不同结构的能力，有函数声明，指的是具有对程序进行封装集成的能力，有运算，指的是完成算数与逻辑运行的能力。
- 内存存储情况如`Java`中声明一个变量`int a = 1`，由于是强类型语言，在`int a`的时候已经决定了当前要开辟的空间是一个`32`位的整形空间，整形是一个四字节`32`位，`JavaScript`不存在整形，并将`1`存储起来，存储的是`32`位整形的二进制补码。此时会有一个十六进制的地址对应上变量标识，通过地址访问标识去访问值。
- 内存存储情况如`JavaScript`中声明一个变量`var a = 1`，由于是弱类型语言，值可以决定开辟的空间，因为`JavaScript`在运行时去赋值，赋值的时候可以确定并推断出值的类型，值确定了类型后就会变成双精度的浮点型的标准进行存储。`JavaScript`所有的数字采用`64`位双精度浮点型的原因是选用`double`类型的双精度`64`位浮点型的取值范围是所有类型中最大的，所以会存在精度上的损失的问题。
- `IEEE`二进制浮点数算术标准（`IEEE 754`）是`20`世纪`80`年代以来最广泛使用的浮点数运算标准，由电器和电子工程师协`Institute of Electrical and Electronics Engineers`会来定义`754`号规范里的二进制浮点数算数标准，其中的公式是`V = (-1)^s * M * 2^E`，`V`是二进制浮点数表示方法，`s`是符号(`0`代表正数，`1`代表负数)，`M`是有效数字，`E`代表了指数(往左移动为正，往右为负)，为许多`CPU`与浮点运算器所采用。
- 变量的声明有`var`，`const`，`let`关键字，都与预编译，作用域以及提升有关系。声明式是把值绑定给标识符号的过程，语句是执行任务行为。`var`后来没有归类到声明式的原因是存在了特殊的情况，会产生作用域的副作用，即无法避免地去创建全局作用域属性的，这种副作用交叉性太强会导致非常多的问题，所以后来`ES6`规范中对其声明式的作用进行移除，使用`const`或`let`来代替。
- 块是`ES6`提出的，是一个大括号。外部无法访问大括号内部定义的变量。目的是封装独立的作用域。块级作用域生效的条件是在严格模式下，或者是模块内部。
- `var`在`ES3`使用的原因是`JavaScript`借助了数学对变量的表述，`const`和`let`并非在`ES6`的时候才提出，而在`ES3`草案时提出。`ES3`在设计语言方面存在极大的问题，在早期浏览器无法承载太多的脚本代码，没有单独的`JS`引擎，早期与渲染引擎一起来做语法分析，超过十几行代码就会崩溃，所以对变量声明上并不会做出区分，`const`和`let`在`JavaScript`中需要有复杂的语言分析的机制，如果列入到代码里会使内存溢出，对`CPU`造成很大的性能损耗，而且渲染本身也需要耗费很大的性能，导致早期的`JavaScript`设计必须要简单。
- 在浏览器性能方面，`var`关键字是比较贴切于`JavaScript`作为一门动态脚本语言，宿主是浏览器环境，浏览器不可能作为一个编译器去编译强类型语言再转为弱类型再去转机器码。针对宿主为浏览器的脚本必须设计的简单化，动态化，这样才可以让浏览器作为解释器有效的去解释和执行脚本代码，并节省开支。所以在`ES3.1`版本时也也没有通过新增`let`，`const`的草案。
- 在语言本身复杂度方面，对于浏览器对新语法的支持上以及浏览器厂商对规范的支持等问题只能选择`var`声明，并不希望把脚本语言的规范做的更加的复杂，而且早期的业务场景需求较为单一，仅是对`DOM`的操作的动态操作。到如今，`ES6`对`const`和`let`的新增是对日益硬件技术的提升的发展需求的补充。
- `let`声明块级作用域的局部变量，`ES6`模块化中的模块也是一个块级作用域，默认严格模式，`window`对象访问是`undefined`。在`ES6`中的块级作用域与`ES3`的立即执行函数创建的作用域性质是一样的，为了保证变量没有全局污染的一个解决方案。
- 标识符被重复声明的报错。在`ES6`中，对`ES3`的`var`的重复赋值是不合理的，所以才新增了`let`声明来让变量可以被重复赋值。
- 在预编译过程`var`声明的变量会提升，会存在短暂的暂时性死区。而`JS`系统中，`undefined`是唯一自动化生成的默认值。预编译阶段拿到声明，但不进行初始化`undefined`或者是其他的值，而初始化的过程放到执行期阶段为了解决声明后可访问变量的问题。
- `const`声明常量的关键字，`const`声明的变量并不能重新被赋值。指向引用值，内部属性可删除或更改。如果是常量性质，命名时要大写。如果是变量性质，命名时用小驼峰写法。
- `ES6`解决方法是`for`循环中初始块用了`let`触发并创建特殊的一种作用域机制，在每次迭代的时候，系统会为`for`的`loop`本体创建一个词法作用域，在词法作用域中新`let`声明一个`i`，将上一次迭代或初始化的值赋值给新的`i`变量，对新词法作用域内的`i`进行操作，如`i++`，这就是形成块作用域的原因。
- `JavaScript`是一门基于对象的语言，但并不是真正面向对象的编程语言。把具有相同属性和行为的事物抽象成一个事物类别，通过实例化，让这个事物类别构造成一个具体的事物对象。
- 面向对象是以创建对象为基础，利用对象完成程序的集成。有一个工具来创建对象，这个对象提供一系列的属性，这些属性帮助开发者完成程序中的功能。最大的特点是具有复用性，每次创建一个新的引用对象，不会造成对象之间的互相引用。
- 面向对象的简称是`OOP`，对象面向编程`Object Oriented Programming`的思想。面向对象具有封装性，继承性，多态性的三大特性。
- 面向对象与`new`关键字相关，`JS`引擎通过`new`关键字执行一个函数并返回一个新的对象。`new`过程相当于是执行一个函数，函数内部定义一个对象，给这个对象的属性进行赋值，再将对象返回外界，这就是实例化一个对象的过程。
- 对于`new`关键字实例化时，实际上省略了内部创建对象，会返回对象的部分，仅需要定义对象属性。在构造函数执行时，会产生一个执行期上下文`this`，并确定指向的对象。在严格模式或模块化脚本中`this`为`undefined`。在非严格模式下，`this`默认指向`window`对象。`this`关键字是一个指针，如内存中栈指向堆地址。
- 在`JavaScript`中，函数都可以充当创建对象的工具，叫构造函数，构造一个新的对象的函数，写法是`new Xxx()`。在开发过程中，注意约定规范，大驼峰命名函数名称，默认为一个构造函数`constructor`。
- 一个函数的声明是一个引用值，`typeof function(){}`结果也是一个对象，在`JavaScript`中的对象都可以使用`.`语法或`['xxx']`进行访问，所以可以给函数引用对象新增属性。在函数上挂载属性的方式叫静态添加属性，该属性叫静态属性或静态方法。
- 在函数上默认具有`prototype`静态原型属性，值是一个对象，也可以是一个数组，也可以是一个函数，主要为了函数充当`prototype`对象的构造器。
- 实例对象可以通过原型继承可将定义在静态属性的方法内部中的`this`指向实例对象。通过继承的原型链可以找到原型内部的属性和方法，不需要通过`xx.__proto__`去访问也可以拿到原型上的属性和方法。
- 直接给构造函数的`this`对象新增方法会存在弊端。当每一次`new`实例化都会在`this`对象中新增新的函数引用，但是一般来说方法都是固定不变的，是静态的，所以没有必要每次实例化都创建新的方法。可以将方法作为一个静态的方法定义在原型上，此面向对象设计写法可以节省开销。

## 第三周

| **日期** |   **早**   |   **午**    |    **晚**    |       **复习内容**       | **完成度** |
| :------: | :--------: | :---------: | :----------: | :----------------------: | :--------: |
| 5月15日  |  有序数据  |  无序数据   |     循环     | `XMLHttpRequest`兼容问题 |    70%     |
| 5月16日  |  枚举封装  | `arguments` | `parseInt()` |       `xhr`的事件        |    80%     |
| 5月17日  |   副作用   |   纯函数    | 函数提纯案例 |      `responseText`      |    70%     |
| 5月18日  |  函数组合  |   结合律    | `pointfree`  |      `responseXML`       |    60%     |
| 5月19日  |  高阶函数  |   柯里化    |  柯里化封装  |      `axios`拦截器       |    70%     |
| 5月20日  | 闭包与设计 | 闭包与设计  |  闭包与设计  |    `express`应用创建     |    70%     |
| 5月21日  |    复习    |    复习     |     复习     |           复习           |     0%     |

**知识整理：**

- 循环是计算机底层提供的一种多次运行同一程序的一种功能，`for`循环是这种功能的接口。迭代的存在必须建立在遍历循环的基础上，每一次遍历的过程中的每一个部分叫做一次迭代，它是**有序**的。
- 遍历是针对一组数据而进行的按顺序抽取的行为。枚举是概率学上的一个名称，分为单次枚举和多次枚举，把一个集合中的**无序**状态的成员逐一抽取的过程。
- 循环机制和循环方法的区别，循环机制如`for`仅仅是一个机制，可以提供`break`，`continue`，`return`控制循环的功能，它不参与数据的读取和修改。
- `forEach`是一个遍历方法，它针对于数据，并确保遍历过程的完整性，所以从职能来讲，`forEach`并不能具备循环机制的功能。
- 数组和字符串是有序列表的，数据意义来自于顺序，它可以迭代。对象是无序列表，不可以迭代。
- 在`ES6`的模块化之前，**类数组**最早广泛用于`DOM`，具有顺序的一种对象结构，有序的对象存储节点以外还保存了属性和方法，但同时也有数组的操作方法和索引。
- 在循环中获取对象的键值和键名的写法，一般来说，在`for`循环中是难以拿到一个对象的属性。因此可以结合`for`和`Object.keys()`来获取对象的键名和键值。但是`Object.keys()`是有弊端的，它无法拿到被`Object.defineProperty()`定义的`enumerable`为`false`的属性。解决方法是用更底层的`Object.getOwnProperyNames()`方法可以拿到不能枚举的属性。
- `parseInt(string, Radix)`方法解析一个字符串并返回指定基数的十进制整数。基数`Radix`是`2-36`之间的整数，要解析成整数的字符串是多少进制的，把进制数转换成十进制整数。
- 副作用针对函数来说，副作用函数不仅仅返回了一个值，还做了其他的事情，如`DOM`操作，操作系统文件，操作数据库，发送`HTTP`请求，打印日志，修改全局变量等。
- 副作用存在的目的不主要是对副作用的完全消除，而是避免不应该出现的副作用。假如函数没有副作用，那么程序只能进行计算，同时也是一个纯函数。
- 原生`JavaScript`方法中的数组`map()`方法返回新的数组，不会修改原数组，不产生副作用，而`pop()`方法会修改原数组，产生了副作用，想要没有副作用得对参数先进行深拷贝，然后返回计算后的新的拷贝数据到外部。
- 引用透明性与副作用经常一起出现，对于一个纯函数而言，给定相同的参数，返回值都相同，所以可以用计算值代替纯函数的调用，用计算结果代替表达式的能力。
- 纯函数是相同的输入得到相同的输出，不依赖且不影响外部环境也不产生任何副作用，简而言之，输出完全取决于输入。纯函数使用场景是可提纯则提纯，不行不强求。
- 输入和输出的数据都是显性的。函数与外界交换数据的唯一渠道是通过参数和返回值，函数从外部接收到所有的数据都由参数传入函数内部，函数内部到外部的数据通过返回值传递到函数外部。对象会被修改数据，如不想被更改原有数据，需要克隆原有数据再修改，深度克隆的函数也是纯函数。
- 纯函数的优点`1`，可移植性高，如`utils.js`中的工具函数。
- 纯函数的优点`2`，合理性(引用透明)，函数看起来合理，易读。
- 纯函数的优点`3`，并行执行，因为纯函数不依赖外部环境并没有副作用，理论上可以同时运行。在服务端运行时，使用了线程概念，对函数进行同步运行。
- 纯函数的优点`4`，可缓存性，返回一个函数作为闭包。
- 函数组合它也叫饲养函数(`compose`)，饲养高品质的函数做优质的输出，用一个新的函数把其他功能的函数组合起来后可以一次性解决这些函数的单个函数要解决的问题。若干个纯函数，偏函数，柯里化函数组合成一个新的函数形成数据传递，并实现一种有序执行的效果。
- 左倾方式是函数参数自右向左边执行函数的方式。`compose`组合函数创建的从右到左的数据流，数据经过`g`函数的执行变成另外的数据，该数据作为参数又传入`f`函数的执行变成另外的数据。
- `Associativity`，**结合律**是在组合函数的参数中再进行分组，它和原来函数组合得出的结果是一样的。
- `pointfree`，饲养组合函数的风格，无值形态是对于即将处理的数据是未知的。`f`函数并不是构造出来的，而是通过饲养函数处理后的数据返回回来的。而且`f`函数是不需要传入参数即可以获取数据。一种与参数无关的形式去合成运算，每一个简单函数运算步骤都是一个运算。
- `pointfree`本质是一些通用的函数组合出各种复杂的运算，上层的运算不直接处理数据而是通过底层函数去处理，由多个单独封装后的函数再组合成一个运算的管道，从右向左的执行产生一个新的数据。
- 只要函数的参数是函数，或者返回值是函数的形式时，都成为高阶函数。`JavaScript`函数实际上都是会指向某一个变量，变量可以指向一个函数。
- 高阶函数的好处是便于扩展，对功能的抽象并进行单独维护，当一个函数的参数是一个回调函数是，外部是可以对此回调函数执行时进行拓展。函数的抽象并不一定作为一个完全独立的函数体，也可以作为一个相互依赖的程序。
- 高阶函数的另外一个函数可以作为尾调函数。一个方法执行完毕后的行为由高阶函数中的参数进行编写。
- 柯里化是函数编程的思想。`curry`，在计算机科学中，柯里化接受多个参数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
- 经过柯里化函数的封装，可以把很多东西封装起来，简化代码。柯里化总是返回新的函数，这个函数是在函数体内部产生的，实际上提高了维护性，而且逻辑性更强。
- 一个复杂的函数可能仅仅是一个功能体，但作用不仅仅是完成一个任务，有可能完成更多的任务，但这些任务仅通过一个程序去完成。柯里化可以**延迟**函数的执行，先完成前面的任务，在适当的时机时再去完成后续的任务。
- 所有实现的功能都在函数内部去完成体现了功能内聚。
- 当需要完成多功能的程序时，有可能需要声明全局变量，也有可能在函数声明多个变量，就会产生耦合的情况，柯里化使用了闭包的形式可以降低耦合。
- 其实有时候程序是可以复用的，柯里化在完成任务的时候实际上都是用同一个函数内部的方法去完成同一件事情，可以降低代码的重复性。
- 一个函数适应性很强，适用于多个大型项目中使用，柯里化的延迟执行可以把一部分的功能先实现，当在适当的时机可以通过参数去对该函数适应性进行调整去进行后续的程序。

## 第四周

| **日期** | **早** |   **午**   |   **晚**   |    **复习内容**    | **完成度** |
| :------: | :----: | :--------: | :--------: | :----------------: | :--------: |
| 5月22日  | 偏函数 | 偏函数区别 | 柯里化函数 | `express`定义路由  |     0%     |
| 5月23日  | 待计划 |   待计划   |   待计划   | `express.Router()` |     0%     |
| 5月24日  | 待计划 |   待计划   |   待计划   |    路由逻辑抽离    |     0%     |
| 5月25日  | 待计划 |   待计划   |   待计划   |    定义视图模版    |     0%     |
| 5月26日  | 待计划 |   待计划   |   待计划   |      请求对象      |     0%     |
| 5月27日  | 待计划 |   待计划   |   待计划   | `express().use()`  |     0%     |
| 5月28日  |  复习  |    复习    |    复习    |        复习        |     0%     |

**知识整理：**
